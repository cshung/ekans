#include <ekans.h>

void f1(ekans_value* env, ekans_value** pReturn);
void f2(ekans_value* env, ekans_value** pReturn);
void f3(ekans_value* env, ekans_value** pReturn);
void f4(ekans_value* env, ekans_value** pReturn);
void f5(ekans_value* env, ekans_value** pReturn);
void f6(ekans_value* env, ekans_value** pReturn);
void f7(ekans_value* env, ekans_value** pReturn);
void f8(ekans_value* env, ekans_value** pReturn);
void f9(ekans_value* env, ekans_value** pReturn);
void f10(ekans_value* env, ekans_value** pReturn);
void f11(ekans_value* env, ekans_value** pReturn);
void f12(ekans_value* env, ekans_value** pReturn);
void f13(ekans_value* env, ekans_value** pReturn);
void f14(ekans_value* env, ekans_value** pReturn);
void f15(ekans_value* env, ekans_value** pReturn);
void f16(ekans_value* env, ekans_value** pReturn);
void f17(ekans_value* env, ekans_value** pReturn);
void f18(ekans_value* env, ekans_value** pReturn);
void f19(ekans_value* env, ekans_value** pReturn);
void f20(ekans_value* env, ekans_value** pReturn);
void f21(ekans_value* env, ekans_value** pReturn);
void f22(ekans_value* env, ekans_value** pReturn);
void f23(ekans_value* env, ekans_value** pReturn);
void f24(ekans_value* env, ekans_value** pReturn);
void f25(ekans_value* env, ekans_value** pReturn);
void f26(ekans_value* env, ekans_value** pReturn);
void f27(ekans_value* env, ekans_value** pReturn);
void f28(ekans_value* env, ekans_value** pReturn);
void f29(ekans_value* env, ekans_value** pReturn);
void f30(ekans_value* env, ekans_value** pReturn);
void f31(ekans_value* env, ekans_value** pReturn);
void f32(ekans_value* env, ekans_value** pReturn);
void f33(ekans_value* env, ekans_value** pReturn);
void f34(ekans_value* env, ekans_value** pReturn);
void f35(ekans_value* env, ekans_value** pReturn);
void f36(ekans_value* env, ekans_value** pReturn);
void f37(ekans_value* env, ekans_value** pReturn);
void f38(ekans_value* env, ekans_value** pReturn);
void f39(ekans_value* env, ekans_value** pReturn);
void f40(ekans_value* env, ekans_value** pReturn);
void f41(ekans_value* env, ekans_value** pReturn);
void f42(ekans_value* env, ekans_value** pReturn);
void f43(ekans_value* env, ekans_value** pReturn);
void f44(ekans_value* env, ekans_value** pReturn);
void f45(ekans_value* env, ekans_value** pReturn);
void f46(ekans_value* env, ekans_value** pReturn);
void f47(ekans_value* env, ekans_value** pReturn);
void f48(ekans_value* env, ekans_value** pReturn);
void f49(ekans_value* env, ekans_value** pReturn);
void f50(ekans_value* env, ekans_value** pReturn);
void f51(ekans_value* env, ekans_value** pReturn);
void f52(ekans_value* env, ekans_value** pReturn);
void f53(ekans_value* env, ekans_value** pReturn);
void f54(ekans_value* env, ekans_value** pReturn);
void f55(ekans_value* env, ekans_value** pReturn);
void f56(ekans_value* env, ekans_value** pReturn);
void f57(ekans_value* env, ekans_value** pReturn);
void f58(ekans_value* env, ekans_value** pReturn);
void f59(ekans_value* env, ekans_value** pReturn);
void f60(ekans_value* env, ekans_value** pReturn);
void f61(ekans_value* env, ekans_value** pReturn);
void f62(ekans_value* env, ekans_value** pReturn);
void f63(ekans_value* env, ekans_value** pReturn);
void f64(ekans_value* env, ekans_value** pReturn);
void f65(ekans_value* env, ekans_value** pReturn);
void f66(ekans_value* env, ekans_value** pReturn);
void f67(ekans_value* env, ekans_value** pReturn);
void f68(ekans_value* env, ekans_value** pReturn);
void f69(ekans_value* env, ekans_value** pReturn);
void f70(ekans_value* env, ekans_value** pReturn);
void f71(ekans_value* env, ekans_value** pReturn);
void f72(ekans_value* env, ekans_value** pReturn);
void f73(ekans_value* env, ekans_value** pReturn);
void f74(ekans_value* env, ekans_value** pReturn);
void f75(ekans_value* env, ekans_value** pReturn);
void f76(ekans_value* env, ekans_value** pReturn);
void f77(ekans_value* env, ekans_value** pReturn);
void f78(ekans_value* env, ekans_value** pReturn);
void f79(ekans_value* env, ekans_value** pReturn);
void f80(ekans_value* env, ekans_value** pReturn);
void f81(ekans_value* env, ekans_value** pReturn);
void f82(ekans_value* env, ekans_value** pReturn);
void f83(ekans_value* env, ekans_value** pReturn);
void f84(ekans_value* env, ekans_value** pReturn);
void f85(ekans_value* env, ekans_value** pReturn);
void f86(ekans_value* env, ekans_value** pReturn);
void f87(ekans_value* env, ekans_value** pReturn);
void f88(ekans_value* env, ekans_value** pReturn);
void f89(ekans_value* env, ekans_value** pReturn);
void f90(ekans_value* env, ekans_value** pReturn);
void f91(ekans_value* env, ekans_value** pReturn);
void f92(ekans_value* env, ekans_value** pReturn);
void f93(ekans_value* env, ekans_value** pReturn);
void f94(ekans_value* env, ekans_value** pReturn);
void f95(ekans_value* env, ekans_value** pReturn);
void f96(ekans_value* env, ekans_value** pReturn);
void f97(ekans_value* env, ekans_value** pReturn);
void f98(ekans_value* env, ekans_value** pReturn);
void f99(ekans_value* env, ekans_value** pReturn);
void f100(ekans_value* env, ekans_value** pReturn);
void f101(ekans_value* env, ekans_value** pReturn);
void f102(ekans_value* env, ekans_value** pReturn);
void f103(ekans_value* env, ekans_value** pReturn);
void f104(ekans_value* env, ekans_value** pReturn);
void f105(ekans_value* env, ekans_value** pReturn);
void f106(ekans_value* env, ekans_value** pReturn);
void f107(ekans_value* env, ekans_value** pReturn);
void f108(ekans_value* env, ekans_value** pReturn);
void f109(ekans_value* env, ekans_value** pReturn);
void f110(ekans_value* env, ekans_value** pReturn);
void f111(ekans_value* env, ekans_value** pReturn);
void f112(ekans_value* env, ekans_value** pReturn);
void f113(ekans_value* env, ekans_value** pReturn);
void f114(ekans_value* env, ekans_value** pReturn);
void f115(ekans_value* env, ekans_value** pReturn);
void f116(ekans_value* env, ekans_value** pReturn);
void f117(ekans_value* env, ekans_value** pReturn);
void f118(ekans_value* env, ekans_value** pReturn);
void f119(ekans_value* env, ekans_value** pReturn);
void f120(ekans_value* env, ekans_value** pReturn);
void f121(ekans_value* env, ekans_value** pReturn);
void f122(ekans_value* env, ekans_value** pReturn);
void f123(ekans_value* env, ekans_value** pReturn);
void f124(ekans_value* env, ekans_value** pReturn);
void f125(ekans_value* env, ekans_value** pReturn);
void f126(ekans_value* env, ekans_value** pReturn);
void f127(ekans_value* env, ekans_value** pReturn);
void f128(ekans_value* env, ekans_value** pReturn);
void f129(ekans_value* env, ekans_value** pReturn);
void f130(ekans_value* env, ekans_value** pReturn);
void f131(ekans_value* env, ekans_value** pReturn);
void f132(ekans_value* env, ekans_value** pReturn);
void f133(ekans_value* env, ekans_value** pReturn);
void f134(ekans_value* env, ekans_value** pReturn);
void f135(ekans_value* env, ekans_value** pReturn);
void f136(ekans_value* env, ekans_value** pReturn);
void f137(ekans_value* env, ekans_value** pReturn);
void f138(ekans_value* env, ekans_value** pReturn);
void f139(ekans_value* env, ekans_value** pReturn);
void f140(ekans_value* env, ekans_value** pReturn);
void f141(ekans_value* env, ekans_value** pReturn);
void f142(ekans_value* env, ekans_value** pReturn);
void f143(ekans_value* env, ekans_value** pReturn);
void f144(ekans_value* env, ekans_value** pReturn);
void f145(ekans_value* env, ekans_value** pReturn);
void f146(ekans_value* env, ekans_value** pReturn);
void f147(ekans_value* env, ekans_value** pReturn);
void f148(ekans_value* env, ekans_value** pReturn);
void f149(ekans_value* env, ekans_value** pReturn);
void f150(ekans_value* env, ekans_value** pReturn);
void f151(ekans_value* env, ekans_value** pReturn);
void f152(ekans_value* env, ekans_value** pReturn);
void f153(ekans_value* env, ekans_value** pReturn);
void f154(ekans_value* env, ekans_value** pReturn);
void f155(ekans_value* env, ekans_value** pReturn);
void f156(ekans_value* env, ekans_value** pReturn);
void f157(ekans_value* env, ekans_value** pReturn);
void f158(ekans_value* env, ekans_value** pReturn);
void f159(ekans_value* env, ekans_value** pReturn);
void f160(ekans_value* env, ekans_value** pReturn);
void f161(ekans_value* env, ekans_value** pReturn);
void f162(ekans_value* env, ekans_value** pReturn);
void f163(ekans_value* env, ekans_value** pReturn);
void f164(ekans_value* env, ekans_value** pReturn);
void f165(ekans_value* env, ekans_value** pReturn);
void f166(ekans_value* env, ekans_value** pReturn);
void f167(ekans_value* env, ekans_value** pReturn);
void f168(ekans_value* env, ekans_value** pReturn);
void f169(ekans_value* env, ekans_value** pReturn);
void f170(ekans_value* env, ekans_value** pReturn);
void f171(ekans_value* env, ekans_value** pReturn);
void f172(ekans_value* env, ekans_value** pReturn);
void f173(ekans_value* env, ekans_value** pReturn);
void f174(ekans_value* env, ekans_value** pReturn);
void f175(ekans_value* env, ekans_value** pReturn);
void f176(ekans_value* env, ekans_value** pReturn);
void f177(ekans_value* env, ekans_value** pReturn);
void f178(ekans_value* env, ekans_value** pReturn);
void f179(ekans_value* env, ekans_value** pReturn);
void f180(ekans_value* env, ekans_value** pReturn);
void f181(ekans_value* env, ekans_value** pReturn);
void f182(ekans_value* env, ekans_value** pReturn);
void f183(ekans_value* env, ekans_value** pReturn);
void f184(ekans_value* env, ekans_value** pReturn);
void f185(ekans_value* env, ekans_value** pReturn);
void f186(ekans_value* env, ekans_value** pReturn);
void f187(ekans_value* env, ekans_value** pReturn);
void f188(ekans_value* env, ekans_value** pReturn);
void f189(ekans_value* env, ekans_value** pReturn);
void f190(ekans_value* env, ekans_value** pReturn);
void f191(ekans_value* env, ekans_value** pReturn);
void f192(ekans_value* env, ekans_value** pReturn);
void f193(ekans_value* env, ekans_value** pReturn);
void f194(ekans_value* env, ekans_value** pReturn);
void f195(ekans_value* env, ekans_value** pReturn);
void f196(ekans_value* env, ekans_value** pReturn);
void f197(ekans_value* env, ekans_value** pReturn);
void f198(ekans_value* env, ekans_value** pReturn);
void f199(ekans_value* env, ekans_value** pReturn);
void f200(ekans_value* env, ekans_value** pReturn);
void f201(ekans_value* env, ekans_value** pReturn);
void f202(ekans_value* env, ekans_value** pReturn);
void f203(ekans_value* env, ekans_value** pReturn);
void f204(ekans_value* env, ekans_value** pReturn);
void f205(ekans_value* env, ekans_value** pReturn);
void f206(ekans_value* env, ekans_value** pReturn);
void f207(ekans_value* env, ekans_value** pReturn);
void f208(ekans_value* env, ekans_value** pReturn);
void f209(ekans_value* env, ekans_value** pReturn);
void f210(ekans_value* env, ekans_value** pReturn);
void f211(ekans_value* env, ekans_value** pReturn);
void f212(ekans_value* env, ekans_value** pReturn);
void f213(ekans_value* env, ekans_value** pReturn);
void f214(ekans_value* env, ekans_value** pReturn);
void f215(ekans_value* env, ekans_value** pReturn);
void f216(ekans_value* env, ekans_value** pReturn);
void f217(ekans_value* env, ekans_value** pReturn);
void f218(ekans_value* env, ekans_value** pReturn);
void f219(ekans_value* env, ekans_value** pReturn);
void f220(ekans_value* env, ekans_value** pReturn);
void f221(ekans_value* env, ekans_value** pReturn);
void f222(ekans_value* env, ekans_value** pReturn);
void f223(ekans_value* env, ekans_value** pReturn);
void f224(ekans_value* env, ekans_value** pReturn);
void f225(ekans_value* env, ekans_value** pReturn);
void f226(ekans_value* env, ekans_value** pReturn);
void f227(ekans_value* env, ekans_value** pReturn);
void f228(ekans_value* env, ekans_value** pReturn);
void f229(ekans_value* env, ekans_value** pReturn);
void f230(ekans_value* env, ekans_value** pReturn);
void f231(ekans_value* env, ekans_value** pReturn);
void f232(ekans_value* env, ekans_value** pReturn);
void f233(ekans_value* env, ekans_value** pReturn);
void f234(ekans_value* env, ekans_value** pReturn);
void f235(ekans_value* env, ekans_value** pReturn);
void f236(ekans_value* env, ekans_value** pReturn);
void f237(ekans_value* env, ekans_value** pReturn);
void f238(ekans_value* env, ekans_value** pReturn);
void f239(ekans_value* env, ekans_value** pReturn);
void f240(ekans_value* env, ekans_value** pReturn);
void f241(ekans_value* env, ekans_value** pReturn);
void f242(ekans_value* env, ekans_value** pReturn);
void f243(ekans_value* env, ekans_value** pReturn);
void f244(ekans_value* env, ekans_value** pReturn);
void f245(ekans_value* env, ekans_value** pReturn);
void f246(ekans_value* env, ekans_value** pReturn);
void f247(ekans_value* env, ekans_value** pReturn);
void f248(ekans_value* env, ekans_value** pReturn);
void f249(ekans_value* env, ekans_value** pReturn);
void f250(ekans_value* env, ekans_value** pReturn);
void f251(ekans_value* env, ekans_value** pReturn);
void f252(ekans_value* env, ekans_value** pReturn);
void f253(ekans_value* env, ekans_value** pReturn);
void f254(ekans_value* env, ekans_value** pReturn);
void f255(ekans_value* env, ekans_value** pReturn);
void f256(ekans_value* env, ekans_value** pReturn);
void f257(ekans_value* env, ekans_value** pReturn);
void f258(ekans_value* env, ekans_value** pReturn);
void f259(ekans_value* env, ekans_value** pReturn);
void f260(ekans_value* env, ekans_value** pReturn);
void f261(ekans_value* env, ekans_value** pReturn);
void f262(ekans_value* env, ekans_value** pReturn);
void f263(ekans_value* env, ekans_value** pReturn);
void f264(ekans_value* env, ekans_value** pReturn);
void f265(ekans_value* env, ekans_value** pReturn);
void f266(ekans_value* env, ekans_value** pReturn);
void f267(ekans_value* env, ekans_value** pReturn);
void f268(ekans_value* env, ekans_value** pReturn);
void f269(ekans_value* env, ekans_value** pReturn);
void f270(ekans_value* env, ekans_value** pReturn);
void f271(ekans_value* env, ekans_value** pReturn);
void f272(ekans_value* env, ekans_value** pReturn);
void f273(ekans_value* env, ekans_value** pReturn);
void f274(ekans_value* env, ekans_value** pReturn);
void f275(ekans_value* env, ekans_value** pReturn);
void f276(ekans_value* env, ekans_value** pReturn);
void f277(ekans_value* env, ekans_value** pReturn);
void f278(ekans_value* env, ekans_value** pReturn);
void f279(ekans_value* env, ekans_value** pReturn);
void f280(ekans_value* env, ekans_value** pReturn);
void f281(ekans_value* env, ekans_value** pReturn);
void f282(ekans_value* env, ekans_value** pReturn);
void f283(ekans_value* env, ekans_value** pReturn);
void f284(ekans_value* env, ekans_value** pReturn);
void f285(ekans_value* env, ekans_value** pReturn);
void f286(ekans_value* env, ekans_value** pReturn);
void f287(ekans_value* env, ekans_value** pReturn);
void f288(ekans_value* env, ekans_value** pReturn);
void f289(ekans_value* env, ekans_value** pReturn);
void f290(ekans_value* env, ekans_value** pReturn);
void f291(ekans_value* env, ekans_value** pReturn);
void f292(ekans_value* env, ekans_value** pReturn);
void f293(ekans_value* env, ekans_value** pReturn);
void f294(ekans_value* env, ekans_value** pReturn);
void f295(ekans_value* env, ekans_value** pReturn);
void f296(ekans_value* env, ekans_value** pReturn);
void f297(ekans_value* env, ekans_value** pReturn);
void f298(ekans_value* env, ekans_value** pReturn);
void f299(ekans_value* env, ekans_value** pReturn);
void f300(ekans_value* env, ekans_value** pReturn);
void f301(ekans_value* env, ekans_value** pReturn);
void f302(ekans_value* env, ekans_value** pReturn);
void f303(ekans_value* env, ekans_value** pReturn);
void f304(ekans_value* env, ekans_value** pReturn);
void f305(ekans_value* env, ekans_value** pReturn);
void f306(ekans_value* env, ekans_value** pReturn);
void f307(ekans_value* env, ekans_value** pReturn);
void f308(ekans_value* env, ekans_value** pReturn);
void f309(ekans_value* env, ekans_value** pReturn);
void f310(ekans_value* env, ekans_value** pReturn);
void f311(ekans_value* env, ekans_value** pReturn);

// The symbol table for this function is:
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f1(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  ekans_value* v66 = NULL;
  push_stack_slot(&v66);
  ekans_value* v67 = NULL;
  push_stack_slot(&v67);
  ekans_value* v68 = NULL;
  push_stack_slot(&v68);
  ekans_value* v69 = NULL;
  push_stack_slot(&v69);
  ekans_value* v70 = NULL;
  push_stack_slot(&v70);
  ekans_value* v71 = NULL;
  push_stack_slot(&v71);
  ekans_value* v72 = NULL;
  push_stack_slot(&v72);
  ekans_value* v73 = NULL;
  push_stack_slot(&v73);
  ekans_value* v74 = NULL;
  push_stack_slot(&v74);
  ekans_value* v75 = NULL;
  push_stack_slot(&v75);
  ekans_value* v76 = NULL;
  push_stack_slot(&v76);
  ekans_value* v77 = NULL;
  push_stack_slot(&v77);
  ekans_value* v78 = NULL;
  push_stack_slot(&v78);
  ekans_value* v79 = NULL;
  push_stack_slot(&v79);
  ekans_value* v80 = NULL;
  push_stack_slot(&v80);
  ekans_value* v81 = NULL;
  push_stack_slot(&v81);
  ekans_value* v82 = NULL;
  push_stack_slot(&v82);
  ekans_value* v83 = NULL;
  push_stack_slot(&v83);
  ekans_value* v84 = NULL;
  push_stack_slot(&v84);
  ekans_value* v85 = NULL;
  push_stack_slot(&v85);
  ekans_value* v86 = NULL;
  push_stack_slot(&v86);
  ekans_value* v87 = NULL;
  push_stack_slot(&v87);
  ekans_value* v88 = NULL;
  push_stack_slot(&v88);
  ekans_value* v89 = NULL;
  push_stack_slot(&v89);
  ekans_value* v90 = NULL;
  push_stack_slot(&v90);
  ekans_value* v91 = NULL;
  push_stack_slot(&v91);
  ekans_value* v92 = NULL;
  push_stack_slot(&v92);
  ekans_value* v93 = NULL;
  push_stack_slot(&v93);
  ekans_value* v94 = NULL;
  push_stack_slot(&v94);
  ekans_value* v95 = NULL;
  push_stack_slot(&v95);
  ekans_value* v96 = NULL;
  push_stack_slot(&v96);
  ekans_value* v97 = NULL;
  push_stack_slot(&v97);
  ekans_value* v98 = NULL;
  push_stack_slot(&v98);
  ekans_value* v99 = NULL;
  push_stack_slot(&v99);
  ekans_value* v100 = NULL;
  push_stack_slot(&v100);
  ekans_value* v101 = NULL;
  push_stack_slot(&v101);
  ekans_value* v102 = NULL;
  push_stack_slot(&v102);
  ekans_value* v103 = NULL;
  push_stack_slot(&v103);
  ekans_value* v104 = NULL;
  push_stack_slot(&v104);
  ekans_value* v105 = NULL;
  push_stack_slot(&v105);
  ekans_value* v106 = NULL;
  push_stack_slot(&v106);
  ekans_value* v107 = NULL;
  push_stack_slot(&v107);
  ekans_value* v108 = NULL;
  push_stack_slot(&v108);
  ekans_value* v109 = NULL;
  push_stack_slot(&v109);
  ekans_value* v110 = NULL;
  push_stack_slot(&v110);
  ekans_value* v111 = NULL;
  push_stack_slot(&v111);
  ekans_value* v112 = NULL;
  push_stack_slot(&v112);
  ekans_value* v113 = NULL;
  push_stack_slot(&v113);
  ekans_value* v114 = NULL;
  push_stack_slot(&v114);
  ekans_value* v115 = NULL;
  push_stack_slot(&v115);
  ekans_value* v116 = NULL;
  push_stack_slot(&v116);
  ekans_value* v117 = NULL;
  push_stack_slot(&v117);
  ekans_value* v118 = NULL;
  push_stack_slot(&v118);
  ekans_value* v119 = NULL;
  push_stack_slot(&v119);
  ekans_value* v120 = NULL;
  push_stack_slot(&v120);
  ekans_value* v121 = NULL;
  push_stack_slot(&v121);
  ekans_value* v122 = NULL;
  push_stack_slot(&v122);
  ekans_value* v123 = NULL;
  push_stack_slot(&v123);
  ekans_value* v124 = NULL;
  push_stack_slot(&v124);
  ekans_value* v125 = NULL;
  push_stack_slot(&v125);
  ekans_value* v126 = NULL;
  push_stack_slot(&v126);
  ekans_value* v127 = NULL;
  push_stack_slot(&v127);
  ekans_value* v128 = NULL;
  push_stack_slot(&v128);
  ekans_value* v129 = NULL;
  push_stack_slot(&v129);
  ekans_value* v130 = NULL;
  push_stack_slot(&v130);
  ekans_value* v131 = NULL;
  push_stack_slot(&v131);
  ekans_value* v132 = NULL;
  push_stack_slot(&v132);
  ekans_value* v133 = NULL;
  push_stack_slot(&v133);
  ekans_value* v134 = NULL;
  push_stack_slot(&v134);
  ekans_value* v135 = NULL;
  push_stack_slot(&v135);
  ekans_value* v136 = NULL;
  push_stack_slot(&v136);
  ekans_value* v137 = NULL;
  push_stack_slot(&v137);
  ekans_value* v138 = NULL;
  push_stack_slot(&v138);
  ekans_value* v139 = NULL;
  push_stack_slot(&v139);
  ekans_value* v140 = NULL;
  push_stack_slot(&v140);
  ekans_value* v141 = NULL;
  push_stack_slot(&v141);
  ekans_value* v142 = NULL;
  push_stack_slot(&v142);
  ekans_value* v143 = NULL;
  push_stack_slot(&v143);
  ekans_value* v144 = NULL;
  push_stack_slot(&v144);
  ekans_value* v145 = NULL;
  push_stack_slot(&v145);
  ekans_value* v146 = NULL;
  push_stack_slot(&v146);
  ekans_value* v147 = NULL;
  push_stack_slot(&v147);
  ekans_value* v148 = NULL;
  push_stack_slot(&v148);
  ekans_value* v149 = NULL;
  push_stack_slot(&v149);
  ekans_value* v150 = NULL;
  push_stack_slot(&v150);
  ekans_value* v151 = NULL;
  push_stack_slot(&v151);
  ekans_value* v152 = NULL;
  push_stack_slot(&v152);
  ekans_value* v153 = NULL;
  push_stack_slot(&v153);
  ekans_value* v154 = NULL;
  push_stack_slot(&v154);
  ekans_value* v155 = NULL;
  push_stack_slot(&v155);
  ekans_value* v156 = NULL;
  push_stack_slot(&v156);
  ekans_value* v157 = NULL;
  push_stack_slot(&v157);
  ekans_value* v158 = NULL;
  push_stack_slot(&v158);
  ekans_value* v159 = NULL;
  push_stack_slot(&v159);
  ekans_value* v160 = NULL;
  push_stack_slot(&v160);
  ekans_value* v161 = NULL;
  push_stack_slot(&v161);
  ekans_value* v162 = NULL;
  push_stack_slot(&v162);
  ekans_value* v163 = NULL;
  push_stack_slot(&v163);
  ekans_value* v164 = NULL;
  push_stack_slot(&v164);
  ekans_value* v165 = NULL;
  push_stack_slot(&v165);
  ekans_value* v166 = NULL;
  push_stack_slot(&v166);
  ekans_value* v167 = NULL;
  push_stack_slot(&v167);
  ekans_value* v168 = NULL;
  push_stack_slot(&v168);
  ekans_value* v169 = NULL;
  push_stack_slot(&v169);
  ekans_value* v170 = NULL;
  push_stack_slot(&v170);
  ekans_value* v171 = NULL;
  push_stack_slot(&v171);
  ekans_value* v172 = NULL;
  push_stack_slot(&v172);
  ekans_value* v173 = NULL;
  push_stack_slot(&v173);
  ekans_value* v174 = NULL;
  push_stack_slot(&v174);
  ekans_value* v175 = NULL;
  push_stack_slot(&v175);
  ekans_value* v176 = NULL;
  push_stack_slot(&v176);
  ekans_value* v177 = NULL;
  push_stack_slot(&v177);
  ekans_value* v178 = NULL;
  push_stack_slot(&v178);
  ekans_value* v179 = NULL;
  push_stack_slot(&v179);
  ekans_value* v180 = NULL;
  push_stack_slot(&v180);
  ekans_value* v181 = NULL;
  push_stack_slot(&v181);
  ekans_value* v182 = NULL;
  push_stack_slot(&v182);
  ekans_value* v183 = NULL;
  push_stack_slot(&v183);
  ekans_value* v184 = NULL;
  push_stack_slot(&v184);
  ekans_value* v185 = NULL;
  push_stack_slot(&v185);
  ekans_value* v186 = NULL;
  push_stack_slot(&v186);
  ekans_value* v187 = NULL;
  push_stack_slot(&v187);
  ekans_value* v188 = NULL;
  push_stack_slot(&v188);
  ekans_value* v189 = NULL;
  push_stack_slot(&v189);
  ekans_value* v190 = NULL;
  push_stack_slot(&v190);
  ekans_value* v191 = NULL;
  push_stack_slot(&v191);
  ekans_value* v192 = NULL;
  push_stack_slot(&v192);
  ekans_value* v193 = NULL;
  push_stack_slot(&v193);
  ekans_value* v194 = NULL;
  push_stack_slot(&v194);
  ekans_value* v195 = NULL;
  push_stack_slot(&v195);
  ekans_value* v196 = NULL;
  push_stack_slot(&v196);
  ekans_value* v197 = NULL;
  push_stack_slot(&v197);
  ekans_value* v198 = NULL;
  push_stack_slot(&v198);
  ekans_value* v199 = NULL;
  push_stack_slot(&v199);
  ekans_value* v200 = NULL;
  push_stack_slot(&v200);
  ekans_value* v201 = NULL;
  push_stack_slot(&v201);
  ekans_value* v202 = NULL;
  push_stack_slot(&v202);
  ekans_value* v203 = NULL;
  push_stack_slot(&v203);
  ekans_value* v204 = NULL;
  push_stack_slot(&v204);
  ekans_value* v205 = NULL;
  push_stack_slot(&v205);
  ekans_value* v206 = NULL;
  push_stack_slot(&v206);
  ekans_value* v207 = NULL;
  push_stack_slot(&v207);
  ekans_value* v208 = NULL;
  push_stack_slot(&v208);
  ekans_value* v209 = NULL;
  push_stack_slot(&v209);
  ekans_value* v210 = NULL;
  push_stack_slot(&v210);
  ekans_value* v211 = NULL;
  push_stack_slot(&v211);
  ekans_value* v212 = NULL;
  push_stack_slot(&v212);
  ekans_value* v213 = NULL;
  push_stack_slot(&v213);
  ekans_value* v214 = NULL;
  push_stack_slot(&v214);
  ekans_value* v215 = NULL;
  push_stack_slot(&v215);
  ekans_value* v216 = NULL;
  push_stack_slot(&v216);
  ekans_value* v217 = NULL;
  push_stack_slot(&v217);
  ekans_value* v218 = NULL;
  push_stack_slot(&v218);
  ekans_value* v219 = NULL;
  push_stack_slot(&v219);
  ekans_value* v220 = NULL;
  push_stack_slot(&v220);
  ekans_value* v221 = NULL;
  push_stack_slot(&v221);
  ekans_value* v222 = NULL;
  push_stack_slot(&v222);
  ekans_value* v223 = NULL;
  push_stack_slot(&v223);
  ekans_value* v224 = NULL;
  push_stack_slot(&v224);
  ekans_value* v225 = NULL;
  push_stack_slot(&v225);
  ekans_value* v226 = NULL;
  push_stack_slot(&v226);
  ekans_value* v227 = NULL;
  push_stack_slot(&v227);
  ekans_value* v228 = NULL;
  push_stack_slot(&v228);
  ekans_value* v229 = NULL;
  push_stack_slot(&v229);
  ekans_value* v230 = NULL;
  push_stack_slot(&v230);
  ekans_value* v231 = NULL;
  push_stack_slot(&v231);
  ekans_value* v232 = NULL;
  push_stack_slot(&v232);
  ekans_value* v233 = NULL;
  push_stack_slot(&v233);
  ekans_value* v234 = NULL;
  push_stack_slot(&v234);
  ekans_value* v235 = NULL;
  push_stack_slot(&v235);
  ekans_value* v236 = NULL;
  push_stack_slot(&v236);
  ekans_value* v237 = NULL;
  push_stack_slot(&v237);
  ekans_value* v238 = NULL;
  push_stack_slot(&v238);
  ekans_value* v239 = NULL;
  push_stack_slot(&v239);
  ekans_value* v240 = NULL;
  push_stack_slot(&v240);
  ekans_value* v241 = NULL;
  push_stack_slot(&v241);
  ekans_value* v242 = NULL;
  push_stack_slot(&v242);
  ekans_value* v243 = NULL;
  push_stack_slot(&v243);
  ekans_value* v244 = NULL;
  push_stack_slot(&v244);
  ekans_value* v245 = NULL;
  push_stack_slot(&v245);
  ekans_value* v246 = NULL;
  push_stack_slot(&v246);
  ekans_value* v247 = NULL;
  push_stack_slot(&v247);
  ekans_value* v248 = NULL;
  push_stack_slot(&v248);
  ekans_value* v249 = NULL;
  push_stack_slot(&v249);
  ekans_value* v250 = NULL;
  push_stack_slot(&v250);
  ekans_value* v251 = NULL;
  push_stack_slot(&v251);
  ekans_value* v252 = NULL;
  push_stack_slot(&v252);
  ekans_value* v253 = NULL;
  push_stack_slot(&v253);
  ekans_value* v254 = NULL;
  push_stack_slot(&v254);
  ekans_value* v255 = NULL;
  push_stack_slot(&v255);
  ekans_value* v256 = NULL;
  push_stack_slot(&v256);
  ekans_value* v257 = NULL;
  push_stack_slot(&v257);
  ekans_value* v258 = NULL;
  push_stack_slot(&v258);
  ekans_value* v259 = NULL;
  push_stack_slot(&v259);
  ekans_value* v260 = NULL;
  push_stack_slot(&v260);
  ekans_value* v261 = NULL;
  push_stack_slot(&v261);
  ekans_value* v262 = NULL;
  push_stack_slot(&v262);
  ekans_value* v263 = NULL;
  push_stack_slot(&v263);
  ekans_value* v264 = NULL;
  push_stack_slot(&v264);
  ekans_value* v265 = NULL;
  push_stack_slot(&v265);
  ekans_value* v266 = NULL;
  push_stack_slot(&v266);
  ekans_value* v267 = NULL;
  push_stack_slot(&v267);
  ekans_value* v268 = NULL;
  push_stack_slot(&v268);
  ekans_value* v269 = NULL;
  push_stack_slot(&v269);
  ekans_value* v270 = NULL;
  push_stack_slot(&v270);
  ekans_value* v271 = NULL;
  push_stack_slot(&v271);
  ekans_value* v272 = NULL;
  push_stack_slot(&v272);
  ekans_value* v273 = NULL;
  push_stack_slot(&v273);
  ekans_value* v274 = NULL;
  push_stack_slot(&v274);
  ekans_value* v275 = NULL;
  push_stack_slot(&v275);
  ekans_value* v276 = NULL;
  push_stack_slot(&v276);
  ekans_value* v277 = NULL;
  push_stack_slot(&v277);
  ekans_value* v278 = NULL;
  push_stack_slot(&v278);
  ekans_value* v279 = NULL;
  push_stack_slot(&v279);
  ekans_value* v280 = NULL;
  push_stack_slot(&v280);
  ekans_value* v281 = NULL;
  push_stack_slot(&v281);
  ekans_value* v282 = NULL;
  push_stack_slot(&v282);
  ekans_value* v283 = NULL;
  push_stack_slot(&v283);
  ekans_value* v284 = NULL;
  push_stack_slot(&v284);
  ekans_value* v285 = NULL;
  push_stack_slot(&v285);
  ekans_value* v286 = NULL;
  push_stack_slot(&v286);
  ekans_value* v287 = NULL;
  push_stack_slot(&v287);
  ekans_value* v288 = NULL;
  push_stack_slot(&v288);
  ekans_value* v289 = NULL;
  push_stack_slot(&v289);
  ekans_value* v290 = NULL;
  push_stack_slot(&v290);
  ekans_value* v291 = NULL;
  push_stack_slot(&v291);
  ekans_value* v292 = NULL;
  push_stack_slot(&v292);
  ekans_value* v293 = NULL;
  push_stack_slot(&v293);
  ekans_value* v294 = NULL;
  push_stack_slot(&v294);
  ekans_value* v295 = NULL;
  push_stack_slot(&v295);
  ekans_value* v296 = NULL;
  push_stack_slot(&v296);
  ekans_value* v297 = NULL;
  push_stack_slot(&v297);
  ekans_value* v298 = NULL;
  push_stack_slot(&v298);
  ekans_value* v299 = NULL;
  push_stack_slot(&v299);
  ekans_value* v300 = NULL;
  push_stack_slot(&v300);
  ekans_value* v301 = NULL;
  push_stack_slot(&v301);
  ekans_value* v302 = NULL;
  push_stack_slot(&v302);
  ekans_value* v303 = NULL;
  push_stack_slot(&v303);
  ekans_value* v304 = NULL;
  push_stack_slot(&v304);
  ekans_value* v305 = NULL;
  push_stack_slot(&v305);
  ekans_value* v306 = NULL;
  push_stack_slot(&v306);
  ekans_value* v307 = NULL;
  push_stack_slot(&v307);
  ekans_value* v308 = NULL;
  push_stack_slot(&v308);
  ekans_value* v309 = NULL;
  push_stack_slot(&v309);
  ekans_value* v310 = NULL;
  push_stack_slot(&v310);
  ekans_value* v311 = NULL;
  push_stack_slot(&v311);
  ekans_value* v312 = NULL;
  push_stack_slot(&v312);
  ekans_value* v313 = NULL;
  push_stack_slot(&v313);
  ekans_value* v314 = NULL;
  push_stack_slot(&v314);
  ekans_value* v315 = NULL;
  push_stack_slot(&v315);
  ekans_value* v316 = NULL;
  push_stack_slot(&v316);
  ekans_value* v317 = NULL;
  push_stack_slot(&v317);
  ekans_value* v318 = NULL;
  push_stack_slot(&v318);
  ekans_value* v319 = NULL;
  push_stack_slot(&v319);
  ekans_value* v320 = NULL;
  push_stack_slot(&v320);
  ekans_value* v321 = NULL;
  push_stack_slot(&v321);
  ekans_value* v322 = NULL;
  push_stack_slot(&v322);
  ekans_value* v323 = NULL;
  push_stack_slot(&v323);
  ekans_value* v324 = NULL;
  push_stack_slot(&v324);
  ekans_value* v325 = NULL;
  push_stack_slot(&v325);
  ekans_value* v326 = NULL;
  push_stack_slot(&v326);
  ekans_value* v327 = NULL;
  push_stack_slot(&v327);
  ekans_value* v328 = NULL;
  push_stack_slot(&v328);
  ekans_value* v329 = NULL;
  push_stack_slot(&v329);
  ekans_value* v330 = NULL;
  push_stack_slot(&v330);
  ekans_value* v331 = NULL;
  push_stack_slot(&v331);
  ekans_value* v332 = NULL;
  push_stack_slot(&v332);
  ekans_value* v333 = NULL;
  push_stack_slot(&v333);
  ekans_value* v334 = NULL;
  push_stack_slot(&v334);
  ekans_value* v335 = NULL;
  push_stack_slot(&v335);
  ekans_value* v336 = NULL;
  push_stack_slot(&v336);
  ekans_value* v337 = NULL;
  push_stack_slot(&v337);
  ekans_value* v338 = NULL;
  push_stack_slot(&v338);
  ekans_value* v339 = NULL;
  push_stack_slot(&v339);
  ekans_value* v340 = NULL;
  push_stack_slot(&v340);
  ekans_value* v341 = NULL;
  push_stack_slot(&v341);
  ekans_value* v342 = NULL;
  push_stack_slot(&v342);
  ekans_value* v343 = NULL;
  push_stack_slot(&v343);
  ekans_value* v344 = NULL;
  push_stack_slot(&v344);
  ekans_value* v345 = NULL;
  push_stack_slot(&v345);
  ekans_value* v346 = NULL;
  push_stack_slot(&v346);
  ekans_value* v347 = NULL;
  push_stack_slot(&v347);
  ekans_value* v348 = NULL;
  push_stack_slot(&v348);
  ekans_value* v349 = NULL;
  push_stack_slot(&v349);
  ekans_value* v350 = NULL;
  push_stack_slot(&v350);
  ekans_value* v351 = NULL;
  push_stack_slot(&v351);
  ekans_value* v352 = NULL;
  push_stack_slot(&v352);
  ekans_value* v353 = NULL;
  push_stack_slot(&v353);
  ekans_value* v354 = NULL;
  push_stack_slot(&v354);
  ekans_value* v355 = NULL;
  push_stack_slot(&v355);
  ekans_value* v356 = NULL;
  push_stack_slot(&v356);
  ekans_value* v357 = NULL;
  push_stack_slot(&v357);
  ekans_value* v358 = NULL;
  push_stack_slot(&v358);
  ekans_value* v359 = NULL;
  push_stack_slot(&v359);
  ekans_value* v360 = NULL;
  push_stack_slot(&v360);
  ekans_value* v361 = NULL;
  push_stack_slot(&v361);
  ekans_value* v362 = NULL;
  push_stack_slot(&v362);
  ekans_value* v363 = NULL;
  push_stack_slot(&v363);
  ekans_value* v364 = NULL;
  push_stack_slot(&v364);
  ekans_value* v365 = NULL;
  push_stack_slot(&v365);
  ekans_value* v366 = NULL;
  push_stack_slot(&v366);
  ekans_value* v367 = NULL;
  push_stack_slot(&v367);
  ekans_value* v368 = NULL;
  push_stack_slot(&v368);
  ekans_value* v369 = NULL;
  push_stack_slot(&v369);
  ekans_value* v370 = NULL;
  push_stack_slot(&v370);
  ekans_value* v371 = NULL;
  push_stack_slot(&v371);
  ekans_value* v372 = NULL;
  push_stack_slot(&v372);
  ekans_value* v373 = NULL;
  push_stack_slot(&v373);
  ekans_value* v374 = NULL;
  push_stack_slot(&v374);
  ekans_value* v375 = NULL;
  push_stack_slot(&v375);
  ekans_value* v376 = NULL;
  push_stack_slot(&v376);
  ekans_value* v377 = NULL;
  push_stack_slot(&v377);
  ekans_value* v378 = NULL;
  push_stack_slot(&v378);
  ekans_value* v379 = NULL;
  push_stack_slot(&v379);
  ekans_value* v380 = NULL;
  push_stack_slot(&v380);
  ekans_value* v381 = NULL;
  push_stack_slot(&v381);
  ekans_value* v382 = NULL;
  push_stack_slot(&v382);
  ekans_value* v383 = NULL;
  push_stack_slot(&v383);
  ekans_value* v384 = NULL;
  push_stack_slot(&v384);
  ekans_value* v385 = NULL;
  push_stack_slot(&v385);
  ekans_value* v386 = NULL;
  push_stack_slot(&v386);
  ekans_value* v387 = NULL;
  push_stack_slot(&v387);
  ekans_value* v388 = NULL;
  push_stack_slot(&v388);
  ekans_value* v389 = NULL;
  push_stack_slot(&v389);
  ekans_value* v390 = NULL;
  push_stack_slot(&v390);
  ekans_value* v391 = NULL;
  push_stack_slot(&v391);
  ekans_value* v392 = NULL;
  push_stack_slot(&v392);
  ekans_value* v393 = NULL;
  push_stack_slot(&v393);
  ekans_value* v394 = NULL;
  push_stack_slot(&v394);
  ekans_value* v395 = NULL;
  push_stack_slot(&v395);
  ekans_value* v396 = NULL;
  push_stack_slot(&v396);
  ekans_value* v397 = NULL;
  push_stack_slot(&v397);
  ekans_value* v398 = NULL;
  push_stack_slot(&v398);
  ekans_value* v399 = NULL;
  push_stack_slot(&v399);
  ekans_value* v400 = NULL;
  push_stack_slot(&v400);
  ekans_value* v401 = NULL;
  push_stack_slot(&v401);
  ekans_value* v402 = NULL;
  push_stack_slot(&v402);
  ekans_value* v403 = NULL;
  push_stack_slot(&v403);
  ekans_value* v404 = NULL;
  push_stack_slot(&v404);
  ekans_value* v405 = NULL;
  push_stack_slot(&v405);
  ekans_value* v406 = NULL;
  push_stack_slot(&v406);
  ekans_value* v407 = NULL;
  push_stack_slot(&v407);
  ekans_value* v408 = NULL;
  push_stack_slot(&v408);
  ekans_value* v409 = NULL;
  push_stack_slot(&v409);
  ekans_value* v410 = NULL;
  push_stack_slot(&v410);
  ekans_value* v411 = NULL;
  push_stack_slot(&v411);
  ekans_value* v412 = NULL;
  push_stack_slot(&v412);
  ekans_value* v413 = NULL;
  push_stack_slot(&v413);
  ekans_value* v414 = NULL;
  push_stack_slot(&v414);
  ekans_value* v415 = NULL;
  push_stack_slot(&v415);
  ekans_value* v416 = NULL;
  push_stack_slot(&v416);
  ekans_value* v417 = NULL;
  push_stack_slot(&v417);
  ekans_value* v418 = NULL;
  push_stack_slot(&v418);
  ekans_value* v419 = NULL;
  push_stack_slot(&v419);
  ekans_value* v420 = NULL;
  push_stack_slot(&v420);
  ekans_value* v421 = NULL;
  push_stack_slot(&v421);
  ekans_value* v422 = NULL;
  push_stack_slot(&v422);
  ekans_value* v423 = NULL;
  push_stack_slot(&v423);
  ekans_value* v424 = NULL;
  push_stack_slot(&v424);
  ekans_value* v425 = NULL;
  push_stack_slot(&v425);
  ekans_value* v426 = NULL;
  push_stack_slot(&v426);
  ekans_value* v427 = NULL;
  push_stack_slot(&v427);
  ekans_value* v428 = NULL;
  push_stack_slot(&v428);
  ekans_value* v429 = NULL;
  push_stack_slot(&v429);
  ekans_value* v430 = NULL;
  push_stack_slot(&v430);
  ekans_value* v431 = NULL;
  push_stack_slot(&v431);
  ekans_value* v432 = NULL;
  push_stack_slot(&v432);
  ekans_value* v433 = NULL;
  push_stack_slot(&v433);
  ekans_value* v434 = NULL;
  push_stack_slot(&v434);
  ekans_value* v435 = NULL;
  push_stack_slot(&v435);
  ekans_value* v436 = NULL;
  push_stack_slot(&v436);
  ekans_value* v437 = NULL;
  push_stack_slot(&v437);
  ekans_value* v438 = NULL;
  push_stack_slot(&v438);
  ekans_value* v439 = NULL;
  push_stack_slot(&v439);
  ekans_value* v440 = NULL;
  push_stack_slot(&v440);
  ekans_value* v441 = NULL;
  push_stack_slot(&v441);
  ekans_value* v442 = NULL;
  push_stack_slot(&v442);
  ekans_value* v443 = NULL;
  push_stack_slot(&v443);
  ekans_value* v444 = NULL;
  push_stack_slot(&v444);
  ekans_value* v445 = NULL;
  push_stack_slot(&v445);
  ekans_value* v446 = NULL;
  push_stack_slot(&v446);
  ekans_value* v447 = NULL;
  push_stack_slot(&v447);
  ekans_value* v448 = NULL;
  push_stack_slot(&v448);
  ekans_value* v449 = NULL;
  push_stack_slot(&v449);
  ekans_value* v450 = NULL;
  push_stack_slot(&v450);
  ekans_value* v451 = NULL;
  push_stack_slot(&v451);
  ekans_value* v452 = NULL;
  push_stack_slot(&v452);
  ekans_value* v453 = NULL;
  push_stack_slot(&v453);
  ekans_value* v454 = NULL;
  push_stack_slot(&v454);
  ekans_value* v455 = NULL;
  push_stack_slot(&v455);
  ekans_value* v456 = NULL;
  push_stack_slot(&v456);
  ekans_value* v457 = NULL;
  push_stack_slot(&v457);
  ekans_value* v458 = NULL;
  push_stack_slot(&v458);
  ekans_value* v459 = NULL;
  push_stack_slot(&v459);
  ekans_value* v460 = NULL;
  push_stack_slot(&v460);
  ekans_value* v461 = NULL;
  push_stack_slot(&v461);
  ekans_value* v462 = NULL;
  push_stack_slot(&v462);
  ekans_value* v463 = NULL;
  push_stack_slot(&v463);
  ekans_value* v464 = NULL;
  push_stack_slot(&v464);
  ekans_value* v465 = NULL;
  push_stack_slot(&v465);
  ekans_value* v466 = NULL;
  push_stack_slot(&v466);
  ekans_value* v467 = NULL;
  push_stack_slot(&v467);
  ekans_value* v468 = NULL;
  push_stack_slot(&v468);
  ekans_value* v469 = NULL;
  push_stack_slot(&v469);
  ekans_value* v470 = NULL;
  push_stack_slot(&v470);
  ekans_value* v471 = NULL;
  push_stack_slot(&v471);
  ekans_value* v472 = NULL;
  push_stack_slot(&v472);
  ekans_value* v473 = NULL;
  push_stack_slot(&v473);
  ekans_value* v474 = NULL;
  push_stack_slot(&v474);
  ekans_value* v475 = NULL;
  push_stack_slot(&v475);
  ekans_value* v476 = NULL;
  push_stack_slot(&v476);
  ekans_value* v477 = NULL;
  push_stack_slot(&v477);
  ekans_value* v478 = NULL;
  push_stack_slot(&v478);
  ekans_value* v479 = NULL;
  push_stack_slot(&v479);
  ekans_value* v480 = NULL;
  push_stack_slot(&v480);
  ekans_value* v481 = NULL;
  push_stack_slot(&v481);
  ekans_value* v482 = NULL;
  push_stack_slot(&v482);
  ekans_value* v483 = NULL;
  push_stack_slot(&v483);
  ekans_value* v484 = NULL;
  push_stack_slot(&v484);
  ekans_value* v485 = NULL;
  push_stack_slot(&v485);
  ekans_value* v486 = NULL;
  push_stack_slot(&v486);
  ekans_value* v487 = NULL;
  push_stack_slot(&v487);
  ekans_value* v488 = NULL;
  push_stack_slot(&v488);
  ekans_value* v489 = NULL;
  push_stack_slot(&v489);
  ekans_value* v490 = NULL;
  push_stack_slot(&v490);
  ekans_value* v491 = NULL;
  push_stack_slot(&v491);
  ekans_value* v492 = NULL;
  push_stack_slot(&v492);
  ekans_value* v493 = NULL;
  push_stack_slot(&v493);
  ekans_value* v494 = NULL;
  push_stack_slot(&v494);
  ekans_value* v495 = NULL;
  push_stack_slot(&v495);
  ekans_value* v496 = NULL;
  push_stack_slot(&v496);
  ekans_value* v497 = NULL;
  push_stack_slot(&v497);
  ekans_value* v498 = NULL;
  push_stack_slot(&v498);
  ekans_value* v499 = NULL;
  push_stack_slot(&v499);
  ekans_value* v500 = NULL;
  push_stack_slot(&v500);
  ekans_value* v501 = NULL;
  push_stack_slot(&v501);
  ekans_value* v502 = NULL;
  push_stack_slot(&v502);
  ekans_value* v503 = NULL;
  push_stack_slot(&v503);
  ekans_value* v504 = NULL;
  push_stack_slot(&v504);
  ekans_value* v505 = NULL;
  push_stack_slot(&v505);
  ekans_value* v506 = NULL;
  push_stack_slot(&v506);
  ekans_value* v507 = NULL;
  push_stack_slot(&v507);
  ekans_value* v508 = NULL;
  push_stack_slot(&v508);
  ekans_value* v509 = NULL;
  push_stack_slot(&v509);
  ekans_value* v510 = NULL;
  push_stack_slot(&v510);
  ekans_value* v511 = NULL;
  push_stack_slot(&v511);
  ekans_value* v512 = NULL;
  push_stack_slot(&v512);
  ekans_value* v513 = NULL;
  push_stack_slot(&v513);
  ekans_value* v514 = NULL;
  push_stack_slot(&v514);
  ekans_value* v515 = NULL;
  push_stack_slot(&v515);
  ekans_value* v516 = NULL;
  push_stack_slot(&v516);
  ekans_value* v517 = NULL;
  push_stack_slot(&v517);
  ekans_value* v518 = NULL;
  push_stack_slot(&v518);
  ekans_value* v519 = NULL;
  push_stack_slot(&v519);
  ekans_value* v520 = NULL;
  push_stack_slot(&v520);
  ekans_value* v521 = NULL;
  push_stack_slot(&v521);
  ekans_value* v522 = NULL;
  push_stack_slot(&v522);
  ekans_value* v523 = NULL;
  push_stack_slot(&v523);
  ekans_value* v524 = NULL;
  push_stack_slot(&v524);
  ekans_value* v525 = NULL;
  push_stack_slot(&v525);
  ekans_value* v526 = NULL;
  push_stack_slot(&v526);
  ekans_value* v527 = NULL;
  push_stack_slot(&v527);
  ekans_value* v528 = NULL;
  push_stack_slot(&v528);
  ekans_value* v529 = NULL;
  push_stack_slot(&v529);
  ekans_value* v530 = NULL;
  push_stack_slot(&v530);
  ekans_value* v531 = NULL;
  push_stack_slot(&v531);
  ekans_value* v532 = NULL;
  push_stack_slot(&v532);
  ekans_value* v533 = NULL;
  push_stack_slot(&v533);
  ekans_value* v534 = NULL;
  push_stack_slot(&v534);
  ekans_value* v535 = NULL;
  push_stack_slot(&v535);
  ekans_value* v536 = NULL;
  push_stack_slot(&v536);
  ekans_value* v537 = NULL;
  push_stack_slot(&v537);
  ekans_value* v538 = NULL;
  push_stack_slot(&v538);
  ekans_value* v539 = NULL;
  push_stack_slot(&v539);
  ekans_value* v540 = NULL;
  push_stack_slot(&v540);
  ekans_value* v541 = NULL;
  push_stack_slot(&v541);
  ekans_value* v542 = NULL;
  push_stack_slot(&v542);
  ekans_value* v543 = NULL;
  push_stack_slot(&v543);
  ekans_value* v544 = NULL;
  push_stack_slot(&v544);
  ekans_value* v545 = NULL;
  push_stack_slot(&v545);
  ekans_value* v546 = NULL;
  push_stack_slot(&v546);
  ekans_value* v547 = NULL;
  push_stack_slot(&v547);
  ekans_value* v548 = NULL;
  push_stack_slot(&v548);
  ekans_value* v549 = NULL;
  push_stack_slot(&v549);
  ekans_value* v550 = NULL;
  push_stack_slot(&v550);
  ekans_value* v551 = NULL;
  push_stack_slot(&v551);
  ekans_value* v552 = NULL;
  push_stack_slot(&v552);
  ekans_value* v553 = NULL;
  push_stack_slot(&v553);
  ekans_value* v554 = NULL;
  push_stack_slot(&v554);
  ekans_value* v555 = NULL;
  push_stack_slot(&v555);
  ekans_value* v556 = NULL;
  push_stack_slot(&v556);
  ekans_value* v557 = NULL;
  push_stack_slot(&v557);
  ekans_value* v558 = NULL;
  push_stack_slot(&v558);
  ekans_value* v559 = NULL;
  push_stack_slot(&v559);
  ekans_value* v560 = NULL;
  push_stack_slot(&v560);
  ekans_value* v561 = NULL;
  push_stack_slot(&v561);
  ekans_value* v562 = NULL;
  push_stack_slot(&v562);
  ekans_value* v563 = NULL;
  push_stack_slot(&v563);
  ekans_value* v564 = NULL;
  push_stack_slot(&v564);
  ekans_value* v565 = NULL;
  push_stack_slot(&v565);
  ekans_value* v566 = NULL;
  push_stack_slot(&v566);
  ekans_value* v567 = NULL;
  push_stack_slot(&v567);
  ekans_value* v568 = NULL;
  push_stack_slot(&v568);
  ekans_value* v569 = NULL;
  push_stack_slot(&v569);
  ekans_value* v570 = NULL;
  push_stack_slot(&v570);
  ekans_value* v571 = NULL;
  push_stack_slot(&v571);
  ekans_value* v572 = NULL;
  push_stack_slot(&v572);
  ekans_value* v573 = NULL;
  push_stack_slot(&v573);
  ekans_value* v574 = NULL;
  push_stack_slot(&v574);
  ekans_value* v575 = NULL;
  push_stack_slot(&v575);
  ekans_value* v576 = NULL;
  push_stack_slot(&v576);
  ekans_value* v577 = NULL;
  push_stack_slot(&v577);
  ekans_value* v578 = NULL;
  push_stack_slot(&v578);
  ekans_value* v579 = NULL;
  push_stack_slot(&v579);
  ekans_value* v580 = NULL;
  push_stack_slot(&v580);
  ekans_value* v581 = NULL;
  push_stack_slot(&v581);
  ekans_value* v582 = NULL;
  push_stack_slot(&v582);
  ekans_value* v583 = NULL;
  push_stack_slot(&v583);
  ekans_value* v584 = NULL;
  push_stack_slot(&v584);
  ekans_value* v585 = NULL;
  push_stack_slot(&v585);
  ekans_value* v586 = NULL;
  push_stack_slot(&v586);
  ekans_value* v587 = NULL;
  push_stack_slot(&v587);
  ekans_value* v588 = NULL;
  push_stack_slot(&v588);
  ekans_value* v589 = NULL;
  push_stack_slot(&v589);
  ekans_value* v590 = NULL;
  push_stack_slot(&v590);
  ekans_value* v591 = NULL;
  push_stack_slot(&v591);
  ekans_value* v592 = NULL;
  push_stack_slot(&v592);
  ekans_value* v593 = NULL;
  push_stack_slot(&v593);
  ekans_value* v594 = NULL;
  push_stack_slot(&v594);
  ekans_value* v595 = NULL;
  push_stack_slot(&v595);
  ekans_value* v596 = NULL;
  push_stack_slot(&v596);
  ekans_value* v597 = NULL;
  push_stack_slot(&v597);
  ekans_value* v598 = NULL;
  push_stack_slot(&v598);
  ekans_value* v599 = NULL;
  push_stack_slot(&v599);
  ekans_value* v600 = NULL;
  push_stack_slot(&v600);
  ekans_value* v601 = NULL;
  push_stack_slot(&v601);
  ekans_value* v602 = NULL;
  push_stack_slot(&v602);
  ekans_value* v603 = NULL;
  push_stack_slot(&v603);
  ekans_value* v604 = NULL;
  push_stack_slot(&v604);
  ekans_value* v605 = NULL;
  push_stack_slot(&v605);
  ekans_value* v606 = NULL;
  push_stack_slot(&v606);
  ekans_value* v607 = NULL;
  push_stack_slot(&v607);
  ekans_value* v608 = NULL;
  push_stack_slot(&v608);
  ekans_value* v609 = NULL;
  push_stack_slot(&v609);
  ekans_value* v610 = NULL;
  push_stack_slot(&v610);
  ekans_value* v611 = NULL;
  push_stack_slot(&v611);
  ekans_value* v612 = NULL;
  push_stack_slot(&v612);
  ekans_value* v613 = NULL;
  push_stack_slot(&v613);
  ekans_value* v614 = NULL;
  push_stack_slot(&v614);
  ekans_value* v615 = NULL;
  push_stack_slot(&v615);
  ekans_value* v616 = NULL;
  push_stack_slot(&v616);
  ekans_value* v617 = NULL;
  push_stack_slot(&v617);
  ekans_value* v618 = NULL;
  push_stack_slot(&v618);
  ekans_value* v619 = NULL;
  push_stack_slot(&v619);
  ekans_value* v620 = NULL;
  push_stack_slot(&v620);
  ekans_value* v621 = NULL;
  push_stack_slot(&v621);
  ekans_value* v622 = NULL;
  push_stack_slot(&v622);
  ekans_value* v623 = NULL;
  push_stack_slot(&v623);
  ekans_value* v624 = NULL;
  push_stack_slot(&v624);
  ekans_value* v625 = NULL;
  push_stack_slot(&v625);
  ekans_value* v626 = NULL;
  push_stack_slot(&v626);
  ekans_value* v627 = NULL;
  push_stack_slot(&v627);
  ekans_value* v628 = NULL;
  push_stack_slot(&v628);
  ekans_value* v629 = NULL;
  push_stack_slot(&v629);
// Adding defines here:
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)
  create_environment(env, 89, &v1);
  env = v1;
  create_closure(env, f2, &v2);
  set_environment(env, 0, v2);
  create_closure(env, f3, &v3);
  set_environment(env, 1, v3);
  // looking up the value for get-args
  get_environment(env, 1, 18, &v4);
  closure_of(v4, &v5);
  // preparing environment with 0 slots for call
  create_environment(v5, 0, &v6);
  function_of(v4)(v6, &v7);
  set_environment(env, 2, v7);
  create_closure(env, f4, &v8);
  set_environment(env, 3, v8);
  create_closure(env, f5, &v9);
  set_environment(env, 4, v9);
  create_closure(env, f6, &v10);
  set_environment(env, 5, v10);
  create_string_value("(define (map f lst) (if (null? lst) '() (cons (f (car lst)) (map f (cdr lst))))) (define (length lst) (if (null? lst) 0 (+ 1 (length (cdr lst)))))(define args (get-args))(define (filter pred lst)(cond[(null? lst) '()][(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))][else (filter pred (cdr lst))]))(define (append lst1 lst2)(if (null? lst1)lst2(cons (car lst1) (append (cdr lst1) lst2))))(define (reverse lst)(define (helper lst acc)(if (null? lst)acc(helper (cdr lst) (cons (car lst) acc))))(helper lst '()))", &v11);
  set_environment(env, 6, v11);
  create_closure(env, f7, &v12);
  set_environment(env, 7, v12);
  create_closure(env, f8, &v13);
  set_environment(env, 8, v13);
  create_char_value('(', &v14);
  set_environment(env, 9, v14);
  create_char_value(')', &v15);
  set_environment(env, 10, v15);
  create_string_value("{", &v16);
  set_environment(env, 11, v16);
  create_string_value("}", &v17);
  set_environment(env, 12, v17);
  create_char_value('[', &v18);
  set_environment(env, 13, v18);
  create_char_value(']', &v19);
  set_environment(env, 14, v19);
  create_string_value("", &v20);
  set_environment(env, 15, v20);
  create_boolean_value(true, &v21);
  set_environment(env, 16, v21);
  create_boolean_value(false, &v22);
  set_environment(env, 17, v22);
  create_closure(env, f9, &v23);
  set_environment(env, 18, v23);
  create_closure(env, f10, &v24);
  set_environment(env, 19, v24);
  create_closure(env, f11, &v25);
  set_environment(env, 20, v25);
  create_closure(env, f12, &v26);
  set_environment(env, 21, v26);
  create_closure(env, f13, &v27);
  set_environment(env, 22, v27);
  create_closure(env, f14, &v28);
  set_environment(env, 23, v28);
  create_closure(env, f15, &v29);
  set_environment(env, 24, v29);
  create_closure(env, f16, &v30);
  set_environment(env, 25, v30);
  create_closure(env, f17, &v31);
  set_environment(env, 26, v31);
  create_closure(env, f18, &v32);
  set_environment(env, 27, v32);
  create_closure(env, f19, &v33);
  set_environment(env, 28, v33);
  create_closure(env, f20, &v34);
  set_environment(env, 29, v34);
  create_closure(env, f21, &v35);
  set_environment(env, 30, v35);
  create_closure(env, f22, &v36);
  set_environment(env, 31, v36);
  create_closure(env, f23, &v37);
  set_environment(env, 32, v37);
  create_closure(env, f24, &v38);
  set_environment(env, 33, v38);
  create_closure(env, f25, &v39);
  set_environment(env, 34, v39);
  create_closure(env, f26, &v40);
  set_environment(env, 35, v40);
  create_closure(env, f27, &v41);
  set_environment(env, 36, v41);
  create_closure(env, f28, &v42);
  set_environment(env, 37, v42);
  create_closure(env, f29, &v43);
  set_environment(env, 38, v43);
  create_closure(env, f30, &v44);
  set_environment(env, 39, v44);
  create_closure(env, f31, &v45);
  set_environment(env, 40, v45);
  create_closure(env, f32, &v46);
  set_environment(env, 41, v46);
  create_closure(env, f33, &v47);
  set_environment(env, 42, v47);
  create_closure(env, f34, &v48);
  set_environment(env, 43, v48);
  create_closure(env, f35, &v49);
  set_environment(env, 44, v49);
  create_closure(env, f36, &v50);
  set_environment(env, 45, v50);
  create_closure(env, f37, &v51);
  set_environment(env, 46, v51);
  create_closure(env, f38, &v52);
  set_environment(env, 47, v52);
  create_closure(env, f39, &v53);
  set_environment(env, 48, v53);
  create_closure(env, f40, &v54);
  set_environment(env, 49, v54);
  create_closure(env, f41, &v55);
  set_environment(env, 50, v55);
  create_closure(env, f42, &v56);
  set_environment(env, 51, v56);
  create_closure(env, f43, &v57);
  set_environment(env, 52, v57);
  create_closure(env, f44, &v58);
  set_environment(env, 53, v58);
  create_closure(env, f45, &v59);
  set_environment(env, 54, v59);
  create_closure(env, f46, &v60);
  set_environment(env, 55, v60);
  create_closure(env, f47, &v61);
  set_environment(env, 56, v61);
  create_closure(env, f48, &v62);
  set_environment(env, 57, v62);
  create_closure(env, f49, &v63);
  set_environment(env, 58, v63);
  create_closure(env, f50, &v64);
  set_environment(env, 59, v64);
  create_closure(env, f51, &v65);
  set_environment(env, 60, v65);
  create_closure(env, f52, &v66);
  set_environment(env, 61, v66);
  create_closure(env, f53, &v67);
  set_environment(env, 62, v67);
  create_closure(env, f54, &v68);
  set_environment(env, 63, v68);
  create_closure(env, f55, &v69);
  set_environment(env, 64, v69);
  create_closure(env, f56, &v70);
  set_environment(env, 65, v70);
  create_closure(env, f57, &v71);
  set_environment(env, 66, v71);
  create_closure(env, f58, &v72);
  set_environment(env, 67, v72);
  create_closure(env, f59, &v73);
  set_environment(env, 68, v73);
  create_closure(env, f60, &v74);
  set_environment(env, 69, v74);
  create_closure(env, f61, &v75);
  set_environment(env, 70, v75);
  create_closure(env, f62, &v76);
  set_environment(env, 71, v76);
  create_closure(env, f63, &v77);
  set_environment(env, 72, v77);
  create_closure(env, f64, &v78);
  set_environment(env, 73, v78);
  create_closure(env, f65, &v79);
  set_environment(env, 74, v79);
  create_closure(env, f66, &v80);
  set_environment(env, 75, v80);
  create_closure(env, f67, &v81);
  set_environment(env, 76, v81);
  create_closure(env, f68, &v82);
  set_environment(env, 77, v82);
  // looking up the value for list
  get_environment(env, 1, 8, &v83);
  closure_of(v83, &v84);
  // preparing environment with 4 slots for call
  create_environment(v84, 4, &v85);
  // looking up the value for cons
  get_environment(env, 1, 7, &v86);
  closure_of(v86, &v87);
  // preparing environment with 2 slots for call
  create_environment(v87, 2, &v88);
  // looking up the value for string->list
  get_environment(env, 1, 17, &v89);
  closure_of(v89, &v90);
  // preparing environment with 1 slots for call
  create_environment(v90, 1, &v91);
  create_string_value("#t", &v92);
  set_environment(v91, 0, v92);
  function_of(v89)(v91, &v93);
  set_environment(v88, 0, v93);
  // looking up the value for cons
  get_environment(env, 1, 7, &v94);
  closure_of(v94, &v95);
  // preparing environment with 2 slots for call
  create_environment(v95, 2, &v96);
  create_symbol_value("bool", &v97);
  set_environment(v96, 0, v97);
  create_boolean_value(true, &v98);
  set_environment(v96, 1, v98);
  function_of(v94)(v96, &v99);
  set_environment(v88, 1, v99);
  function_of(v86)(v88, &v100);
  set_environment(v85, 0, v100);
  // looking up the value for cons
  get_environment(env, 1, 7, &v101);
  closure_of(v101, &v102);
  // preparing environment with 2 slots for call
  create_environment(v102, 2, &v103);
  // looking up the value for string->list
  get_environment(env, 1, 17, &v104);
  closure_of(v104, &v105);
  // preparing environment with 1 slots for call
  create_environment(v105, 1, &v106);
  create_string_value("#f", &v107);
  set_environment(v106, 0, v107);
  function_of(v104)(v106, &v108);
  set_environment(v103, 0, v108);
  // looking up the value for cons
  get_environment(env, 1, 7, &v109);
  closure_of(v109, &v110);
  // preparing environment with 2 slots for call
  create_environment(v110, 2, &v111);
  create_symbol_value("bool", &v112);
  set_environment(v111, 0, v112);
  create_boolean_value(false, &v113);
  set_environment(v111, 1, v113);
  function_of(v109)(v111, &v114);
  set_environment(v103, 1, v114);
  function_of(v101)(v103, &v115);
  set_environment(v85, 1, v115);
  // looking up the value for cons
  get_environment(env, 1, 7, &v116);
  closure_of(v116, &v117);
  // preparing environment with 2 slots for call
  create_environment(v117, 2, &v118);
  // looking up the value for string->list
  get_environment(env, 1, 17, &v119);
  closure_of(v119, &v120);
  // preparing environment with 1 slots for call
  create_environment(v120, 1, &v121);
  create_string_value("#\\newline", &v122);
  set_environment(v121, 0, v122);
  function_of(v119)(v121, &v123);
  set_environment(v118, 0, v123);
  // looking up the value for cons
  get_environment(env, 1, 7, &v124);
  closure_of(v124, &v125);
  // preparing environment with 2 slots for call
  create_environment(v125, 2, &v126);
  create_symbol_value("character", &v127);
  set_environment(v126, 0, v127);
  create_char_value('\n', &v128);
  set_environment(v126, 1, v128);
  function_of(v124)(v126, &v129);
  set_environment(v118, 1, v129);
  function_of(v116)(v118, &v130);
  set_environment(v85, 2, v130);
  // looking up the value for cons
  get_environment(env, 1, 7, &v131);
  closure_of(v131, &v132);
  // preparing environment with 2 slots for call
  create_environment(v132, 2, &v133);
  // looking up the value for string->list
  get_environment(env, 1, 17, &v134);
  closure_of(v134, &v135);
  // preparing environment with 1 slots for call
  create_environment(v135, 1, &v136);
  create_string_value("#\\space", &v137);
  set_environment(v136, 0, v137);
  function_of(v134)(v136, &v138);
  set_environment(v133, 0, v138);
  // looking up the value for cons
  get_environment(env, 1, 7, &v139);
  closure_of(v139, &v140);
  // preparing environment with 2 slots for call
  create_environment(v140, 2, &v141);
  create_symbol_value("character", &v142);
  set_environment(v141, 0, v142);
  create_char_value(' ', &v143);
  set_environment(v141, 1, v143);
  function_of(v139)(v141, &v144);
  set_environment(v133, 1, v144);
  function_of(v131)(v133, &v145);
  set_environment(v85, 3, v145);
  function_of(v83)(v85, &v146);
  set_environment(env, 78, v146);
  create_closure(env, f69, &v147);
  set_environment(env, 79, v147);
  create_closure(env, f70, &v148);
  set_environment(env, 80, v148);
  create_closure(env, f71, &v149);
  set_environment(env, 81, v149);
  create_closure(env, f72, &v150);
  set_environment(env, 82, v150);
  create_closure(env, f73, &v151);
  set_environment(env, 83, v151);
  create_closure(env, f74, &v152);
  set_environment(env, 84, v152);
  create_string_value("+", &v158);
  create_string_value("plus", &v161);
  create_nil_value(&v162);
  create_cons_cell(v161, v162, &v163);
  create_cons_cell(v158, v163, &v164);
  create_string_value("-", &v169);
  create_string_value("subtract", &v172);
  create_nil_value(&v173);
  create_cons_cell(v172, v173, &v174);
  create_cons_cell(v169, v174, &v175);
  create_string_value("*", &v180);
  create_string_value("multiply", &v183);
  create_nil_value(&v184);
  create_cons_cell(v183, v184, &v185);
  create_cons_cell(v180, v185, &v186);
  create_string_value("/", &v191);
  create_string_value("division", &v194);
  create_nil_value(&v195);
  create_cons_cell(v194, v195, &v196);
  create_cons_cell(v191, v196, &v197);
  create_string_value("not", &v202);
  create_string_value("not", &v205);
  create_nil_value(&v206);
  create_cons_cell(v205, v206, &v207);
  create_cons_cell(v202, v207, &v208);
  create_string_value("char<=?", &v213);
  create_string_value("char_le", &v216);
  create_nil_value(&v217);
  create_cons_cell(v216, v217, &v218);
  create_cons_cell(v213, v218, &v219);
  create_string_value("char>=?", &v224);
  create_string_value("char_ge", &v227);
  create_nil_value(&v228);
  create_cons_cell(v227, v228, &v229);
  create_cons_cell(v224, v229, &v230);
  create_string_value("cons", &v235);
  create_string_value("list_cons", &v238);
  create_nil_value(&v239);
  create_cons_cell(v238, v239, &v240);
  create_cons_cell(v235, v240, &v241);
  create_string_value("list", &v246);
  create_string_value("list_constructor", &v249);
  create_nil_value(&v250);
  create_cons_cell(v249, v250, &v251);
  create_cons_cell(v246, v251, &v252);
  create_string_value("=", &v257);
  create_string_value("equals", &v260);
  create_nil_value(&v261);
  create_cons_cell(v260, v261, &v262);
  create_cons_cell(v257, v262, &v263);
  create_string_value("eq?", &v268);
  create_string_value("equals", &v271);
  create_nil_value(&v272);
  create_cons_cell(v271, v272, &v273);
  create_cons_cell(v268, v273, &v274);
  create_string_value("equal?", &v279);
  create_string_value("equals", &v282);
  create_nil_value(&v283);
  create_cons_cell(v282, v283, &v284);
  create_cons_cell(v279, v284, &v285);
  create_string_value("null?", &v290);
  create_string_value("is_null", &v293);
  create_nil_value(&v294);
  create_cons_cell(v293, v294, &v295);
  create_cons_cell(v290, v295, &v296);
  create_string_value("member", &v301);
  create_string_value("member", &v304);
  create_nil_value(&v305);
  create_cons_cell(v304, v305, &v306);
  create_cons_cell(v301, v306, &v307);
  create_string_value("car", &v312);
  create_string_value("car", &v315);
  create_nil_value(&v316);
  create_cons_cell(v315, v316, &v317);
  create_cons_cell(v312, v317, &v318);
  create_string_value("cdr", &v323);
  create_string_value("cdr", &v326);
  create_nil_value(&v327);
  create_cons_cell(v326, v327, &v328);
  create_cons_cell(v323, v328, &v329);
  create_string_value("char->integer", &v334);
  create_string_value("char_to_int", &v337);
  create_nil_value(&v338);
  create_cons_cell(v337, v338, &v339);
  create_cons_cell(v334, v339, &v340);
  create_string_value("string->list", &v345);
  create_string_value("string_to_list", &v348);
  create_nil_value(&v349);
  create_cons_cell(v348, v349, &v350);
  create_cons_cell(v345, v350, &v351);
  create_string_value("get-args", &v356);
  create_string_value("args", &v359);
  create_nil_value(&v360);
  create_cons_cell(v359, v360, &v361);
  create_cons_cell(v356, v361, &v362);
  create_string_value("displayln", &v367);
  create_string_value("println", &v370);
  create_nil_value(&v371);
  create_cons_cell(v370, v371, &v372);
  create_cons_cell(v367, v372, &v373);
  create_string_value("<", &v378);
  create_string_value("less", &v381);
  create_nil_value(&v382);
  create_cons_cell(v381, v382, &v383);
  create_cons_cell(v378, v383, &v384);
  create_string_value(">", &v389);
  create_string_value("greater", &v392);
  create_nil_value(&v393);
  create_cons_cell(v392, v393, &v394);
  create_cons_cell(v389, v394, &v395);
  create_string_value("error", &v400);
  create_string_value("failfast", &v403);
  create_nil_value(&v404);
  create_cons_cell(v403, v404, &v405);
  create_cons_cell(v400, v405, &v406);
  create_string_value("pair?", &v411);
  create_string_value("is_pair", &v414);
  create_nil_value(&v415);
  create_cons_cell(v414, v415, &v416);
  create_cons_cell(v411, v416, &v417);
  create_string_value("list->string", &v422);
  create_string_value("list_to_string", &v425);
  create_nil_value(&v426);
  create_cons_cell(v425, v426, &v427);
  create_cons_cell(v422, v427, &v428);
  create_string_value("string-append", &v433);
  create_string_value("string_append", &v436);
  create_nil_value(&v437);
  create_cons_cell(v436, v437, &v438);
  create_cons_cell(v433, v438, &v439);
  create_string_value("format", &v444);
  create_string_value("format", &v447);
  create_nil_value(&v448);
  create_cons_cell(v447, v448, &v449);
  create_cons_cell(v444, v449, &v450);
  create_string_value("cadr", &v455);
  create_string_value("cadr", &v458);
  create_nil_value(&v459);
  create_cons_cell(v458, v459, &v460);
  create_cons_cell(v455, v460, &v461);
  create_string_value("caddr", &v466);
  create_string_value("caddr", &v469);
  create_nil_value(&v470);
  create_cons_cell(v469, v470, &v471);
  create_cons_cell(v466, v471, &v472);
  create_string_value("cddr", &v477);
  create_string_value("cddr", &v480);
  create_nil_value(&v481);
  create_cons_cell(v480, v481, &v482);
  create_cons_cell(v477, v482, &v483);
  create_string_value("cddadr", &v488);
  create_string_value("cddadr", &v491);
  create_nil_value(&v492);
  create_cons_cell(v491, v492, &v493);
  create_cons_cell(v488, v493, &v494);
  create_string_value("cdadr", &v499);
  create_string_value("cdadr", &v502);
  create_nil_value(&v503);
  create_cons_cell(v502, v503, &v504);
  create_cons_cell(v499, v504, &v505);
  create_string_value("caadr", &v510);
  create_string_value("caadr", &v513);
  create_nil_value(&v514);
  create_cons_cell(v513, v514, &v515);
  create_cons_cell(v510, v515, &v516);
  create_string_value("caar", &v521);
  create_string_value("caar", &v524);
  create_nil_value(&v525);
  create_cons_cell(v524, v525, &v526);
  create_cons_cell(v521, v526, &v527);
  create_string_value("cdar", &v532);
  create_string_value("cdar", &v535);
  create_nil_value(&v536);
  create_cons_cell(v535, v536, &v537);
  create_cons_cell(v532, v537, &v538);
  create_string_value("cdddr", &v543);
  create_string_value("cdddr", &v546);
  create_nil_value(&v547);
  create_cons_cell(v546, v547, &v548);
  create_cons_cell(v543, v548, &v549);
  create_string_value("cadddr", &v554);
  create_string_value("cadddr", &v557);
  create_nil_value(&v558);
  create_cons_cell(v557, v558, &v559);
  create_cons_cell(v554, v559, &v560);
  create_string_value("write-file", &v565);
  create_string_value("write_file", &v568);
  create_nil_value(&v569);
  create_cons_cell(v568, v569, &v570);
  create_cons_cell(v565, v570, &v571);
  create_string_value("read-file", &v576);
  create_string_value("read_file", &v579);
  create_nil_value(&v580);
  create_cons_cell(v579, v580, &v581);
  create_cons_cell(v576, v581, &v582);
  create_nil_value(&v583);
  create_cons_cell(v582, v583, &v584);
  create_cons_cell(v571, v584, &v585);
  create_cons_cell(v560, v585, &v586);
  create_cons_cell(v549, v586, &v587);
  create_cons_cell(v538, v587, &v588);
  create_cons_cell(v527, v588, &v589);
  create_cons_cell(v516, v589, &v590);
  create_cons_cell(v505, v590, &v591);
  create_cons_cell(v494, v591, &v592);
  create_cons_cell(v483, v592, &v593);
  create_cons_cell(v472, v593, &v594);
  create_cons_cell(v461, v594, &v595);
  create_cons_cell(v450, v595, &v596);
  create_cons_cell(v439, v596, &v597);
  create_cons_cell(v428, v597, &v598);
  create_cons_cell(v417, v598, &v599);
  create_cons_cell(v406, v599, &v600);
  create_cons_cell(v395, v600, &v601);
  create_cons_cell(v384, v601, &v602);
  create_cons_cell(v373, v602, &v603);
  create_cons_cell(v362, v603, &v604);
  create_cons_cell(v351, v604, &v605);
  create_cons_cell(v340, v605, &v606);
  create_cons_cell(v329, v606, &v607);
  create_cons_cell(v318, v607, &v608);
  create_cons_cell(v307, v608, &v609);
  create_cons_cell(v296, v609, &v610);
  create_cons_cell(v285, v610, &v611);
  create_cons_cell(v274, v611, &v612);
  create_cons_cell(v263, v612, &v613);
  create_cons_cell(v252, v613, &v614);
  create_cons_cell(v241, v614, &v615);
  create_cons_cell(v230, v615, &v616);
  create_cons_cell(v219, v616, &v617);
  create_cons_cell(v208, v617, &v618);
  create_cons_cell(v197, v618, &v619);
  create_cons_cell(v186, v619, &v620);
  create_cons_cell(v175, v620, &v621);
  create_cons_cell(v164, v621, &v622);
  set_environment(env, 85, v622);
  create_closure(env, f75, &v623);
  set_environment(env, 86, v623);
  create_closure(env, f76, &v624);
  set_environment(env, 87, v624);
  create_closure(env, f77, &v625);
  set_environment(env, 88, v625);
  // looking up the value for main
  get_environment(env, 0, 8, &v626);
  closure_of(v626, &v627);
  // preparing environment with 0 slots for call
  create_environment(v627, 0, &v628);
  function_of(v626)(v628, &v629);
  *pReturn = v629;
  pop_stack_slot(629);
  collect(false);
}
// The symbol table for this function is:
// (f lst)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f2(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for lst
  get_environment(env, 0, 1, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    create_nil_value(&v8);
    v1 = v8;
  } else {
    // looking up the value for cons
  get_environment(env, 2, 7, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for f
  get_environment(env, 0, 0, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for car
  get_environment(env, 2, 14, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for lst
  get_environment(env, 0, 1, &v18);
  set_environment(v17, 0, v18);
  function_of(v15)(v17, &v19);
  set_environment(v14, 0, v19);
  function_of(v12)(v14, &v20);
  set_environment(v11, 0, v20);
  // looking up the value for map
  get_environment(env, 1, 0, &v21);
  closure_of(v21, &v22);
  // preparing environment with 2 slots for call
  create_environment(v22, 2, &v23);
  // looking up the value for f
  get_environment(env, 0, 0, &v24);
  set_environment(v23, 0, v24);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v25);
  closure_of(v25, &v26);
  // preparing environment with 1 slots for call
  create_environment(v26, 1, &v27);
  // looking up the value for lst
  get_environment(env, 0, 1, &v28);
  set_environment(v27, 0, v28);
  function_of(v25)(v27, &v29);
  set_environment(v23, 1, v29);
  function_of(v21)(v23, &v30);
  set_environment(v11, 1, v30);
  function_of(v9)(v11, &v31);
    v1 = v31;
  }
  *pReturn = v1;
  pop_stack_slot(31);
  collect(false);
}
// The symbol table for this function is:
// (lst)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f3(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for lst
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    create_number_value(0, &v7);
    v1 = v7;
  } else {
    // looking up the value for +
  get_environment(env, 2, 0, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  create_number_value(1, &v11);
  set_environment(v10, 0, v11);
  // looking up the value for length
  get_environment(env, 1, 1, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for lst
  get_environment(env, 0, 0, &v18);
  set_environment(v17, 0, v18);
  function_of(v15)(v17, &v19);
  set_environment(v14, 0, v19);
  function_of(v12)(v14, &v20);
  set_environment(v10, 1, v20);
  function_of(v8)(v10, &v21);
    v1 = v21;
  }
  *pReturn = v1;
  pop_stack_slot(21);
  collect(false);
}
// The symbol table for this function is:
// (pred lst)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f4(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for lst
  get_environment(env, 0, 1, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
  create_nil_value(&v8);
    v1 = v8;
  } else {
  // looking up the value for pred
  get_environment(env, 0, 0, &v10);
  closure_of(v10, &v11);
  // preparing environment with 1 slots for call
  create_environment(v11, 1, &v12);
  // looking up the value for car
  get_environment(env, 2, 14, &v13);
  closure_of(v13, &v14);
  // preparing environment with 1 slots for call
  create_environment(v14, 1, &v15);
  // looking up the value for lst
  get_environment(env, 0, 1, &v16);
  set_environment(v15, 0, v16);
  function_of(v13)(v15, &v17);
  set_environment(v12, 0, v17);
  function_of(v10)(v12, &v18);
  if (is_true(v18)) {
  // looking up the value for cons
  get_environment(env, 2, 7, &v19);
  closure_of(v19, &v20);
  // preparing environment with 2 slots for call
  create_environment(v20, 2, &v21);
  // looking up the value for car
  get_environment(env, 2, 14, &v22);
  closure_of(v22, &v23);
  // preparing environment with 1 slots for call
  create_environment(v23, 1, &v24);
  // looking up the value for lst
  get_environment(env, 0, 1, &v25);
  set_environment(v24, 0, v25);
  function_of(v22)(v24, &v26);
  set_environment(v21, 0, v26);
  // looking up the value for filter
  get_environment(env, 1, 3, &v27);
  closure_of(v27, &v28);
  // preparing environment with 2 slots for call
  create_environment(v28, 2, &v29);
  // looking up the value for pred
  get_environment(env, 0, 0, &v30);
  set_environment(v29, 0, v30);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v31);
  closure_of(v31, &v32);
  // preparing environment with 1 slots for call
  create_environment(v32, 1, &v33);
  // looking up the value for lst
  get_environment(env, 0, 1, &v34);
  set_environment(v33, 0, v34);
  function_of(v31)(v33, &v35);
  set_environment(v29, 1, v35);
  function_of(v27)(v29, &v36);
  set_environment(v21, 1, v36);
  function_of(v19)(v21, &v37);
    v9 = v37;
  } else {
  // looking up the value for filter
  get_environment(env, 1, 3, &v38);
  closure_of(v38, &v39);
  // preparing environment with 2 slots for call
  create_environment(v39, 2, &v40);
  // looking up the value for pred
  get_environment(env, 0, 0, &v41);
  set_environment(v40, 0, v41);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v42);
  closure_of(v42, &v43);
  // preparing environment with 1 slots for call
  create_environment(v43, 1, &v44);
  // looking up the value for lst
  get_environment(env, 0, 1, &v45);
  set_environment(v44, 0, v45);
  function_of(v42)(v44, &v46);
  set_environment(v40, 1, v46);
  function_of(v38)(v40, &v47);
    v9 = v47;
  }
    v1 = v9;
  }
  *pReturn = v1;
  pop_stack_slot(47);
  collect(false);
}
// The symbol table for this function is:
// (lst1 lst2)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f5(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for lst1
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for lst2
  get_environment(env, 0, 1, &v7);
    v1 = v7;
  } else {
    // looking up the value for cons
  get_environment(env, 2, 7, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for car
  get_environment(env, 2, 14, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for lst1
  get_environment(env, 0, 0, &v14);
  set_environment(v13, 0, v14);
  function_of(v11)(v13, &v15);
  set_environment(v10, 0, v15);
  // looking up the value for append
  get_environment(env, 1, 4, &v16);
  closure_of(v16, &v17);
  // preparing environment with 2 slots for call
  create_environment(v17, 2, &v18);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v19);
  closure_of(v19, &v20);
  // preparing environment with 1 slots for call
  create_environment(v20, 1, &v21);
  // looking up the value for lst1
  get_environment(env, 0, 0, &v22);
  set_environment(v21, 0, v22);
  function_of(v19)(v21, &v23);
  set_environment(v18, 0, v23);
  // looking up the value for lst2
  get_environment(env, 0, 1, &v24);
  set_environment(v18, 1, v24);
  function_of(v16)(v18, &v25);
  set_environment(v10, 1, v25);
  function_of(v8)(v10, &v26);
    v1 = v26;
  }
  *pReturn = v1;
  pop_stack_slot(26);
  collect(false);
}
// The symbol table for this function is:
// (lst)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f6(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
// Adding defines here:
// (helper)
// (lst)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)
  create_environment(env, 1, &v1);
  env = v1;
  create_closure(env, f78, &v2);
  set_environment(env, 0, v2);
  // looking up the value for helper
  get_environment(env, 0, 0, &v3);
  closure_of(v3, &v4);
  // preparing environment with 2 slots for call
  create_environment(v4, 2, &v5);
  // looking up the value for lst
  get_environment(env, 1, 0, &v6);
  set_environment(v5, 0, v6);
  create_nil_value(&v8);
  set_environment(v5, 1, v8);
  function_of(v3)(v5, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (input-file output-file)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f7(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
// Adding defines here:
// (input parsed-program)
// (input-file output-file)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)
  create_environment(env, 2, &v1);
  env = v1;
  // looking up the value for string-append
  get_environment(env, 3, 25, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for library
  get_environment(env, 2, 6, &v5);
  set_environment(v4, 0, v5);
  // looking up the value for read-file
  get_environment(env, 3, 38, &v6);
  closure_of(v6, &v7);
  // preparing environment with 1 slots for call
  create_environment(v7, 1, &v8);
  // looking up the value for input-file
  get_environment(env, 1, 0, &v9);
  set_environment(v8, 0, v9);
  function_of(v6)(v8, &v10);
  set_environment(v4, 1, v10);
  function_of(v2)(v4, &v11);
  set_environment(env, 0, v11);
  // looking up the value for parse-statements
  get_environment(env, 2, 80, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for string->list
  get_environment(env, 3, 17, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for input
  get_environment(env, 0, 0, &v18);
  set_environment(v17, 0, v18);
  function_of(v15)(v17, &v19);
  set_environment(v14, 0, v19);
  function_of(v12)(v14, &v20);
  set_environment(env, 1, v20);
  // looking up the value for eq?
  get_environment(env, 3, 10, &v22);
  closure_of(v22, &v23);
  // preparing environment with 2 slots for call
  create_environment(v23, 2, &v24);
  // looking up the value for parsed-program
  get_environment(env, 0, 1, &v25);
  set_environment(v24, 0, v25);
  create_symbol_value("error", &v26);
  set_environment(v24, 1, v26);
  function_of(v22)(v24, &v27);
  if (is_true(v27)) {
    // looking up the value for displayln
  get_environment(env, 3, 19, &v28);
  closure_of(v28, &v29);
  // preparing environment with 1 slots for call
  create_environment(v29, 1, &v30);
  create_string_value("Error: Unable to parse the input.", &v31);
  set_environment(v30, 0, v31);
  function_of(v28)(v30, &v32);
    v21 = v32;
  } else {
    create_closure(env, f79, &v33);
  closure_of(v33, &v34);
  // preparing environment with 1 slots for call
  create_environment(v34, 1, &v35);
  // looking up the value for generate-all-code
  get_environment(env, 2, 54, &v36);
  closure_of(v36, &v37);
  // preparing environment with 1 slots for call
  create_environment(v37, 1, &v38);
  // looking up the value for car
  get_environment(env, 3, 14, &v39);
  closure_of(v39, &v40);
  // preparing environment with 1 slots for call
  create_environment(v40, 1, &v41);
  // looking up the value for parsed-program
  get_environment(env, 0, 1, &v42);
  set_environment(v41, 0, v42);
  function_of(v39)(v41, &v43);
  set_environment(v38, 0, v43);
  function_of(v36)(v38, &v44);
  set_environment(v35, 0, v44);
  function_of(v33)(v35, &v45);
    v21 = v45;
  }
  *pReturn = v21;
  pop_stack_slot(45);
  collect(false);
}
// The symbol table for this function is:
// ()
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f8(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  // looking up the value for <
  get_environment(env, 2, 20, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for length
  get_environment(env, 1, 1, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for args
  get_environment(env, 1, 2, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  create_number_value(2, &v10);
  set_environment(v4, 1, v10);
  function_of(v2)(v4, &v11);
  if (is_true(v11)) {
    // looking up the value for displayln
  get_environment(env, 2, 19, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  create_string_value("Usage: ./compiler.out input.rkt output.c", &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
    v1 = v16;
  } else {
    // looking up the value for compiler
  get_environment(env, 1, 7, &v17);
  closure_of(v17, &v18);
  // preparing environment with 2 slots for call
  create_environment(v18, 2, &v19);
  // looking up the value for car
  get_environment(env, 2, 14, &v20);
  closure_of(v20, &v21);
  // preparing environment with 1 slots for call
  create_environment(v21, 1, &v22);
  // looking up the value for args
  get_environment(env, 1, 2, &v23);
  set_environment(v22, 0, v23);
  function_of(v20)(v22, &v24);
  set_environment(v19, 0, v24);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v25);
  closure_of(v25, &v26);
  // preparing environment with 1 slots for call
  create_environment(v26, 1, &v27);
  // looking up the value for args
  get_environment(env, 1, 2, &v28);
  set_environment(v27, 0, v28);
  function_of(v25)(v27, &v29);
  set_environment(v19, 1, v29);
  function_of(v17)(v19, &v30);
    v1 = v30;
  }
  *pReturn = v1;
  pop_stack_slot(30);
  collect(false);
}
// The symbol table for this function is:
// (comment)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f9(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  // looking up the value for show-comment
  get_environment(env, 1, 16, &v2);
  if (is_true(v2)) {
    // looking up the value for comment
  get_environment(env, 0, 0, &v3);
    v1 = v3;
  } else {
    create_string_value("", &v4);
    v1 = v4;
  }
  *pReturn = v1;
  pop_stack_slot(4);
  collect(false);
}
// The symbol table for this function is:
// ()
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f10(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  // looking up the value for gc-stress
  get_environment(env, 1, 17, &v2);
  if (is_true(v2)) {
    // looking up the value for generate-collect-statement
  get_environment(env, 1, 22, &v3);
  closure_of(v3, &v4);
  // preparing environment with 0 slots for call
  create_environment(v4, 0, &v5);
  function_of(v3)(v5, &v6);
    v1 = v6;
  } else {
    create_string_value("", &v7);
    v1 = v7;
  }
  *pReturn = v1;
  pop_stack_slot(7);
  collect(false);
}
// The symbol table for this function is:
// (function-id)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f11(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  // looking up the value for =
  get_environment(env, 2, 9, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for function-id
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_number_value(0, &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    // looking up the value for empty-string
  get_environment(env, 1, 15, &v8);
    v1 = v8;
  } else {
    // looking up the value for string-append
  get_environment(env, 2, 25, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for generate-function-prototypes
  get_environment(env, 1, 20, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for -
  get_environment(env, 2, 1, &v15);
  closure_of(v15, &v16);
  // preparing environment with 2 slots for call
  create_environment(v16, 2, &v17);
  // looking up the value for function-id
  get_environment(env, 0, 0, &v18);
  set_environment(v17, 0, v18);
  create_number_value(1, &v19);
  set_environment(v17, 1, v19);
  function_of(v15)(v17, &v20);
  set_environment(v14, 0, v20);
  function_of(v12)(v14, &v21);
  set_environment(v11, 0, v21);
  // looking up the value for format
  get_environment(env, 2, 26, &v22);
  closure_of(v22, &v23);
  // preparing environment with 2 slots for call
  create_environment(v23, 2, &v24);
  create_string_value("void f~a(ekans_value* env, ekans_value** pReturn);\n", &v25);
  set_environment(v24, 0, v25);
  // looking up the value for function-id
  get_environment(env, 0, 0, &v26);
  set_environment(v24, 1, v26);
  function_of(v22)(v24, &v27);
  set_environment(v11, 1, v27);
  function_of(v9)(v11, &v28);
    v1 = v28;
  }
  *pReturn = v1;
  pop_stack_slot(28);
  collect(false);
}
// The symbol table for this function is:
// (number-of-functions)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f12(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  // looking up the value for string-append
  get_environment(env, 2, 25, &v1);
  closure_of(v1, &v2);
  // preparing environment with 5 slots for call
  create_environment(v2, 5, &v3);
  create_string_value("#include <ekans.h>", &v4);
  set_environment(v3, 0, v4);
  create_string_value("\n", &v5);
  set_environment(v3, 1, v5);
  create_string_value("\n", &v6);
  set_environment(v3, 2, v6);
  // looking up the value for generate-function-prototypes
  get_environment(env, 1, 20, &v7);
  closure_of(v7, &v8);
  // preparing environment with 1 slots for call
  create_environment(v8, 1, &v9);
  // looking up the value for number-of-functions
  get_environment(env, 0, 0, &v10);
  set_environment(v9, 0, v10);
  function_of(v7)(v9, &v11);
  set_environment(v3, 3, v11);
  create_string_value("\n", &v12);
  set_environment(v3, 4, v12);
  function_of(v1)(v3, &v13);
  *pReturn = v13;
  pop_stack_slot(13);
  collect(false);
}
// The symbol table for this function is:
// ()
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f13(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  create_string_value("  collect(false);\n", &v1);
  *pReturn = v1;
  pop_stack_slot(1);
  collect(false);
}
// The symbol table for this function is:
// (number-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f14(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  create_closure(env, f80, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for number-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for new-variable-id
  get_environment(env, 1, 58, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for context
  get_environment(env, 0, 1, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  // looking up the value for increment-variable-id
  get_environment(env, 1, 60, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for context
  get_environment(env, 0, 1, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v3, 2, v18);
  function_of(v1)(v3, &v19);
  *pReturn = v19;
  pop_stack_slot(19);
  collect(false);
}
// The symbol table for this function is:
// (bool-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f15(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  create_closure(env, f81, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for bool-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for new-variable-id
  get_environment(env, 1, 58, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for context
  get_environment(env, 0, 1, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  // looking up the value for increment-variable-id
  get_environment(env, 1, 60, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for context
  get_environment(env, 0, 1, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v3, 2, v18);
  function_of(v1)(v3, &v19);
  *pReturn = v19;
  pop_stack_slot(19);
  collect(false);
}
// The symbol table for this function is:
// (char-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f16(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  create_closure(env, f82, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for char-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for new-variable-id
  get_environment(env, 1, 58, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for context
  get_environment(env, 0, 1, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  // looking up the value for increment-variable-id
  get_environment(env, 1, 60, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for context
  get_environment(env, 0, 1, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v3, 2, v18);
  function_of(v1)(v3, &v19);
  *pReturn = v19;
  pop_stack_slot(19);
  collect(false);
}
// The symbol table for this function is:
// (string-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f17(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  create_closure(env, f83, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for string-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for new-variable-id
  get_environment(env, 1, 58, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for context
  get_environment(env, 0, 1, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  // looking up the value for increment-variable-id
  get_environment(env, 1, 60, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for context
  get_environment(env, 0, 1, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v3, 2, v18);
  function_of(v1)(v3, &v19);
  *pReturn = v19;
  pop_stack_slot(19);
  collect(false);
}
// The symbol table for this function is:
// (symbol-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f18(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f84, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for symbol-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f19(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f85, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for if-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (and-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f20(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  create_closure(env, f86, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for car
  get_environment(env, 2, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for and-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for and-statement
  get_environment(env, 0, 0, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  function_of(v1)(v3, &v14);
  *pReturn = v14;
  pop_stack_slot(14);
  collect(false);
}
// The symbol table for this function is:
// (or-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f21(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  create_closure(env, f87, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for car
  get_environment(env, 2, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for or-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for or-statement
  get_environment(env, 0, 0, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  function_of(v1)(v3, &v14);
  *pReturn = v14;
  pop_stack_slot(14);
  collect(false);
}
// The symbol table for this function is:
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f22(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  // looking up the value for >
  get_environment(env, 2, 21, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for length
  get_environment(env, 1, 1, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for cond-statement
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  create_number_value(2, &v10);
  set_environment(v4, 1, v10);
  function_of(v2)(v4, &v11);
  if (is_true(v11)) {
    create_closure(env, f88, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for car
  get_environment(env, 2, 14, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for cond-statement
  get_environment(env, 0, 0, &v18);
  set_environment(v17, 0, v18);
  function_of(v15)(v17, &v19);
  set_environment(v14, 0, v19);
  function_of(v12)(v14, &v20);
    v1 = v20;
  } else {
    // looking up the value for generate-statements
  get_environment(env, 1, 43, &v21);
  closure_of(v21, &v22);
  // preparing environment with 3 slots for call
  create_environment(v22, 3, &v23);
  // looking up the value for cddadr
  get_environment(env, 2, 30, &v24);
  closure_of(v24, &v25);
  // preparing environment with 1 slots for call
  create_environment(v25, 1, &v26);
  // looking up the value for cond-statement
  get_environment(env, 0, 0, &v27);
  set_environment(v26, 0, v27);
  function_of(v24)(v26, &v28);
  set_environment(v23, 0, v28);
  // looking up the value for context
  get_environment(env, 0, 1, &v29);
  set_environment(v23, 1, v29);
  create_nil_value(&v31);
  set_environment(v23, 2, v31);
  function_of(v21)(v23, &v32);
    v1 = v32;
  }
  *pReturn = v1;
  pop_stack_slot(32);
  collect(false);
}
// The symbol table for this function is:
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f23(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f89, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f24(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f90, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 2, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f25(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f91, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f26(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  create_closure(env, f92, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for new-variable-id
  get_environment(env, 1, 58, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for context
  get_environment(env, 0, 1, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  // looking up the value for increment-variable-id
  get_environment(env, 1, 60, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for context
  get_environment(env, 0, 1, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v3, 2, v18);
  function_of(v1)(v3, &v19);
  *pReturn = v19;
  pop_stack_slot(19);
  collect(false);
}
// The symbol table for this function is:
// (quoted-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f27(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f93, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 1, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f28(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f94, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdadr
  get_environment(env, 2, 31, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f29(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f95, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdadr
  get_environment(env, 2, 31, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (quote-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f30(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  // looking up the value for generate-statement-quoted
  get_environment(env, 1, 36, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for quote-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for context
  get_environment(env, 0, 1, &v9);
  set_environment(v3, 1, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f31(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f96, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 2, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f32(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f97, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (values counter)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f33(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for values
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    create_nil_value(&v8);
    v1 = v8;
  } else {
    // looking up the value for cons
  get_environment(env, 2, 7, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for list
  get_environment(env, 2, 8, &v12);
  closure_of(v12, &v13);
  // preparing environment with 3 slots for call
  create_environment(v13, 3, &v14);
  create_symbol_value("set-environment", &v15);
  set_environment(v14, 0, v15);
  // looking up the value for car
  get_environment(env, 2, 14, &v16);
  closure_of(v16, &v17);
  // preparing environment with 1 slots for call
  create_environment(v17, 1, &v18);
  // looking up the value for values
  get_environment(env, 0, 0, &v19);
  set_environment(v18, 0, v19);
  function_of(v16)(v18, &v20);
  set_environment(v14, 1, v20);
  // looking up the value for counter
  get_environment(env, 0, 1, &v21);
  set_environment(v14, 2, v21);
  function_of(v12)(v14, &v22);
  set_environment(v11, 0, v22);
  // looking up the value for set-environment
  get_environment(env, 1, 42, &v23);
  closure_of(v23, &v24);
  // preparing environment with 2 slots for call
  create_environment(v24, 2, &v25);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v26);
  closure_of(v26, &v27);
  // preparing environment with 1 slots for call
  create_environment(v27, 1, &v28);
  // looking up the value for values
  get_environment(env, 0, 0, &v29);
  set_environment(v28, 0, v29);
  function_of(v26)(v28, &v30);
  set_environment(v25, 0, v30);
  // looking up the value for +
  get_environment(env, 2, 0, &v31);
  closure_of(v31, &v32);
  // preparing environment with 2 slots for call
  create_environment(v32, 2, &v33);
  // looking up the value for counter
  get_environment(env, 0, 1, &v34);
  set_environment(v33, 0, v34);
  create_number_value(1, &v35);
  set_environment(v33, 1, v35);
  function_of(v31)(v33, &v36);
  set_environment(v25, 1, v36);
  function_of(v23)(v25, &v37);
  set_environment(v11, 1, v37);
  function_of(v9)(v11, &v38);
    v1 = v38;
  }
  *pReturn = v1;
  pop_stack_slot(38);
  collect(false);
}
// The symbol table for this function is:
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f34(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for statements
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for list
  get_environment(env, 2, 8, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  // looking up the value for empty-string
  get_environment(env, 1, 15, &v10);
  set_environment(v9, 0, v10);
  // looking up the value for result
  get_environment(env, 0, 2, &v11);
  set_environment(v9, 1, v11);
  // looking up the value for context
  get_environment(env, 0, 1, &v12);
  set_environment(v9, 2, v12);
  function_of(v7)(v9, &v13);
    v1 = v13;
  } else {
    create_closure(env, f98, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for extract-defines
  get_environment(env, 1, 53, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for statements
  get_environment(env, 0, 0, &v20);
  set_environment(v19, 0, v20);
  function_of(v17)(v19, &v21);
  set_environment(v16, 0, v21);
  function_of(v14)(v16, &v22);
    v1 = v22;
  }
  *pReturn = v1;
  pop_stack_slot(22);
  collect(false);
}
// The symbol table for this function is:
// (arguments prefix index environment-id context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f35(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for arguments
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for cons
  get_environment(env, 2, 7, &v7);
  closure_of(v7, &v8);
  // preparing environment with 2 slots for call
  create_environment(v8, 2, &v9);
  // looking up the value for prefix
  get_environment(env, 0, 1, &v10);
  set_environment(v9, 0, v10);
  // looking up the value for context
  get_environment(env, 0, 4, &v11);
  set_environment(v9, 1, v11);
  function_of(v7)(v9, &v12);
    v1 = v12;
  } else {
    create_closure(env, f99, &v13);
  closure_of(v13, &v14);
  // preparing environment with 1 slots for call
  create_environment(v14, 1, &v15);
  // looking up the value for generate-statement
  get_environment(env, 1, 40, &v16);
  closure_of(v16, &v17);
  // preparing environment with 2 slots for call
  create_environment(v17, 2, &v18);
  // looking up the value for car
  get_environment(env, 2, 14, &v19);
  closure_of(v19, &v20);
  // preparing environment with 1 slots for call
  create_environment(v20, 1, &v21);
  // looking up the value for arguments
  get_environment(env, 0, 0, &v22);
  set_environment(v21, 0, v22);
  function_of(v19)(v21, &v23);
  set_environment(v18, 0, v23);
  // looking up the value for context
  get_environment(env, 0, 4, &v24);
  set_environment(v18, 1, v24);
  function_of(v16)(v18, &v25);
  set_environment(v15, 0, v25);
  function_of(v13)(v15, &v26);
    v1 = v26;
  }
  *pReturn = v1;
  pop_stack_slot(26);
  collect(false);
}
// The symbol table for this function is:
// (number-of-variables)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f36(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  // looking up the value for =
  get_environment(env, 2, 9, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for number-of-variables
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_number_value(0, &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    // looking up the value for empty-string
  get_environment(env, 1, 15, &v8);
    v1 = v8;
  } else {
    // looking up the value for string-append
  get_environment(env, 2, 25, &v9);
  closure_of(v9, &v10);
  // preparing environment with 5 slots for call
  create_environment(v10, 5, &v11);
  // looking up the value for generate-temp-declarations
  get_environment(env, 1, 45, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for -
  get_environment(env, 2, 1, &v15);
  closure_of(v15, &v16);
  // preparing environment with 2 slots for call
  create_environment(v16, 2, &v17);
  // looking up the value for number-of-variables
  get_environment(env, 0, 0, &v18);
  set_environment(v17, 0, v18);
  create_number_value(1, &v19);
  set_environment(v17, 1, v19);
  function_of(v15)(v17, &v20);
  set_environment(v14, 0, v20);
  function_of(v12)(v14, &v21);
  set_environment(v11, 0, v21);
  // looking up the value for format
  get_environment(env, 2, 26, &v22);
  closure_of(v22, &v23);
  // preparing environment with 2 slots for call
  create_environment(v23, 2, &v24);
  create_string_value("  ekans_value* v~a = NULL;\n", &v25);
  set_environment(v24, 0, v25);
  // looking up the value for number-of-variables
  get_environment(env, 0, 0, &v26);
  set_environment(v24, 1, v26);
  function_of(v22)(v24, &v27);
  set_environment(v11, 1, v27);
  // looking up the value for optional-collect
  get_environment(env, 1, 19, &v28);
  closure_of(v28, &v29);
  // preparing environment with 0 slots for call
  create_environment(v29, 0, &v30);
  function_of(v28)(v30, &v31);
  set_environment(v11, 2, v31);
  // looking up the value for format
  get_environment(env, 2, 26, &v32);
  closure_of(v32, &v33);
  // preparing environment with 2 slots for call
  create_environment(v33, 2, &v34);
  create_string_value("  push_stack_slot(&v~a);\n", &v35);
  set_environment(v34, 0, v35);
  // looking up the value for number-of-variables
  get_environment(env, 0, 0, &v36);
  set_environment(v34, 1, v36);
  function_of(v32)(v34, &v37);
  set_environment(v11, 3, v37);
  // looking up the value for optional-collect
  get_environment(env, 1, 19, &v38);
  closure_of(v38, &v39);
  // preparing environment with 0 slots for call
  create_environment(v39, 0, &v40);
  function_of(v38)(v40, &v41);
  set_environment(v11, 4, v41);
  function_of(v9)(v11, &v42);
    v1 = v42;
  }
  *pReturn = v1;
  pop_stack_slot(42);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f37(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for pending-functions
  get_environment(env, 1, 67, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for context
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  function_of(v2)(v4, &v10);
  if (is_true(v10)) {
    // looking up the value for cons
  get_environment(env, 2, 7, &v11);
  closure_of(v11, &v12);
  // preparing environment with 2 slots for call
  create_environment(v12, 2, &v13);
  // looking up the value for empty-string
  get_environment(env, 1, 15, &v14);
  set_environment(v13, 0, v14);
  create_number_value(0, &v15);
  set_environment(v13, 1, v15);
  function_of(v11)(v13, &v16);
    v1 = v16;
  } else {
    create_closure(env, f100, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for pending-functions
  get_environment(env, 1, 67, &v20);
  closure_of(v20, &v21);
  // preparing environment with 1 slots for call
  create_environment(v21, 1, &v22);
  // looking up the value for context
  get_environment(env, 0, 0, &v23);
  set_environment(v22, 0, v23);
  function_of(v20)(v22, &v24);
  set_environment(v19, 0, v24);
  function_of(v17)(v19, &v25);
    v1 = v25;
  }
  *pReturn = v1;
  pop_stack_slot(25);
  collect(false);
}
// The symbol table for this function is:
// (table)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f38(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for table
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    create_string_value("", &v7);
    v1 = v7;
  } else {
    // looking up the value for format
  get_environment(env, 2, 26, &v8);
  closure_of(v8, &v9);
  // preparing environment with 3 slots for call
  create_environment(v9, 3, &v10);
  create_string_value("// ~a\n~a", &v11);
  set_environment(v10, 0, v11);
  // looking up the value for car
  get_environment(env, 2, 14, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for table
  get_environment(env, 0, 0, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
  set_environment(v10, 1, v16);
  // looking up the value for pretty-symbol-table
  get_environment(env, 1, 47, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v20);
  closure_of(v20, &v21);
  // preparing environment with 1 slots for call
  create_environment(v21, 1, &v22);
  // looking up the value for table
  get_environment(env, 0, 0, &v23);
  set_environment(v22, 0, v23);
  function_of(v20)(v22, &v24);
  set_environment(v19, 0, v24);
  function_of(v17)(v19, &v25);
  set_environment(v10, 2, v25);
  function_of(v8)(v10, &v26);
    v1 = v26;
  }
  *pReturn = v1;
  pop_stack_slot(26);
  collect(false);
}
// The symbol table for this function is:
// (function-id statements context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f39(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  create_closure(env, f101, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for context
  get_environment(env, 0, 2, &v4);
  set_environment(v3, 0, v4);
  function_of(v1)(v3, &v5);
  *pReturn = v5;
  pop_stack_slot(5);
  collect(false);
}
// The symbol table for this function is:
// (statement)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f40(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  // looking up the value for equal?
  get_environment(env, 2, 11, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for car
  get_environment(env, 2, 14, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for statement
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  create_symbol_value("list-statement", &v10);
  set_environment(v4, 1, v10);
  function_of(v2)(v4, &v11);
  if (is_true(v11)) {
    // looking up the value for equal?
  get_environment(env, 2, 11, &v13);
  closure_of(v13, &v14);
  // preparing environment with 2 slots for call
  create_environment(v14, 2, &v15);
  // looking up the value for caadr
  get_environment(env, 2, 32, &v16);
  closure_of(v16, &v17);
  // preparing environment with 1 slots for call
  create_environment(v17, 1, &v18);
  // looking up the value for statement
  get_environment(env, 0, 0, &v19);
  set_environment(v18, 0, v19);
  function_of(v16)(v18, &v20);
  set_environment(v15, 0, v20);
  create_symbol_value("symbol-statement", &v21);
  set_environment(v15, 1, v21);
  function_of(v13)(v15, &v22);
  if (is_true(v22)) {
    // looking up the value for equal?
  get_environment(env, 2, 11, &v24);
  closure_of(v24, &v25);
  // preparing environment with 2 slots for call
  create_environment(v25, 2, &v26);
  // looking up the value for cdadr
  get_environment(env, 2, 31, &v27);
  closure_of(v27, &v28);
  // preparing environment with 1 slots for call
  create_environment(v28, 1, &v29);
  // looking up the value for statement
  get_environment(env, 0, 0, &v30);
  set_environment(v29, 0, v30);
  function_of(v27)(v29, &v31);
  set_environment(v26, 0, v31);
  create_string_value("define", &v32);
  set_environment(v26, 1, v32);
  function_of(v24)(v26, &v33);
  if (is_true(v33)) {
    create_boolean_value(true, &v34);
    v23 = v34;
  } else {
    create_boolean_value(false, &v35);
    v23 = v35;
  }
    v12 = v23;
  } else {
    create_boolean_value(false, &v36);
    v12 = v36;
  }
    v1 = v12;
  } else {
    create_boolean_value(false, &v37);
    v1 = v37;
  }
  *pReturn = v1;
  pop_stack_slot(37);
  collect(false);
}
// The symbol table for this function is:
// (statement)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f41(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  // looking up the value for not
  get_environment(env, 2, 4, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for define?
  get_environment(env, 1, 49, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (statement)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f42(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f102, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 2, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (statement)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f43(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  create_closure(env, f103, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for caddr
  get_environment(env, 2, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for cdddr
  get_environment(env, 2, 35, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for statement
  get_environment(env, 0, 0, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  function_of(v1)(v3, &v14);
  *pReturn = v14;
  pop_stack_slot(14);
  collect(false);
}
// The symbol table for this function is:
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f44(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f104, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for filter
  get_environment(env, 1, 3, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for define?
  get_environment(env, 1, 49, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for statements
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f45(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  create_closure(env, f105, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for list
  get_environment(env, 2, 8, &v4);
  closure_of(v4, &v5);
  // preparing environment with 4 slots for call
  create_environment(v5, 4, &v6);
  create_number_value(0, &v7);
  set_environment(v6, 0, v7);
  create_number_value(1, &v8);
  set_environment(v6, 1, v8);
  create_nil_value(&v10);
  set_environment(v6, 2, v10);
  // looking up the value for list
  get_environment(env, 2, 8, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for list
  get_environment(env, 2, 8, &v14);
  closure_of(v14, &v15);
  // preparing environment with 3 slots for call
  create_environment(v15, 3, &v16);
  create_number_value(1, &v17);
  set_environment(v16, 0, v17);
  // looking up the value for statements
  get_environment(env, 0, 0, &v18);
  set_environment(v16, 1, v18);
  // looking up the value for initial-symbol-table
  get_environment(env, 1, 86, &v19);
  closure_of(v19, &v20);
  // preparing environment with 0 slots for call
  create_environment(v20, 0, &v21);
  function_of(v19)(v21, &v22);
  set_environment(v16, 2, v22);
  function_of(v14)(v16, &v23);
  set_environment(v13, 0, v23);
  function_of(v11)(v13, &v24);
  set_environment(v6, 3, v24);
  function_of(v4)(v6, &v25);
  set_environment(v3, 0, v25);
  function_of(v1)(v3, &v26);
  *pReturn = v26;
  pop_stack_slot(26);
  collect(false);
}
// The symbol table for this function is:
// (elements index temp-id)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f46(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for elements
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for empty-string
  get_environment(env, 1, 15, &v7);
    v1 = v7;
  } else {
    // looking up the value for string-append
  get_environment(env, 2, 25, &v8);
  closure_of(v8, &v9);
  // preparing environment with 3 slots for call
  create_environment(v9, 3, &v10);
  // looking up the value for format
  get_environment(env, 2, 26, &v11);
  closure_of(v11, &v12);
  // preparing environment with 3 slots for call
  create_environment(v12, 3, &v13);
  create_string_value("  create_closure(*pEnv, ~a, &v~a);\n", &v14);
  set_environment(v13, 0, v14);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for car
  get_environment(env, 2, 14, &v18);
  closure_of(v18, &v19);
  // preparing environment with 1 slots for call
  create_environment(v19, 1, &v20);
  // looking up the value for elements
  get_environment(env, 0, 0, &v21);
  set_environment(v20, 0, v21);
  function_of(v18)(v20, &v22);
  set_environment(v17, 0, v22);
  function_of(v15)(v17, &v23);
  set_environment(v13, 1, v23);
  // looking up the value for temp-id
  get_environment(env, 0, 2, &v24);
  set_environment(v13, 2, v24);
  function_of(v11)(v13, &v25);
  set_environment(v10, 0, v25);
  // looking up the value for format
  get_environment(env, 2, 26, &v26);
  closure_of(v26, &v27);
  // preparing environment with 3 slots for call
  create_environment(v27, 3, &v28);
  create_string_value("  set_environment(*pEnv, ~a, v~a);\n", &v29);
  set_environment(v28, 0, v29);
  // looking up the value for index
  get_environment(env, 0, 1, &v30);
  set_environment(v28, 1, v30);
  // looking up the value for temp-id
  get_environment(env, 0, 2, &v31);
  set_environment(v28, 2, v31);
  function_of(v26)(v28, &v32);
  set_environment(v10, 1, v32);
  // looking up the value for populate-environment
  get_environment(env, 1, 55, &v33);
  closure_of(v33, &v34);
  // preparing environment with 3 slots for call
  create_environment(v34, 3, &v35);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v36);
  closure_of(v36, &v37);
  // preparing environment with 1 slots for call
  create_environment(v37, 1, &v38);
  // looking up the value for elements
  get_environment(env, 0, 0, &v39);
  set_environment(v38, 0, v39);
  function_of(v36)(v38, &v40);
  set_environment(v35, 0, v40);
  // looking up the value for +
  get_environment(env, 2, 0, &v41);
  closure_of(v41, &v42);
  // preparing environment with 2 slots for call
  create_environment(v42, 2, &v43);
  // looking up the value for index
  get_environment(env, 0, 1, &v44);
  set_environment(v43, 0, v44);
  create_number_value(1, &v45);
  set_environment(v43, 1, v45);
  function_of(v41)(v43, &v46);
  set_environment(v35, 1, v46);
  // looking up the value for +
  get_environment(env, 2, 0, &v47);
  closure_of(v47, &v48);
  // preparing environment with 2 slots for call
  create_environment(v48, 2, &v49);
  // looking up the value for temp-id
  get_environment(env, 0, 2, &v50);
  set_environment(v49, 0, v50);
  create_number_value(1, &v51);
  set_environment(v49, 1, v51);
  function_of(v47)(v49, &v52);
  set_environment(v35, 2, v52);
  function_of(v33)(v35, &v53);
  set_environment(v10, 2, v53);
  function_of(v8)(v10, &v54);
    v1 = v54;
  }
  *pReturn = v1;
  pop_stack_slot(54);
  collect(false);
}
// The symbol table for this function is:
// ()
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f47(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  // looking up the value for string-append
  get_environment(env, 2, 25, &v1);
  closure_of(v1, &v2);
  // preparing environment with 10 slots for call
  create_environment(v2, 10, &v3);
  create_string_value("\n", &v4);
  set_environment(v3, 0, v4);
  create_string_value("void build_builtins(ekans_value** pEnv) ", &v5);
  set_environment(v3, 1, v5);
  // looking up the value for lb
  get_environment(env, 1, 11, &v6);
  set_environment(v3, 2, v6);
  create_string_value("\n", &v7);
  set_environment(v3, 3, v7);
  // looking up the value for format
  get_environment(env, 2, 26, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  create_string_value("  create_environment(NULL, ~a, pEnv);\n", &v11);
  set_environment(v10, 0, v11);
  // looking up the value for length
  get_environment(env, 1, 1, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for builtins
  get_environment(env, 1, 85, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
  set_environment(v10, 1, v16);
  function_of(v8)(v10, &v17);
  set_environment(v3, 4, v17);
  // looking up the value for generate-temp-declarations
  get_environment(env, 1, 45, &v18);
  closure_of(v18, &v19);
  // preparing environment with 1 slots for call
  create_environment(v19, 1, &v20);
  // looking up the value for length
  get_environment(env, 1, 1, &v21);
  closure_of(v21, &v22);
  // preparing environment with 1 slots for call
  create_environment(v22, 1, &v23);
  // looking up the value for builtins
  get_environment(env, 1, 85, &v24);
  set_environment(v23, 0, v24);
  function_of(v21)(v23, &v25);
  set_environment(v20, 0, v25);
  function_of(v18)(v20, &v26);
  set_environment(v3, 5, v26);
  // looking up the value for populate-environment
  get_environment(env, 1, 55, &v27);
  closure_of(v27, &v28);
  // preparing environment with 3 slots for call
  create_environment(v28, 3, &v29);
  // looking up the value for builtins
  get_environment(env, 1, 85, &v30);
  set_environment(v29, 0, v30);
  create_number_value(0, &v31);
  set_environment(v29, 1, v31);
  create_number_value(1, &v32);
  set_environment(v29, 2, v32);
  function_of(v27)(v29, &v33);
  set_environment(v3, 6, v33);
  // looking up the value for format
  get_environment(env, 2, 26, &v34);
  closure_of(v34, &v35);
  // preparing environment with 2 slots for call
  create_environment(v35, 2, &v36);
  create_string_value("  pop_stack_slot(~a);\n", &v37);
  set_environment(v36, 0, v37);
  // looking up the value for length
  get_environment(env, 1, 1, &v38);
  closure_of(v38, &v39);
  // preparing environment with 1 slots for call
  create_environment(v39, 1, &v40);
  // looking up the value for builtins
  get_environment(env, 1, 85, &v41);
  set_environment(v40, 0, v41);
  function_of(v38)(v40, &v42);
  set_environment(v36, 1, v42);
  function_of(v34)(v36, &v43);
  set_environment(v3, 7, v43);
  // looking up the value for rb
  get_environment(env, 1, 12, &v44);
  set_environment(v3, 8, v44);
  create_string_value("\n", &v45);
  set_environment(v3, 9, v45);
  function_of(v1)(v3, &v46);
  *pReturn = v46;
  pop_stack_slot(46);
  collect(false);
}
// The symbol table for this function is:
// ()
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f48(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  // looking up the value for string-append
  get_environment(env, 2, 25, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for generate-build-builtins
  get_environment(env, 1, 56, &v4);
  closure_of(v4, &v5);
  // preparing environment with 0 slots for call
  create_environment(v5, 0, &v6);
  function_of(v4)(v6, &v7);
  set_environment(v3, 0, v7);
  // looking up the value for string-append
  get_environment(env, 2, 25, &v8);
  closure_of(v8, &v9);
  // preparing environment with 16 slots for call
  create_environment(v9, 16, &v10);
  create_string_value("int main(int argc, char** argv) ", &v11);
  set_environment(v10, 0, v11);
  // looking up the value for lb
  get_environment(env, 1, 11, &v12);
  set_environment(v10, 1, v12);
  create_string_value("\n", &v13);
  set_environment(v10, 2, v13);
  create_string_value("  initialize_ekans(argc, argv);\n", &v14);
  set_environment(v10, 3, v14);
  create_string_value("  ekans_value* env = NULL;\n", &v15);
  set_environment(v10, 4, v15);
  create_string_value("  push_stack_slot(&env);\n", &v16);
  set_environment(v10, 5, v16);
  create_string_value("  ekans_value* v1 = NULL;\n", &v17);
  set_environment(v10, 6, v17);
  create_string_value("  push_stack_slot(&v1);\n", &v18);
  set_environment(v10, 7, v18);
  create_string_value("  build_builtins(&env);\n", &v19);
  set_environment(v10, 8, v19);
  create_string_value("  f1(env, &v1);\n", &v20);
  set_environment(v10, 9, v20);
  create_string_value("  print_ekans_value(v1);\n", &v21);
  set_environment(v10, 10, v21);
  create_string_value("  pop_stack_slot(2);\n", &v22);
  set_environment(v10, 11, v22);
  create_string_value("  finalize_ekans();\n", &v23);
  set_environment(v10, 12, v23);
  create_string_value("  return 0;\n", &v24);
  set_environment(v10, 13, v24);
  // looking up the value for rb
  get_environment(env, 1, 12, &v25);
  set_environment(v10, 14, v25);
  create_string_value("\n", &v26);
  set_environment(v10, 15, v26);
  function_of(v8)(v10, &v27);
  set_environment(v3, 1, v27);
  function_of(v1)(v3, &v28);
  *pReturn = v28;
  pop_stack_slot(28);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f49(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  // looking up the value for +
  get_environment(env, 2, 0, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for car
  get_environment(env, 2, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  create_number_value(1, &v9);
  set_environment(v3, 1, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f50(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  // looking up the value for car
  get_environment(env, 2, 14, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for context
  get_environment(env, 0, 0, &v4);
  set_environment(v3, 0, v4);
  function_of(v1)(v3, &v5);
  *pReturn = v5;
  pop_stack_slot(5);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f51(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  // looking up the value for cons
  get_environment(env, 2, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for +
  get_environment(env, 2, 0, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for car
  get_environment(env, 2, 14, &v7);
  closure_of(v7, &v8);
  // preparing environment with 1 slots for call
  create_environment(v8, 1, &v9);
  // looking up the value for context
  get_environment(env, 0, 0, &v10);
  set_environment(v9, 0, v10);
  function_of(v7)(v9, &v11);
  set_environment(v6, 0, v11);
  create_number_value(1, &v12);
  set_environment(v6, 1, v12);
  function_of(v4)(v6, &v13);
  set_environment(v3, 0, v13);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for context
  get_environment(env, 0, 0, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v3, 1, v18);
  function_of(v1)(v3, &v19);
  *pReturn = v19;
  pop_stack_slot(19);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f52(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  // looking up the value for +
  get_environment(env, 2, 0, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  create_number_value(1, &v9);
  set_environment(v3, 1, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f53(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for context
  get_environment(env, 0, 0, &v4);
  set_environment(v3, 0, v4);
  function_of(v1)(v3, &v5);
  *pReturn = v5;
  pop_stack_slot(5);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f54(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  // looking up the value for cons
  get_environment(env, 2, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for car
  get_environment(env, 2, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for cons
  get_environment(env, 2, 7, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for +
  get_environment(env, 2, 0, &v12);
  closure_of(v12, &v13);
  // preparing environment with 2 slots for call
  create_environment(v13, 2, &v14);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for context
  get_environment(env, 0, 0, &v18);
  set_environment(v17, 0, v18);
  function_of(v15)(v17, &v19);
  set_environment(v14, 0, v19);
  create_number_value(1, &v20);
  set_environment(v14, 1, v20);
  function_of(v12)(v14, &v21);
  set_environment(v11, 0, v21);
  // looking up the value for cddr
  get_environment(env, 2, 29, &v22);
  closure_of(v22, &v23);
  // preparing environment with 1 slots for call
  create_environment(v23, 1, &v24);
  // looking up the value for context
  get_environment(env, 0, 0, &v25);
  set_environment(v24, 0, v25);
  function_of(v22)(v24, &v26);
  set_environment(v11, 1, v26);
  function_of(v9)(v11, &v27);
  set_environment(v3, 1, v27);
  function_of(v1)(v3, &v28);
  *pReturn = v28;
  pop_stack_slot(28);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f55(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  // looking up the value for caddr
  get_environment(env, 2, 28, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for context
  get_environment(env, 0, 0, &v4);
  set_environment(v3, 0, v4);
  function_of(v1)(v3, &v5);
  *pReturn = v5;
  pop_stack_slot(5);
  collect(false);
}
// The symbol table for this function is:
// (symbols context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f56(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  // looking up the value for list
  get_environment(env, 2, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 4 slots for call
  create_environment(v2, 4, &v3);
  // looking up the value for car
  get_environment(env, 2, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for context
  get_environment(env, 0, 1, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  // looking up the value for cons
  get_environment(env, 2, 7, &v14);
  closure_of(v14, &v15);
  // preparing environment with 2 slots for call
  create_environment(v15, 2, &v16);
  // looking up the value for symbols
  get_environment(env, 0, 0, &v17);
  set_environment(v16, 0, v17);
  // looking up the value for caddr
  get_environment(env, 2, 28, &v18);
  closure_of(v18, &v19);
  // preparing environment with 1 slots for call
  create_environment(v19, 1, &v20);
  // looking up the value for context
  get_environment(env, 0, 1, &v21);
  set_environment(v20, 0, v21);
  function_of(v18)(v20, &v22);
  set_environment(v16, 1, v22);
  function_of(v14)(v16, &v23);
  set_environment(v3, 2, v23);
  // looking up the value for cadddr
  get_environment(env, 2, 36, &v24);
  closure_of(v24, &v25);
  // preparing environment with 1 slots for call
  create_environment(v25, 1, &v26);
  // looking up the value for context
  get_environment(env, 0, 1, &v27);
  set_environment(v26, 0, v27);
  function_of(v24)(v26, &v28);
  set_environment(v3, 3, v28);
  function_of(v1)(v3, &v29);
  *pReturn = v29;
  pop_stack_slot(29);
  collect(false);
}
// The symbol table for this function is:
// (id body function-context context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f57(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  // looking up the value for list
  get_environment(env, 2, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 4 slots for call
  create_environment(v2, 4, &v3);
  // looking up the value for car
  get_environment(env, 2, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 3, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for context
  get_environment(env, 0, 3, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v3, 1, v13);
  // looking up the value for caddr
  get_environment(env, 2, 28, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for context
  get_environment(env, 0, 3, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v3, 2, v18);
  // looking up the value for cons
  get_environment(env, 2, 7, &v19);
  closure_of(v19, &v20);
  // preparing environment with 2 slots for call
  create_environment(v20, 2, &v21);
  // looking up the value for list
  get_environment(env, 2, 8, &v22);
  closure_of(v22, &v23);
  // preparing environment with 3 slots for call
  create_environment(v23, 3, &v24);
  // looking up the value for id
  get_environment(env, 0, 0, &v25);
  set_environment(v24, 0, v25);
  // looking up the value for body
  get_environment(env, 0, 1, &v26);
  set_environment(v24, 1, v26);
  // looking up the value for function-context
  get_environment(env, 0, 2, &v27);
  set_environment(v24, 2, v27);
  function_of(v22)(v24, &v28);
  set_environment(v21, 0, v28);
  // looking up the value for cadddr
  get_environment(env, 2, 36, &v29);
  closure_of(v29, &v30);
  // preparing environment with 1 slots for call
  create_environment(v30, 1, &v31);
  // looking up the value for context
  get_environment(env, 0, 3, &v32);
  set_environment(v31, 0, v32);
  function_of(v29)(v31, &v33);
  set_environment(v21, 1, v33);
  function_of(v19)(v21, &v34);
  set_environment(v3, 3, v34);
  function_of(v1)(v3, &v35);
  *pReturn = v35;
  pop_stack_slot(35);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f58(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  // looking up the value for cadddr
  get_environment(env, 2, 36, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for context
  get_environment(env, 0, 0, &v4);
  set_environment(v3, 0, v4);
  function_of(v1)(v3, &v5);
  *pReturn = v5;
  pop_stack_slot(5);
  collect(false);
}
// The symbol table for this function is:
// (c)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f59(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  // looking up the value for char>=?
  get_environment(env, 2, 6, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for c
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_char_value('0', &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    // looking up the value for char<=?
  get_environment(env, 2, 5, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for c
  get_environment(env, 0, 0, &v12);
  set_environment(v11, 0, v12);
  create_char_value('9', &v13);
  set_environment(v11, 1, v13);
  function_of(v9)(v11, &v14);
  if (is_true(v14)) {
    create_boolean_value(true, &v15);
    v8 = v15;
  } else {
    create_boolean_value(false, &v16);
    v8 = v16;
  }
    v1 = v8;
  } else {
    create_boolean_value(false, &v17);
    v1 = v17;
  }
  *pReturn = v1;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (input condition)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f60(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for input
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for cons
  get_environment(env, 2, 7, &v7);
  closure_of(v7, &v8);
  // preparing environment with 2 slots for call
  create_environment(v8, 2, &v9);
  create_nil_value(&v11);
  set_environment(v9, 0, v11);
  create_nil_value(&v13);
  set_environment(v9, 1, v13);
  function_of(v7)(v9, &v14);
    v1 = v14;
  } else {
    create_closure(env, f106, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for condition
  get_environment(env, 0, 1, &v18);
  closure_of(v18, &v19);
  // preparing environment with 1 slots for call
  create_environment(v19, 1, &v20);
  // looking up the value for input
  get_environment(env, 0, 0, &v21);
  set_environment(v20, 0, v21);
  function_of(v18)(v20, &v22);
  set_environment(v17, 0, v22);
  function_of(v15)(v17, &v23);
    v1 = v23;
  }
  *pReturn = v1;
  pop_stack_slot(23);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f61(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  // looking up the value for digit?
  get_environment(env, 1, 68, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for car
  get_environment(env, 2, 14, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for input
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  function_of(v2)(v4, &v10);
  if (is_true(v10)) {
    create_symbol_value("keep-going", &v11);
    v1 = v11;
  } else {
    create_symbol_value("drop-and-stop", &v12);
    v1 = v12;
  }
  *pReturn = v1;
  pop_stack_slot(12);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f62(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  // looking up the value for token-end?
  get_environment(env, 1, 74, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for input
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    create_symbol_value("drop-and-stop", &v7);
    v1 = v7;
  } else {
    create_symbol_value("keep-going", &v8);
    v1 = v8;
  }
  *pReturn = v1;
  pop_stack_slot(8);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f63(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  // looking up the value for not
  get_environment(env, 2, 4, &v3);
  closure_of(v3, &v4);
  // preparing environment with 1 slots for call
  create_environment(v4, 1, &v5);
  // looking up the value for equal?
  get_environment(env, 2, 11, &v6);
  closure_of(v6, &v7);
  // preparing environment with 2 slots for call
  create_environment(v7, 2, &v8);
  // looking up the value for car
  get_environment(env, 2, 14, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for input
  get_environment(env, 0, 0, &v12);
  set_environment(v11, 0, v12);
  function_of(v9)(v11, &v13);
  set_environment(v8, 0, v13);
  create_char_value('\\', &v14);
  set_environment(v8, 1, v14);
  function_of(v6)(v8, &v15);
  set_environment(v5, 0, v15);
  function_of(v3)(v5, &v16);
  if (is_true(v16)) {
    // looking up the value for equal?
  get_environment(env, 2, 11, &v18);
  closure_of(v18, &v19);
  // preparing environment with 2 slots for call
  create_environment(v19, 2, &v20);
  // looking up the value for cadr
  get_environment(env, 2, 27, &v21);
  closure_of(v21, &v22);
  // preparing environment with 1 slots for call
  create_environment(v22, 1, &v23);
  // looking up the value for input
  get_environment(env, 0, 0, &v24);
  set_environment(v23, 0, v24);
  function_of(v21)(v23, &v25);
  set_environment(v20, 0, v25);
  create_char_value('"', &v26);
  set_environment(v20, 1, v26);
  function_of(v18)(v20, &v27);
  if (is_true(v27)) {
    create_boolean_value(true, &v28);
    v17 = v28;
  } else {
    create_boolean_value(false, &v29);
    v17 = v29;
  }
    v2 = v17;
  } else {
    create_boolean_value(false, &v30);
    v2 = v30;
  }
  if (is_true(v2)) {
    create_symbol_value("take-and-stop", &v31);
    v1 = v31;
  } else {
    create_symbol_value("keep-going", &v32);
    v1 = v32;
  }
  *pReturn = v1;
  pop_stack_slot(32);
  collect(false);
}
// The symbol table for this function is:
// (lst acc)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f64(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for lst
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for acc
  get_environment(env, 0, 1, &v7);
    v1 = v7;
  } else {
    create_closure(env, f107, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for char->integer
  get_environment(env, 2, 16, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for car
  get_environment(env, 2, 14, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for lst
  get_environment(env, 0, 0, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v13, 0, v18);
  function_of(v11)(v13, &v19);
  set_environment(v10, 0, v19);
  function_of(v8)(v10, &v20);
    v1 = v20;
  }
  *pReturn = v1;
  pop_stack_slot(20);
  collect(false);
}
// The symbol table for this function is:
// (suffix)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f65(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for suffix
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    create_boolean_value(true, &v7);
    v1 = v7;
  } else {
    // looking up the value for member
  get_environment(env, 2, 13, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for car
  get_environment(env, 2, 14, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for suffix
  get_environment(env, 0, 0, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
  set_environment(v11, 0, v16);
  create_char_value(' ', &v20);
  create_char_value('\n', &v23);
  create_char_value('(', &v26);
  create_char_value(')', &v29);
  create_char_value('[', &v32);
  create_char_value(']', &v35);
  create_nil_value(&v36);
  create_cons_cell(v35, v36, &v37);
  create_cons_cell(v32, v37, &v38);
  create_cons_cell(v29, v38, &v39);
  create_cons_cell(v26, v39, &v40);
  create_cons_cell(v23, v40, &v41);
  create_cons_cell(v20, v41, &v42);
  set_environment(v11, 1, v42);
  function_of(v9)(v11, &v43);
  if (is_true(v43)) {
    create_boolean_value(true, &v44);
    v8 = v44;
  } else {
    create_boolean_value(false, &v45);
    v8 = v45;
  }
    v1 = v8;
  }
  *pReturn = v1;
  pop_stack_slot(45);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f66(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for input
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
  create_nil_value(&v8);
    v1 = v8;
  } else {
  // looking up the value for equal?
  get_environment(env, 2, 11, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  // looking up the value for car
  get_environment(env, 2, 14, &v13);
  closure_of(v13, &v14);
  // preparing environment with 1 slots for call
  create_environment(v14, 1, &v15);
  // looking up the value for input
  get_environment(env, 0, 0, &v16);
  set_environment(v15, 0, v16);
  function_of(v13)(v15, &v17);
  set_environment(v12, 0, v17);
  create_char_value('\n', &v18);
  set_environment(v12, 1, v18);
  function_of(v10)(v12, &v19);
  if (is_true(v19)) {
  // looking up the value for cdr
  get_environment(env, 2, 15, &v20);
  closure_of(v20, &v21);
  // preparing environment with 1 slots for call
  create_environment(v21, 1, &v22);
  // looking up the value for input
  get_environment(env, 0, 0, &v23);
  set_environment(v22, 0, v23);
  function_of(v20)(v22, &v24);
    v9 = v24;
  } else {
  // looking up the value for skip-comment
  get_environment(env, 1, 75, &v25);
  closure_of(v25, &v26);
  // preparing environment with 1 slots for call
  create_environment(v26, 1, &v27);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v28);
  closure_of(v28, &v29);
  // preparing environment with 1 slots for call
  create_environment(v29, 1, &v30);
  // looking up the value for input
  get_environment(env, 0, 0, &v31);
  set_environment(v30, 0, v31);
  function_of(v28)(v30, &v32);
  set_environment(v27, 0, v32);
  function_of(v25)(v27, &v33);
    v9 = v33;
  }
    v1 = v9;
  }
  *pReturn = v1;
  pop_stack_slot(33);
  collect(false);
}
// The symbol table for this function is:
// (input prefix)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f67(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for prefix
  get_environment(env, 0, 1, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for list
  get_environment(env, 2, 8, &v7);
  closure_of(v7, &v8);
  // preparing environment with 1 slots for call
  create_environment(v8, 1, &v9);
  // looking up the value for input
  get_environment(env, 0, 0, &v10);
  set_environment(v9, 0, v10);
  function_of(v7)(v9, &v11);
    v1 = v11;
  } else {
    // looking up the value for null?
  get_environment(env, 2, 12, &v13);
  closure_of(v13, &v14);
  // preparing environment with 1 slots for call
  create_environment(v14, 1, &v15);
  // looking up the value for input
  get_environment(env, 0, 0, &v16);
  set_environment(v15, 0, v16);
  function_of(v13)(v15, &v17);
  if (is_true(v17)) {
    create_nil_value(&v19);
    v12 = v19;
  } else {
    // looking up the value for equal?
  get_environment(env, 2, 11, &v21);
  closure_of(v21, &v22);
  // preparing environment with 2 slots for call
  create_environment(v22, 2, &v23);
  // looking up the value for car
  get_environment(env, 2, 14, &v24);
  closure_of(v24, &v25);
  // preparing environment with 1 slots for call
  create_environment(v25, 1, &v26);
  // looking up the value for input
  get_environment(env, 0, 0, &v27);
  set_environment(v26, 0, v27);
  function_of(v24)(v26, &v28);
  set_environment(v23, 0, v28);
  // looking up the value for car
  get_environment(env, 2, 14, &v29);
  closure_of(v29, &v30);
  // preparing environment with 1 slots for call
  create_environment(v30, 1, &v31);
  // looking up the value for prefix
  get_environment(env, 0, 1, &v32);
  set_environment(v31, 0, v32);
  function_of(v29)(v31, &v33);
  set_environment(v23, 1, v33);
  function_of(v21)(v23, &v34);
  if (is_true(v34)) {
    // looking up the value for match
  get_environment(env, 1, 76, &v35);
  closure_of(v35, &v36);
  // preparing environment with 2 slots for call
  create_environment(v36, 2, &v37);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v38);
  closure_of(v38, &v39);
  // preparing environment with 1 slots for call
  create_environment(v39, 1, &v40);
  // looking up the value for input
  get_environment(env, 0, 0, &v41);
  set_environment(v40, 0, v41);
  function_of(v38)(v40, &v42);
  set_environment(v37, 0, v42);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v43);
  closure_of(v43, &v44);
  // preparing environment with 1 slots for call
  create_environment(v44, 1, &v45);
  // looking up the value for prefix
  get_environment(env, 0, 1, &v46);
  set_environment(v45, 0, v46);
  function_of(v43)(v45, &v47);
  set_environment(v37, 1, v47);
  function_of(v35)(v37, &v48);
    v20 = v48;
  } else {
    create_nil_value(&v50);
    v20 = v50;
  }
    v12 = v20;
  }
    v1 = v12;
  }
  *pReturn = v1;
  pop_stack_slot(50);
  collect(false);
}
// The symbol table for this function is:
// (input keywords)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f68(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for keywords
  get_environment(env, 0, 1, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    create_nil_value(&v8);
    v1 = v8;
  } else {
    create_closure(env, f108, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for car
  get_environment(env, 2, 14, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for keywords
  get_environment(env, 0, 1, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
  set_environment(v11, 0, v16);
  function_of(v9)(v11, &v17);
    v1 = v17;
  }
  *pReturn = v1;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f69(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for input
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for cons
  get_environment(env, 2, 7, &v7);
  closure_of(v7, &v8);
  // preparing environment with 2 slots for call
  create_environment(v8, 2, &v9);
  // looking up the value for cons
  get_environment(env, 2, 7, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  create_symbol_value("eof", &v13);
  set_environment(v12, 0, v13);
  create_nil_value(&v15);
  set_environment(v12, 1, v15);
  function_of(v10)(v12, &v16);
  set_environment(v9, 0, v16);
  create_nil_value(&v18);
  set_environment(v9, 1, v18);
  function_of(v7)(v9, &v19);
    v1 = v19;
  } else {
    create_closure(env, f109, &v20);
  closure_of(v20, &v21);
  // preparing environment with 1 slots for call
  create_environment(v21, 1, &v22);
  // looking up the value for lexer-keywords
  get_environment(env, 1, 77, &v23);
  closure_of(v23, &v24);
  // preparing environment with 2 slots for call
  create_environment(v24, 2, &v25);
  // looking up the value for input
  get_environment(env, 0, 0, &v26);
  set_environment(v25, 0, v26);
  // looking up the value for keywords
  get_environment(env, 1, 78, &v27);
  set_environment(v25, 1, v27);
  function_of(v23)(v25, &v28);
  set_environment(v22, 0, v28);
  function_of(v20)(v22, &v29);
    v1 = v29;
  }
  *pReturn = v1;
  pop_stack_slot(29);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f70(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f110, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for lexer
  get_environment(env, 1, 79, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for input
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f71(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f111, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for lexer
  get_environment(env, 1, 79, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for input
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f72(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f112, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for lexer
  get_environment(env, 1, 79, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for input
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f73(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f113, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for lexer
  get_environment(env, 1, 79, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for input
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f74(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f114, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for lexer
  get_environment(env, 1, 79, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for input
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// ()
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f75(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  // looking up the value for cons
  get_environment(env, 2, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for map
  get_environment(env, 1, 0, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for car
  get_environment(env, 2, 14, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for builtins
  get_environment(env, 1, 85, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  create_nil_value(&v11);
  set_environment(v3, 1, v11);
  function_of(v1)(v3, &v12);
  *pReturn = v12;
  pop_stack_slot(12);
  collect(false);
}
// The symbol table for this function is:
// (l target current index)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f76(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for l
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for current
  get_environment(env, 0, 2, &v7);
    v1 = v7;
  } else {
    create_closure(env, f115, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for car
  get_environment(env, 2, 14, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for l
  get_environment(env, 0, 0, &v14);
  set_environment(v13, 0, v14);
  function_of(v11)(v13, &v15);
  set_environment(v10, 0, v15);
  // looking up the value for cdr
  get_environment(env, 2, 15, &v16);
  closure_of(v16, &v17);
  // preparing environment with 1 slots for call
  create_environment(v17, 1, &v18);
  // looking up the value for l
  get_environment(env, 0, 0, &v19);
  set_environment(v18, 0, v19);
  function_of(v16)(v18, &v20);
  set_environment(v10, 1, v20);
  function_of(v8)(v10, &v21);
    v1 = v21;
  }
  *pReturn = v1;
  pop_stack_slot(21);
  collect(false);
}
// The symbol table for this function is:
// (symbol table level)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f77(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  // looking up the value for null?
  get_environment(env, 2, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for table
  get_environment(env, 0, 1, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for error
  get_environment(env, 2, 22, &v7);
  closure_of(v7, &v8);
  // preparing environment with 1 slots for call
  create_environment(v8, 1, &v9);
  // looking up the value for format
  get_environment(env, 2, 26, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  create_string_value("Symbol '~a' is not found", &v13);
  set_environment(v12, 0, v13);
  // looking up the value for symbol
  get_environment(env, 0, 0, &v14);
  set_environment(v12, 1, v14);
  function_of(v10)(v12, &v15);
  set_environment(v9, 0, v15);
  function_of(v7)(v9, &v16);
    v1 = v16;
  } else {
    create_closure(env, f116, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for last-index-of
  get_environment(env, 1, 87, &v20);
  closure_of(v20, &v21);
  // preparing environment with 4 slots for call
  create_environment(v21, 4, &v22);
  // looking up the value for car
  get_environment(env, 2, 14, &v23);
  closure_of(v23, &v24);
  // preparing environment with 1 slots for call
  create_environment(v24, 1, &v25);
  // looking up the value for table
  get_environment(env, 0, 1, &v26);
  set_environment(v25, 0, v26);
  function_of(v23)(v25, &v27);
  set_environment(v22, 0, v27);
  // looking up the value for symbol
  get_environment(env, 0, 0, &v28);
  set_environment(v22, 1, v28);
  create_nil_value(&v30);
  set_environment(v22, 2, v30);
  create_number_value(0, &v31);
  set_environment(v22, 3, v31);
  function_of(v20)(v22, &v32);
  set_environment(v19, 0, v32);
  function_of(v17)(v19, &v33);
    v1 = v33;
  }
  *pReturn = v1;
  pop_stack_slot(33);
  collect(false);
}
// The symbol table for this function is:
// (lst acc)
// (helper)
// (lst)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f78(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  // looking up the value for null?
  get_environment(env, 4, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for lst
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for acc
  get_environment(env, 0, 1, &v7);
    v1 = v7;
  } else {
    // looking up the value for helper
  get_environment(env, 1, 0, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for lst
  get_environment(env, 0, 0, &v14);
  set_environment(v13, 0, v14);
  function_of(v11)(v13, &v15);
  set_environment(v10, 0, v15);
  // looking up the value for cons
  get_environment(env, 4, 7, &v16);
  closure_of(v16, &v17);
  // preparing environment with 2 slots for call
  create_environment(v17, 2, &v18);
  // looking up the value for car
  get_environment(env, 4, 14, &v19);
  closure_of(v19, &v20);
  // preparing environment with 1 slots for call
  create_environment(v20, 1, &v21);
  // looking up the value for lst
  get_environment(env, 0, 0, &v22);
  set_environment(v21, 0, v22);
  function_of(v19)(v21, &v23);
  set_environment(v18, 0, v23);
  // looking up the value for acc
  get_environment(env, 0, 1, &v24);
  set_environment(v18, 1, v24);
  function_of(v16)(v18, &v25);
  set_environment(v10, 1, v25);
  function_of(v8)(v10, &v26);
    v1 = v26;
  }
  *pReturn = v1;
  pop_stack_slot(26);
  collect(false);
}
// The symbol table for this function is:
// (generated-code)
// (input parsed-program)
// (input-file output-file)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f79(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  // looking up the value for write-file
  get_environment(env, 4, 37, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for output-file
  get_environment(env, 2, 1, &v4);
  set_environment(v3, 0, v4);
  // looking up the value for generated-code
  get_environment(env, 0, 0, &v5);
  set_environment(v3, 1, v5);
  function_of(v1)(v3, &v6);
  *pReturn = v6;
  pop_stack_slot(6);
  collect(false);
}
// The symbol table for this function is:
// (number-value variable-id context)
// (number-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f80(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  // looking up the value for list
  get_environment(env, 3, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 3, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for format
  get_environment(env, 3, 26, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  create_string_value("  create_number_value(~a, &v~a);\n", &v10);
  set_environment(v9, 0, v10);
  // looking up the value for number-value
  get_environment(env, 0, 0, &v11);
  set_environment(v9, 1, v11);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v12);
  set_environment(v9, 2, v12);
  function_of(v7)(v9, &v13);
  set_environment(v6, 0, v13);
  // looking up the value for optional-collect
  get_environment(env, 2, 19, &v14);
  closure_of(v14, &v15);
  // preparing environment with 0 slots for call
  create_environment(v15, 0, &v16);
  function_of(v14)(v16, &v17);
  set_environment(v6, 1, v17);
  function_of(v4)(v6, &v18);
  set_environment(v3, 0, v18);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v19);
  set_environment(v3, 1, v19);
  // looking up the value for context
  get_environment(env, 0, 2, &v20);
  set_environment(v3, 2, v20);
  function_of(v1)(v3, &v21);
  *pReturn = v21;
  pop_stack_slot(21);
  collect(false);
}
// The symbol table for this function is:
// (bool-value variable-id context)
// (bool-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f81(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  // looking up the value for list
  get_environment(env, 3, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 3, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for format
  get_environment(env, 3, 26, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  create_string_value("  create_boolean_value(~a, &v~a);\n", &v10);
  set_environment(v9, 0, v10);
  // looking up the value for bool-value
  get_environment(env, 0, 0, &v12);
  if (is_true(v12)) {
    create_string_value("true", &v13);
    v11 = v13;
  } else {
    create_string_value("false", &v14);
    v11 = v14;
  }
  set_environment(v9, 1, v11);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v15);
  set_environment(v9, 2, v15);
  function_of(v7)(v9, &v16);
  set_environment(v6, 0, v16);
  // looking up the value for optional-collect
  get_environment(env, 2, 19, &v17);
  closure_of(v17, &v18);
  // preparing environment with 0 slots for call
  create_environment(v18, 0, &v19);
  function_of(v17)(v19, &v20);
  set_environment(v6, 1, v20);
  function_of(v4)(v6, &v21);
  set_environment(v3, 0, v21);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v22);
  set_environment(v3, 1, v22);
  // looking up the value for context
  get_environment(env, 0, 2, &v23);
  set_environment(v3, 2, v23);
  function_of(v1)(v3, &v24);
  *pReturn = v24;
  pop_stack_slot(24);
  collect(false);
}
// The symbol table for this function is:
// (char-value variable-id context)
// (char-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f82(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  // looking up the value for list
  get_environment(env, 3, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 3, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for equal?
  get_environment(env, 3, 11, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for char-value
  get_environment(env, 0, 0, &v11);
  set_environment(v10, 0, v11);
  create_char_value('\n', &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
  if (is_true(v13)) {
  // looking up the value for format
  get_environment(env, 3, 26, &v14);
  closure_of(v14, &v15);
  // preparing environment with 2 slots for call
  create_environment(v15, 2, &v16);
  create_string_value("  create_char_value('\\n', &v~a);\n", &v17);
  set_environment(v16, 0, v17);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v18);
  set_environment(v16, 1, v18);
  function_of(v14)(v16, &v19);
    v7 = v19;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v21);
  closure_of(v21, &v22);
  // preparing environment with 2 slots for call
  create_environment(v22, 2, &v23);
  // looking up the value for char-value
  get_environment(env, 0, 0, &v24);
  set_environment(v23, 0, v24);
  create_char_value('\'', &v25);
  set_environment(v23, 1, v25);
  function_of(v21)(v23, &v26);
  if (is_true(v26)) {
  // looking up the value for format
  get_environment(env, 3, 26, &v27);
  closure_of(v27, &v28);
  // preparing environment with 2 slots for call
  create_environment(v28, 2, &v29);
  create_string_value("  create_char_value('\\'', &v~a);\n", &v30);
  set_environment(v29, 0, v30);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v31);
  set_environment(v29, 1, v31);
  function_of(v27)(v29, &v32);
    v20 = v32;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v34);
  closure_of(v34, &v35);
  // preparing environment with 2 slots for call
  create_environment(v35, 2, &v36);
  // looking up the value for char-value
  get_environment(env, 0, 0, &v37);
  set_environment(v36, 0, v37);
  create_char_value('\\', &v38);
  set_environment(v36, 1, v38);
  function_of(v34)(v36, &v39);
  if (is_true(v39)) {
  // looking up the value for format
  get_environment(env, 3, 26, &v40);
  closure_of(v40, &v41);
  // preparing environment with 2 slots for call
  create_environment(v41, 2, &v42);
  create_string_value("  create_char_value('\\\\', &v~a);\n", &v43);
  set_environment(v42, 0, v43);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v44);
  set_environment(v42, 1, v44);
  function_of(v40)(v42, &v45);
    v33 = v45;
  } else {
  // looking up the value for format
  get_environment(env, 3, 26, &v46);
  closure_of(v46, &v47);
  // preparing environment with 3 slots for call
  create_environment(v47, 3, &v48);
  create_string_value("  create_char_value('~a', &v~a);\n", &v49);
  set_environment(v48, 0, v49);
  // looking up the value for char-value
  get_environment(env, 0, 0, &v50);
  set_environment(v48, 1, v50);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v51);
  set_environment(v48, 2, v51);
  function_of(v46)(v48, &v52);
    v33 = v52;
  }
    v20 = v33;
  }
    v7 = v20;
  }
  set_environment(v6, 0, v7);
  // looking up the value for optional-collect
  get_environment(env, 2, 19, &v53);
  closure_of(v53, &v54);
  // preparing environment with 0 slots for call
  create_environment(v54, 0, &v55);
  function_of(v53)(v55, &v56);
  set_environment(v6, 1, v56);
  function_of(v4)(v6, &v57);
  set_environment(v3, 0, v57);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v58);
  set_environment(v3, 1, v58);
  // looking up the value for context
  get_environment(env, 0, 2, &v59);
  set_environment(v3, 2, v59);
  function_of(v1)(v3, &v60);
  *pReturn = v60;
  pop_stack_slot(60);
  collect(false);
}
// The symbol table for this function is:
// (string-value variable-id context)
// (string-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f83(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  // looking up the value for list
  get_environment(env, 3, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 3, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for format
  get_environment(env, 3, 26, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  create_string_value("  create_string_value(\"~a\", &v~a);\n", &v10);
  set_environment(v9, 0, v10);
  // looking up the value for string-value
  get_environment(env, 0, 0, &v11);
  set_environment(v9, 1, v11);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v12);
  set_environment(v9, 2, v12);
  function_of(v7)(v9, &v13);
  set_environment(v6, 0, v13);
  // looking up the value for optional-collect
  get_environment(env, 2, 19, &v14);
  closure_of(v14, &v15);
  // preparing environment with 0 slots for call
  create_environment(v15, 0, &v16);
  function_of(v14)(v16, &v17);
  set_environment(v6, 1, v17);
  function_of(v4)(v6, &v18);
  set_environment(v3, 0, v18);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v19);
  set_environment(v3, 1, v19);
  // looking up the value for context
  get_environment(env, 0, 2, &v20);
  set_environment(v3, 2, v20);
  function_of(v1)(v3, &v21);
  *pReturn = v21;
  pop_stack_slot(21);
  collect(false);
}
// The symbol table for this function is:
// (symbol-value)
// (symbol-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f84(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f117, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 2, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f85(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f118, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 3, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for if-statement
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (head arguments)
// (and-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f86(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  // looking up the value for null?
  get_environment(env, 3, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for arguments
  get_environment(env, 0, 1, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for generate-bool-statement
  get_environment(env, 2, 24, &v7);
  closure_of(v7, &v8);
  // preparing environment with 2 slots for call
  create_environment(v8, 2, &v9);
  // looking up the value for cons
  get_environment(env, 3, 7, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  create_symbol_value("bool-statement", &v13);
  set_environment(v12, 0, v13);
  create_boolean_value(true, &v14);
  set_environment(v12, 1, v14);
  function_of(v10)(v12, &v15);
  set_environment(v9, 0, v15);
  // looking up the value for context
  get_environment(env, 1, 1, &v16);
  set_environment(v9, 1, v16);
  function_of(v7)(v9, &v17);
    v1 = v17;
  } else {
    create_closure(env, f119, &v18);
  closure_of(v18, &v19);
  // preparing environment with 1 slots for call
  create_environment(v19, 1, &v20);
  // looking up the value for car
  get_environment(env, 3, 14, &v21);
  closure_of(v21, &v22);
  // preparing environment with 1 slots for call
  create_environment(v22, 1, &v23);
  // looking up the value for arguments
  get_environment(env, 0, 1, &v24);
  set_environment(v23, 0, v24);
  function_of(v21)(v23, &v25);
  set_environment(v20, 0, v25);
  function_of(v18)(v20, &v26);
    v1 = v26;
  }
  *pReturn = v1;
  pop_stack_slot(26);
  collect(false);
}
// The symbol table for this function is:
// (head arguments)
// (or-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f87(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  // looking up the value for null?
  get_environment(env, 3, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for arguments
  get_environment(env, 0, 1, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for generate-bool-statement
  get_environment(env, 2, 24, &v7);
  closure_of(v7, &v8);
  // preparing environment with 2 slots for call
  create_environment(v8, 2, &v9);
  // looking up the value for cons
  get_environment(env, 3, 7, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  create_symbol_value("bool-statement", &v13);
  set_environment(v12, 0, v13);
  create_boolean_value(false, &v14);
  set_environment(v12, 1, v14);
  function_of(v10)(v12, &v15);
  set_environment(v9, 0, v15);
  // looking up the value for context
  get_environment(env, 1, 1, &v16);
  set_environment(v9, 1, v16);
  function_of(v7)(v9, &v17);
    v1 = v17;
  } else {
    create_closure(env, f120, &v18);
  closure_of(v18, &v19);
  // preparing environment with 1 slots for call
  create_environment(v19, 1, &v20);
  // looking up the value for car
  get_environment(env, 3, 14, &v21);
  closure_of(v21, &v22);
  // preparing environment with 1 slots for call
  create_environment(v22, 1, &v23);
  // looking up the value for arguments
  get_environment(env, 0, 1, &v24);
  set_environment(v23, 0, v24);
  function_of(v21)(v23, &v25);
  set_environment(v20, 0, v25);
  function_of(v18)(v20, &v26);
    v1 = v26;
  }
  *pReturn = v1;
  pop_stack_slot(26);
  collect(false);
}
// The symbol table for this function is:
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f88(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f121, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 2, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (list-statement-list)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f89(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  ekans_value* v66 = NULL;
  push_stack_slot(&v66);
  ekans_value* v67 = NULL;
  push_stack_slot(&v67);
  ekans_value* v68 = NULL;
  push_stack_slot(&v68);
  ekans_value* v69 = NULL;
  push_stack_slot(&v69);
  ekans_value* v70 = NULL;
  push_stack_slot(&v70);
  ekans_value* v71 = NULL;
  push_stack_slot(&v71);
  ekans_value* v72 = NULL;
  push_stack_slot(&v72);
  ekans_value* v73 = NULL;
  push_stack_slot(&v73);
  ekans_value* v74 = NULL;
  push_stack_slot(&v74);
  ekans_value* v75 = NULL;
  push_stack_slot(&v75);
  ekans_value* v76 = NULL;
  push_stack_slot(&v76);
  ekans_value* v77 = NULL;
  push_stack_slot(&v77);
  ekans_value* v78 = NULL;
  push_stack_slot(&v78);
  ekans_value* v79 = NULL;
  push_stack_slot(&v79);
  ekans_value* v80 = NULL;
  push_stack_slot(&v80);
  ekans_value* v81 = NULL;
  push_stack_slot(&v81);
  ekans_value* v82 = NULL;
  push_stack_slot(&v82);
  ekans_value* v83 = NULL;
  push_stack_slot(&v83);
  ekans_value* v84 = NULL;
  push_stack_slot(&v84);
  ekans_value* v85 = NULL;
  push_stack_slot(&v85);
  ekans_value* v86 = NULL;
  push_stack_slot(&v86);
  ekans_value* v87 = NULL;
  push_stack_slot(&v87);
  ekans_value* v88 = NULL;
  push_stack_slot(&v88);
  ekans_value* v89 = NULL;
  push_stack_slot(&v89);
  ekans_value* v90 = NULL;
  push_stack_slot(&v90);
  ekans_value* v91 = NULL;
  push_stack_slot(&v91);
  ekans_value* v92 = NULL;
  push_stack_slot(&v92);
  ekans_value* v93 = NULL;
  push_stack_slot(&v93);
  ekans_value* v94 = NULL;
  push_stack_slot(&v94);
  ekans_value* v95 = NULL;
  push_stack_slot(&v95);
  ekans_value* v96 = NULL;
  push_stack_slot(&v96);
  ekans_value* v97 = NULL;
  push_stack_slot(&v97);
  ekans_value* v98 = NULL;
  push_stack_slot(&v98);
  ekans_value* v99 = NULL;
  push_stack_slot(&v99);
  ekans_value* v100 = NULL;
  push_stack_slot(&v100);
  ekans_value* v101 = NULL;
  push_stack_slot(&v101);
  ekans_value* v102 = NULL;
  push_stack_slot(&v102);
  ekans_value* v103 = NULL;
  push_stack_slot(&v103);
  ekans_value* v104 = NULL;
  push_stack_slot(&v104);
  ekans_value* v105 = NULL;
  push_stack_slot(&v105);
  ekans_value* v106 = NULL;
  push_stack_slot(&v106);
  ekans_value* v107 = NULL;
  push_stack_slot(&v107);
  ekans_value* v108 = NULL;
  push_stack_slot(&v108);
  ekans_value* v109 = NULL;
  push_stack_slot(&v109);
  ekans_value* v110 = NULL;
  push_stack_slot(&v110);
  ekans_value* v111 = NULL;
  push_stack_slot(&v111);
  ekans_value* v112 = NULL;
  push_stack_slot(&v112);
  ekans_value* v113 = NULL;
  push_stack_slot(&v113);
  ekans_value* v114 = NULL;
  push_stack_slot(&v114);
  ekans_value* v115 = NULL;
  push_stack_slot(&v115);
  ekans_value* v116 = NULL;
  push_stack_slot(&v116);
  ekans_value* v117 = NULL;
  push_stack_slot(&v117);
  ekans_value* v118 = NULL;
  push_stack_slot(&v118);
  ekans_value* v119 = NULL;
  push_stack_slot(&v119);
  ekans_value* v120 = NULL;
  push_stack_slot(&v120);
  ekans_value* v121 = NULL;
  push_stack_slot(&v121);
  ekans_value* v122 = NULL;
  push_stack_slot(&v122);
  ekans_value* v123 = NULL;
  push_stack_slot(&v123);
  ekans_value* v124 = NULL;
  push_stack_slot(&v124);
  ekans_value* v125 = NULL;
  push_stack_slot(&v125);
  ekans_value* v126 = NULL;
  push_stack_slot(&v126);
  ekans_value* v127 = NULL;
  push_stack_slot(&v127);
  ekans_value* v128 = NULL;
  push_stack_slot(&v128);
  ekans_value* v129 = NULL;
  push_stack_slot(&v129);
  ekans_value* v130 = NULL;
  push_stack_slot(&v130);
  ekans_value* v131 = NULL;
  push_stack_slot(&v131);
  ekans_value* v132 = NULL;
  push_stack_slot(&v132);
  ekans_value* v133 = NULL;
  push_stack_slot(&v133);
  ekans_value* v134 = NULL;
  push_stack_slot(&v134);
  ekans_value* v135 = NULL;
  push_stack_slot(&v135);
  ekans_value* v136 = NULL;
  push_stack_slot(&v136);
  ekans_value* v137 = NULL;
  push_stack_slot(&v137);
  ekans_value* v138 = NULL;
  push_stack_slot(&v138);
  ekans_value* v139 = NULL;
  push_stack_slot(&v139);
  ekans_value* v140 = NULL;
  push_stack_slot(&v140);
  ekans_value* v141 = NULL;
  push_stack_slot(&v141);
  ekans_value* v142 = NULL;
  push_stack_slot(&v142);
  ekans_value* v143 = NULL;
  push_stack_slot(&v143);
  ekans_value* v144 = NULL;
  push_stack_slot(&v144);
  ekans_value* v145 = NULL;
  push_stack_slot(&v145);
  ekans_value* v146 = NULL;
  push_stack_slot(&v146);
  ekans_value* v147 = NULL;
  push_stack_slot(&v147);
  ekans_value* v148 = NULL;
  push_stack_slot(&v148);
  ekans_value* v149 = NULL;
  push_stack_slot(&v149);
  ekans_value* v150 = NULL;
  push_stack_slot(&v150);
  ekans_value* v151 = NULL;
  push_stack_slot(&v151);
  ekans_value* v152 = NULL;
  push_stack_slot(&v152);
  ekans_value* v153 = NULL;
  push_stack_slot(&v153);
  ekans_value* v154 = NULL;
  push_stack_slot(&v154);
  ekans_value* v155 = NULL;
  push_stack_slot(&v155);
  ekans_value* v156 = NULL;
  push_stack_slot(&v156);
  ekans_value* v157 = NULL;
  push_stack_slot(&v157);
  ekans_value* v158 = NULL;
  push_stack_slot(&v158);
  ekans_value* v159 = NULL;
  push_stack_slot(&v159);
  ekans_value* v160 = NULL;
  push_stack_slot(&v160);
  ekans_value* v161 = NULL;
  push_stack_slot(&v161);
  ekans_value* v162 = NULL;
  push_stack_slot(&v162);
  ekans_value* v163 = NULL;
  push_stack_slot(&v163);
  ekans_value* v164 = NULL;
  push_stack_slot(&v164);
  ekans_value* v165 = NULL;
  push_stack_slot(&v165);
  ekans_value* v166 = NULL;
  push_stack_slot(&v166);
  ekans_value* v167 = NULL;
  push_stack_slot(&v167);
  ekans_value* v168 = NULL;
  push_stack_slot(&v168);
  ekans_value* v169 = NULL;
  push_stack_slot(&v169);
  ekans_value* v170 = NULL;
  push_stack_slot(&v170);
  ekans_value* v171 = NULL;
  push_stack_slot(&v171);
  ekans_value* v172 = NULL;
  push_stack_slot(&v172);
  ekans_value* v173 = NULL;
  push_stack_slot(&v173);
  ekans_value* v174 = NULL;
  push_stack_slot(&v174);
  ekans_value* v175 = NULL;
  push_stack_slot(&v175);
  ekans_value* v176 = NULL;
  push_stack_slot(&v176);
  ekans_value* v177 = NULL;
  push_stack_slot(&v177);
  ekans_value* v178 = NULL;
  push_stack_slot(&v178);
  ekans_value* v179 = NULL;
  push_stack_slot(&v179);
  ekans_value* v180 = NULL;
  push_stack_slot(&v180);
  ekans_value* v181 = NULL;
  push_stack_slot(&v181);
  ekans_value* v182 = NULL;
  push_stack_slot(&v182);
  ekans_value* v183 = NULL;
  push_stack_slot(&v183);
  ekans_value* v184 = NULL;
  push_stack_slot(&v184);
  ekans_value* v185 = NULL;
  push_stack_slot(&v185);
  ekans_value* v186 = NULL;
  push_stack_slot(&v186);
  ekans_value* v187 = NULL;
  push_stack_slot(&v187);
  ekans_value* v188 = NULL;
  push_stack_slot(&v188);
  ekans_value* v189 = NULL;
  push_stack_slot(&v189);
  ekans_value* v190 = NULL;
  push_stack_slot(&v190);
  ekans_value* v191 = NULL;
  push_stack_slot(&v191);
  ekans_value* v192 = NULL;
  push_stack_slot(&v192);
  ekans_value* v193 = NULL;
  push_stack_slot(&v193);
  ekans_value* v194 = NULL;
  push_stack_slot(&v194);
  ekans_value* v195 = NULL;
  push_stack_slot(&v195);
  ekans_value* v196 = NULL;
  push_stack_slot(&v196);
  ekans_value* v197 = NULL;
  push_stack_slot(&v197);
  ekans_value* v198 = NULL;
  push_stack_slot(&v198);
  ekans_value* v199 = NULL;
  push_stack_slot(&v199);
  ekans_value* v200 = NULL;
  push_stack_slot(&v200);
  ekans_value* v201 = NULL;
  push_stack_slot(&v201);
  ekans_value* v202 = NULL;
  push_stack_slot(&v202);
  ekans_value* v203 = NULL;
  push_stack_slot(&v203);
  ekans_value* v204 = NULL;
  push_stack_slot(&v204);
  ekans_value* v205 = NULL;
  push_stack_slot(&v205);
  ekans_value* v206 = NULL;
  push_stack_slot(&v206);
  ekans_value* v207 = NULL;
  push_stack_slot(&v207);
  ekans_value* v208 = NULL;
  push_stack_slot(&v208);
  ekans_value* v209 = NULL;
  push_stack_slot(&v209);
  ekans_value* v210 = NULL;
  push_stack_slot(&v210);
  ekans_value* v211 = NULL;
  push_stack_slot(&v211);
  ekans_value* v212 = NULL;
  push_stack_slot(&v212);
  ekans_value* v213 = NULL;
  push_stack_slot(&v213);
  ekans_value* v214 = NULL;
  push_stack_slot(&v214);
  ekans_value* v215 = NULL;
  push_stack_slot(&v215);
  ekans_value* v216 = NULL;
  push_stack_slot(&v216);
  ekans_value* v217 = NULL;
  push_stack_slot(&v217);
  ekans_value* v218 = NULL;
  push_stack_slot(&v218);
  ekans_value* v219 = NULL;
  push_stack_slot(&v219);
  ekans_value* v220 = NULL;
  push_stack_slot(&v220);
  ekans_value* v221 = NULL;
  push_stack_slot(&v221);
  ekans_value* v222 = NULL;
  push_stack_slot(&v222);
  ekans_value* v223 = NULL;
  push_stack_slot(&v223);
  ekans_value* v224 = NULL;
  push_stack_slot(&v224);
  ekans_value* v225 = NULL;
  push_stack_slot(&v225);
  ekans_value* v226 = NULL;
  push_stack_slot(&v226);
  ekans_value* v227 = NULL;
  push_stack_slot(&v227);
  ekans_value* v228 = NULL;
  push_stack_slot(&v228);
  ekans_value* v229 = NULL;
  push_stack_slot(&v229);
  ekans_value* v230 = NULL;
  push_stack_slot(&v230);
  // looking up the value for equal?
  get_environment(env, 3, 11, &v3);
  closure_of(v3, &v4);
  // preparing environment with 2 slots for call
  create_environment(v4, 2, &v5);
  // looking up the value for caar
  get_environment(env, 3, 33, &v6);
  closure_of(v6, &v7);
  // preparing environment with 1 slots for call
  create_environment(v7, 1, &v8);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v9);
  set_environment(v8, 0, v9);
  function_of(v6)(v8, &v10);
  set_environment(v5, 0, v10);
  create_symbol_value("symbol-statement", &v11);
  set_environment(v5, 1, v11);
  function_of(v3)(v5, &v12);
  if (is_true(v12)) {
    // looking up the value for equal?
  get_environment(env, 3, 11, &v14);
  closure_of(v14, &v15);
  // preparing environment with 2 slots for call
  create_environment(v15, 2, &v16);
  // looking up the value for cdar
  get_environment(env, 3, 34, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v20);
  set_environment(v19, 0, v20);
  function_of(v17)(v19, &v21);
  set_environment(v16, 0, v21);
  create_string_value("lambda", &v22);
  set_environment(v16, 1, v22);
  function_of(v14)(v16, &v23);
  if (is_true(v23)) {
    create_boolean_value(true, &v24);
    v13 = v24;
  } else {
    create_boolean_value(false, &v25);
    v13 = v25;
  }
    v2 = v13;
  } else {
    create_boolean_value(false, &v26);
    v2 = v26;
  }
  if (is_true(v2)) {
  // looking up the value for generate-lambda
  get_environment(env, 2, 34, &v27);
  closure_of(v27, &v28);
  // preparing environment with 2 slots for call
  create_environment(v28, 2, &v29);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v30);
  set_environment(v29, 0, v30);
  // looking up the value for context
  get_environment(env, 1, 1, &v31);
  set_environment(v29, 1, v31);
  function_of(v27)(v29, &v32);
    v1 = v32;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v35);
  closure_of(v35, &v36);
  // preparing environment with 2 slots for call
  create_environment(v36, 2, &v37);
  // looking up the value for caar
  get_environment(env, 3, 33, &v38);
  closure_of(v38, &v39);
  // preparing environment with 1 slots for call
  create_environment(v39, 1, &v40);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v41);
  set_environment(v40, 0, v41);
  function_of(v38)(v40, &v42);
  set_environment(v37, 0, v42);
  create_symbol_value("symbol-statement", &v43);
  set_environment(v37, 1, v43);
  function_of(v35)(v37, &v44);
  if (is_true(v44)) {
    // looking up the value for equal?
  get_environment(env, 3, 11, &v46);
  closure_of(v46, &v47);
  // preparing environment with 2 slots for call
  create_environment(v47, 2, &v48);
  // looking up the value for cdar
  get_environment(env, 3, 34, &v49);
  closure_of(v49, &v50);
  // preparing environment with 1 slots for call
  create_environment(v50, 1, &v51);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v52);
  set_environment(v51, 0, v52);
  function_of(v49)(v51, &v53);
  set_environment(v48, 0, v53);
  create_string_value("let", &v54);
  set_environment(v48, 1, v54);
  function_of(v46)(v48, &v55);
  if (is_true(v55)) {
    create_boolean_value(true, &v56);
    v45 = v56;
  } else {
    create_boolean_value(false, &v57);
    v45 = v57;
  }
    v34 = v45;
  } else {
    create_boolean_value(false, &v58);
    v34 = v58;
  }
  if (is_true(v34)) {
  // looking up the value for generate-let
  get_environment(env, 2, 37, &v59);
  closure_of(v59, &v60);
  // preparing environment with 2 slots for call
  create_environment(v60, 2, &v61);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v62);
  set_environment(v61, 0, v62);
  // looking up the value for context
  get_environment(env, 1, 1, &v63);
  set_environment(v61, 1, v63);
  function_of(v59)(v61, &v64);
    v33 = v64;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v67);
  closure_of(v67, &v68);
  // preparing environment with 2 slots for call
  create_environment(v68, 2, &v69);
  // looking up the value for caar
  get_environment(env, 3, 33, &v70);
  closure_of(v70, &v71);
  // preparing environment with 1 slots for call
  create_environment(v71, 1, &v72);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v73);
  set_environment(v72, 0, v73);
  function_of(v70)(v72, &v74);
  set_environment(v69, 0, v74);
  create_symbol_value("symbol-statement", &v75);
  set_environment(v69, 1, v75);
  function_of(v67)(v69, &v76);
  if (is_true(v76)) {
    // looking up the value for equal?
  get_environment(env, 3, 11, &v78);
  closure_of(v78, &v79);
  // preparing environment with 2 slots for call
  create_environment(v79, 2, &v80);
  // looking up the value for cdar
  get_environment(env, 3, 34, &v81);
  closure_of(v81, &v82);
  // preparing environment with 1 slots for call
  create_environment(v82, 1, &v83);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v84);
  set_environment(v83, 0, v84);
  function_of(v81)(v83, &v85);
  set_environment(v80, 0, v85);
  create_string_value("let*", &v86);
  set_environment(v80, 1, v86);
  function_of(v78)(v80, &v87);
  if (is_true(v87)) {
    create_boolean_value(true, &v88);
    v77 = v88;
  } else {
    create_boolean_value(false, &v89);
    v77 = v89;
  }
    v66 = v77;
  } else {
    create_boolean_value(false, &v90);
    v66 = v90;
  }
  if (is_true(v66)) {
  // looking up the value for generate-let-star
  get_environment(env, 2, 38, &v91);
  closure_of(v91, &v92);
  // preparing environment with 2 slots for call
  create_environment(v92, 2, &v93);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v94);
  set_environment(v93, 0, v94);
  // looking up the value for context
  get_environment(env, 1, 1, &v95);
  set_environment(v93, 1, v95);
  function_of(v91)(v93, &v96);
    v65 = v96;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v99);
  closure_of(v99, &v100);
  // preparing environment with 2 slots for call
  create_environment(v100, 2, &v101);
  // looking up the value for caar
  get_environment(env, 3, 33, &v102);
  closure_of(v102, &v103);
  // preparing environment with 1 slots for call
  create_environment(v103, 1, &v104);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v105);
  set_environment(v104, 0, v105);
  function_of(v102)(v104, &v106);
  set_environment(v101, 0, v106);
  create_symbol_value("symbol-statement", &v107);
  set_environment(v101, 1, v107);
  function_of(v99)(v101, &v108);
  if (is_true(v108)) {
    // looking up the value for equal?
  get_environment(env, 3, 11, &v110);
  closure_of(v110, &v111);
  // preparing environment with 2 slots for call
  create_environment(v111, 2, &v112);
  // looking up the value for cdar
  get_environment(env, 3, 34, &v113);
  closure_of(v113, &v114);
  // preparing environment with 1 slots for call
  create_environment(v114, 1, &v115);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v116);
  set_environment(v115, 0, v116);
  function_of(v113)(v115, &v117);
  set_environment(v112, 0, v117);
  create_string_value("if", &v118);
  set_environment(v112, 1, v118);
  function_of(v110)(v112, &v119);
  if (is_true(v119)) {
    create_boolean_value(true, &v120);
    v109 = v120;
  } else {
    create_boolean_value(false, &v121);
    v109 = v121;
  }
    v98 = v109;
  } else {
    create_boolean_value(false, &v122);
    v98 = v122;
  }
  if (is_true(v98)) {
  // looking up the value for generate-if-statement
  get_environment(env, 2, 28, &v123);
  closure_of(v123, &v124);
  // preparing environment with 2 slots for call
  create_environment(v124, 2, &v125);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v126);
  set_environment(v125, 0, v126);
  // looking up the value for context
  get_environment(env, 1, 1, &v127);
  set_environment(v125, 1, v127);
  function_of(v123)(v125, &v128);
    v97 = v128;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v131);
  closure_of(v131, &v132);
  // preparing environment with 2 slots for call
  create_environment(v132, 2, &v133);
  // looking up the value for caar
  get_environment(env, 3, 33, &v134);
  closure_of(v134, &v135);
  // preparing environment with 1 slots for call
  create_environment(v135, 1, &v136);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v137);
  set_environment(v136, 0, v137);
  function_of(v134)(v136, &v138);
  set_environment(v133, 0, v138);
  create_symbol_value("symbol-statement", &v139);
  set_environment(v133, 1, v139);
  function_of(v131)(v133, &v140);
  if (is_true(v140)) {
    // looking up the value for equal?
  get_environment(env, 3, 11, &v142);
  closure_of(v142, &v143);
  // preparing environment with 2 slots for call
  create_environment(v143, 2, &v144);
  // looking up the value for cdar
  get_environment(env, 3, 34, &v145);
  closure_of(v145, &v146);
  // preparing environment with 1 slots for call
  create_environment(v146, 1, &v147);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v148);
  set_environment(v147, 0, v148);
  function_of(v145)(v147, &v149);
  set_environment(v144, 0, v149);
  create_string_value("and", &v150);
  set_environment(v144, 1, v150);
  function_of(v142)(v144, &v151);
  if (is_true(v151)) {
    create_boolean_value(true, &v152);
    v141 = v152;
  } else {
    create_boolean_value(false, &v153);
    v141 = v153;
  }
    v130 = v141;
  } else {
    create_boolean_value(false, &v154);
    v130 = v154;
  }
  if (is_true(v130)) {
  // looking up the value for generate-and-statement
  get_environment(env, 2, 29, &v155);
  closure_of(v155, &v156);
  // preparing environment with 2 slots for call
  create_environment(v156, 2, &v157);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v158);
  set_environment(v157, 0, v158);
  // looking up the value for context
  get_environment(env, 1, 1, &v159);
  set_environment(v157, 1, v159);
  function_of(v155)(v157, &v160);
    v129 = v160;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v163);
  closure_of(v163, &v164);
  // preparing environment with 2 slots for call
  create_environment(v164, 2, &v165);
  // looking up the value for caar
  get_environment(env, 3, 33, &v166);
  closure_of(v166, &v167);
  // preparing environment with 1 slots for call
  create_environment(v167, 1, &v168);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v169);
  set_environment(v168, 0, v169);
  function_of(v166)(v168, &v170);
  set_environment(v165, 0, v170);
  create_symbol_value("symbol-statement", &v171);
  set_environment(v165, 1, v171);
  function_of(v163)(v165, &v172);
  if (is_true(v172)) {
    // looking up the value for equal?
  get_environment(env, 3, 11, &v174);
  closure_of(v174, &v175);
  // preparing environment with 2 slots for call
  create_environment(v175, 2, &v176);
  // looking up the value for cdar
  get_environment(env, 3, 34, &v177);
  closure_of(v177, &v178);
  // preparing environment with 1 slots for call
  create_environment(v178, 1, &v179);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v180);
  set_environment(v179, 0, v180);
  function_of(v177)(v179, &v181);
  set_environment(v176, 0, v181);
  create_string_value("or", &v182);
  set_environment(v176, 1, v182);
  function_of(v174)(v176, &v183);
  if (is_true(v183)) {
    create_boolean_value(true, &v184);
    v173 = v184;
  } else {
    create_boolean_value(false, &v185);
    v173 = v185;
  }
    v162 = v173;
  } else {
    create_boolean_value(false, &v186);
    v162 = v186;
  }
  if (is_true(v162)) {
  // looking up the value for generate-or-statement
  get_environment(env, 2, 30, &v187);
  closure_of(v187, &v188);
  // preparing environment with 2 slots for call
  create_environment(v188, 2, &v189);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v190);
  set_environment(v189, 0, v190);
  // looking up the value for context
  get_environment(env, 1, 1, &v191);
  set_environment(v189, 1, v191);
  function_of(v187)(v189, &v192);
    v161 = v192;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v195);
  closure_of(v195, &v196);
  // preparing environment with 2 slots for call
  create_environment(v196, 2, &v197);
  // looking up the value for caar
  get_environment(env, 3, 33, &v198);
  closure_of(v198, &v199);
  // preparing environment with 1 slots for call
  create_environment(v199, 1, &v200);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v201);
  set_environment(v200, 0, v201);
  function_of(v198)(v200, &v202);
  set_environment(v197, 0, v202);
  create_symbol_value("symbol-statement", &v203);
  set_environment(v197, 1, v203);
  function_of(v195)(v197, &v204);
  if (is_true(v204)) {
    // looking up the value for equal?
  get_environment(env, 3, 11, &v206);
  closure_of(v206, &v207);
  // preparing environment with 2 slots for call
  create_environment(v207, 2, &v208);
  // looking up the value for cdar
  get_environment(env, 3, 34, &v209);
  closure_of(v209, &v210);
  // preparing environment with 1 slots for call
  create_environment(v210, 1, &v211);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v212);
  set_environment(v211, 0, v212);
  function_of(v209)(v211, &v213);
  set_environment(v208, 0, v213);
  create_string_value("cond", &v214);
  set_environment(v208, 1, v214);
  function_of(v206)(v208, &v215);
  if (is_true(v215)) {
    create_boolean_value(true, &v216);
    v205 = v216;
  } else {
    create_boolean_value(false, &v217);
    v205 = v217;
  }
    v194 = v205;
  } else {
    create_boolean_value(false, &v218);
    v194 = v218;
  }
  if (is_true(v194)) {
  // looking up the value for generate-cond-statement
  get_environment(env, 2, 31, &v219);
  closure_of(v219, &v220);
  // preparing environment with 2 slots for call
  create_environment(v220, 2, &v221);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v222);
  set_environment(v221, 0, v222);
  // looking up the value for context
  get_environment(env, 1, 1, &v223);
  set_environment(v221, 1, v223);
  function_of(v219)(v221, &v224);
    v193 = v224;
  } else {
  // looking up the value for generate-application
  get_environment(env, 2, 33, &v225);
  closure_of(v225, &v226);
  // preparing environment with 2 slots for call
  create_environment(v226, 2, &v227);
  // looking up the value for list-statement-list
  get_environment(env, 0, 0, &v228);
  set_environment(v227, 0, v228);
  // looking up the value for context
  get_environment(env, 1, 1, &v229);
  set_environment(v227, 1, v229);
  function_of(v225)(v227, &v230);
    v193 = v230;
  }
    v161 = v193;
  }
    v129 = v161;
  }
    v97 = v129;
  }
    v65 = v97;
  }
    v33 = v65;
  }
    v1 = v33;
  }
  *pReturn = v1;
  pop_stack_slot(230);
  collect(false);
}
// The symbol table for this function is:
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f90(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f122, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 3, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement-list
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f91(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f123, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 3, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for arguments-list-statement
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f92(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  // looking up the value for null?
  get_environment(env, 3, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for quoted-list-statement
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for list
  get_environment(env, 3, 8, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  // looking up the value for string-append
  get_environment(env, 3, 25, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  // looking up the value for format
  get_environment(env, 3, 26, &v13);
  closure_of(v13, &v14);
  // preparing environment with 2 slots for call
  create_environment(v14, 2, &v15);
  create_string_value("  create_nil_value(&v~a);\n", &v16);
  set_environment(v15, 0, v16);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v17);
  set_environment(v15, 1, v17);
  function_of(v13)(v15, &v18);
  set_environment(v12, 0, v18);
  // looking up the value for optional-collect
  get_environment(env, 2, 19, &v19);
  closure_of(v19, &v20);
  // preparing environment with 0 slots for call
  create_environment(v20, 0, &v21);
  function_of(v19)(v21, &v22);
  set_environment(v12, 1, v22);
  function_of(v10)(v12, &v23);
  set_environment(v9, 0, v23);
  // looking up the value for variable-id
  get_environment(env, 0, 1, &v24);
  set_environment(v9, 1, v24);
  // looking up the value for context
  get_environment(env, 0, 2, &v25);
  set_environment(v9, 2, v25);
  function_of(v7)(v9, &v26);
    v1 = v26;
  } else {
    create_closure(env, f124, &v27);
  closure_of(v27, &v28);
  // preparing environment with 1 slots for call
  create_environment(v28, 1, &v29);
  // looking up the value for generate-statement-quoted
  get_environment(env, 2, 36, &v30);
  closure_of(v30, &v31);
  // preparing environment with 2 slots for call
  create_environment(v31, 2, &v32);
  // looking up the value for car
  get_environment(env, 3, 14, &v33);
  closure_of(v33, &v34);
  // preparing environment with 1 slots for call
  create_environment(v34, 1, &v35);
  // looking up the value for quoted-list-statement
  get_environment(env, 0, 0, &v36);
  set_environment(v35, 0, v36);
  function_of(v33)(v35, &v37);
  set_environment(v32, 0, v37);
  // looking up the value for context
  get_environment(env, 0, 2, &v38);
  set_environment(v32, 1, v38);
  function_of(v30)(v32, &v39);
  set_environment(v29, 0, v39);
  function_of(v27)(v29, &v40);
    v1 = v40;
  }
  *pReturn = v1;
  pop_stack_slot(40);
  collect(false);
}
// The symbol table for this function is:
// (variable-id)
// (quoted-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f93(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f125, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 2, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f94(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f126, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for map
  get_environment(env, 2, 0, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for cadr
  get_environment(env, 3, 27, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for bindings
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f95(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f127, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cddr
  get_environment(env, 3, 29, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement-list
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (statement-type)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f96(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  ekans_value* v66 = NULL;
  push_stack_slot(&v66);
  ekans_value* v67 = NULL;
  push_stack_slot(&v67);
  ekans_value* v68 = NULL;
  push_stack_slot(&v68);
  ekans_value* v69 = NULL;
  push_stack_slot(&v69);
  ekans_value* v70 = NULL;
  push_stack_slot(&v70);
  ekans_value* v71 = NULL;
  push_stack_slot(&v71);
  ekans_value* v72 = NULL;
  push_stack_slot(&v72);
  ekans_value* v73 = NULL;
  push_stack_slot(&v73);
  ekans_value* v74 = NULL;
  push_stack_slot(&v74);
  ekans_value* v75 = NULL;
  push_stack_slot(&v75);
  ekans_value* v76 = NULL;
  push_stack_slot(&v76);
  ekans_value* v77 = NULL;
  push_stack_slot(&v77);
  ekans_value* v78 = NULL;
  push_stack_slot(&v78);
  ekans_value* v79 = NULL;
  push_stack_slot(&v79);
  ekans_value* v80 = NULL;
  push_stack_slot(&v80);
  ekans_value* v81 = NULL;
  push_stack_slot(&v81);
  ekans_value* v82 = NULL;
  push_stack_slot(&v82);
  ekans_value* v83 = NULL;
  push_stack_slot(&v83);
  ekans_value* v84 = NULL;
  push_stack_slot(&v84);
  ekans_value* v85 = NULL;
  push_stack_slot(&v85);
  ekans_value* v86 = NULL;
  push_stack_slot(&v86);
  ekans_value* v87 = NULL;
  push_stack_slot(&v87);
  ekans_value* v88 = NULL;
  push_stack_slot(&v88);
  ekans_value* v89 = NULL;
  push_stack_slot(&v89);
  ekans_value* v90 = NULL;
  push_stack_slot(&v90);
  ekans_value* v91 = NULL;
  push_stack_slot(&v91);
  ekans_value* v92 = NULL;
  push_stack_slot(&v92);
  ekans_value* v93 = NULL;
  push_stack_slot(&v93);
  ekans_value* v94 = NULL;
  push_stack_slot(&v94);
  ekans_value* v95 = NULL;
  push_stack_slot(&v95);
  ekans_value* v96 = NULL;
  push_stack_slot(&v96);
  ekans_value* v97 = NULL;
  push_stack_slot(&v97);
  ekans_value* v98 = NULL;
  push_stack_slot(&v98);
  ekans_value* v99 = NULL;
  push_stack_slot(&v99);
  ekans_value* v100 = NULL;
  push_stack_slot(&v100);
  ekans_value* v101 = NULL;
  push_stack_slot(&v101);
  ekans_value* v102 = NULL;
  push_stack_slot(&v102);
  ekans_value* v103 = NULL;
  push_stack_slot(&v103);
  ekans_value* v104 = NULL;
  push_stack_slot(&v104);
  ekans_value* v105 = NULL;
  push_stack_slot(&v105);
  ekans_value* v106 = NULL;
  push_stack_slot(&v106);
  ekans_value* v107 = NULL;
  push_stack_slot(&v107);
  ekans_value* v108 = NULL;
  push_stack_slot(&v108);
  ekans_value* v109 = NULL;
  push_stack_slot(&v109);
  ekans_value* v110 = NULL;
  push_stack_slot(&v110);
  ekans_value* v111 = NULL;
  push_stack_slot(&v111);
  ekans_value* v112 = NULL;
  push_stack_slot(&v112);
  ekans_value* v113 = NULL;
  push_stack_slot(&v113);
  ekans_value* v114 = NULL;
  push_stack_slot(&v114);
  // looking up the value for eq?
  get_environment(env, 3, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("number-statement", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
  // looking up the value for generate-number-statement
  get_environment(env, 2, 23, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for statement
  get_environment(env, 1, 0, &v11);
  set_environment(v10, 0, v11);
  // looking up the value for context
  get_environment(env, 1, 1, &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
    v1 = v13;
  } else {
  // looking up the value for eq?
  get_environment(env, 3, 10, &v15);
  closure_of(v15, &v16);
  // preparing environment with 2 slots for call
  create_environment(v16, 2, &v17);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v18);
  set_environment(v17, 0, v18);
  create_symbol_value("bool-statement", &v19);
  set_environment(v17, 1, v19);
  function_of(v15)(v17, &v20);
  if (is_true(v20)) {
  // looking up the value for generate-bool-statement
  get_environment(env, 2, 24, &v21);
  closure_of(v21, &v22);
  // preparing environment with 2 slots for call
  create_environment(v22, 2, &v23);
  // looking up the value for statement
  get_environment(env, 1, 0, &v24);
  set_environment(v23, 0, v24);
  // looking up the value for context
  get_environment(env, 1, 1, &v25);
  set_environment(v23, 1, v25);
  function_of(v21)(v23, &v26);
    v14 = v26;
  } else {
  // looking up the value for eq?
  get_environment(env, 3, 10, &v28);
  closure_of(v28, &v29);
  // preparing environment with 2 slots for call
  create_environment(v29, 2, &v30);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v31);
  set_environment(v30, 0, v31);
  create_symbol_value("char-statement", &v32);
  set_environment(v30, 1, v32);
  function_of(v28)(v30, &v33);
  if (is_true(v33)) {
  // looking up the value for generate-char-statement
  get_environment(env, 2, 25, &v34);
  closure_of(v34, &v35);
  // preparing environment with 2 slots for call
  create_environment(v35, 2, &v36);
  // looking up the value for statement
  get_environment(env, 1, 0, &v37);
  set_environment(v36, 0, v37);
  // looking up the value for context
  get_environment(env, 1, 1, &v38);
  set_environment(v36, 1, v38);
  function_of(v34)(v36, &v39);
    v27 = v39;
  } else {
  // looking up the value for eq?
  get_environment(env, 3, 10, &v41);
  closure_of(v41, &v42);
  // preparing environment with 2 slots for call
  create_environment(v42, 2, &v43);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v44);
  set_environment(v43, 0, v44);
  create_symbol_value("string-statement", &v45);
  set_environment(v43, 1, v45);
  function_of(v41)(v43, &v46);
  if (is_true(v46)) {
  // looking up the value for generate-string-statement
  get_environment(env, 2, 26, &v47);
  closure_of(v47, &v48);
  // preparing environment with 2 slots for call
  create_environment(v48, 2, &v49);
  // looking up the value for statement
  get_environment(env, 1, 0, &v50);
  set_environment(v49, 0, v50);
  // looking up the value for context
  get_environment(env, 1, 1, &v51);
  set_environment(v49, 1, v51);
  function_of(v47)(v49, &v52);
    v40 = v52;
  } else {
  // looking up the value for eq?
  get_environment(env, 3, 10, &v54);
  closure_of(v54, &v55);
  // preparing environment with 2 slots for call
  create_environment(v55, 2, &v56);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v57);
  set_environment(v56, 0, v57);
  create_symbol_value("symbol-statement", &v58);
  set_environment(v56, 1, v58);
  function_of(v54)(v56, &v59);
  if (is_true(v59)) {
  // looking up the value for generate-symbol-statement
  get_environment(env, 2, 27, &v60);
  closure_of(v60, &v61);
  // preparing environment with 2 slots for call
  create_environment(v61, 2, &v62);
  // looking up the value for statement
  get_environment(env, 1, 0, &v63);
  set_environment(v62, 0, v63);
  // looking up the value for context
  get_environment(env, 1, 1, &v64);
  set_environment(v62, 1, v64);
  function_of(v60)(v62, &v65);
    v53 = v65;
  } else {
  // looking up the value for eq?
  get_environment(env, 3, 10, &v67);
  closure_of(v67, &v68);
  // preparing environment with 2 slots for call
  create_environment(v68, 2, &v69);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v70);
  set_environment(v69, 0, v70);
  create_symbol_value("list-statement", &v71);
  set_environment(v69, 1, v71);
  function_of(v67)(v69, &v72);
  if (is_true(v72)) {
  // looking up the value for generate-list-statement
  get_environment(env, 2, 32, &v73);
  closure_of(v73, &v74);
  // preparing environment with 2 slots for call
  create_environment(v74, 2, &v75);
  // looking up the value for statement
  get_environment(env, 1, 0, &v76);
  set_environment(v75, 0, v76);
  // looking up the value for context
  get_environment(env, 1, 1, &v77);
  set_environment(v75, 1, v77);
  function_of(v73)(v75, &v78);
    v66 = v78;
  } else {
  // looking up the value for eq?
  get_environment(env, 3, 10, &v80);
  closure_of(v80, &v81);
  // preparing environment with 2 slots for call
  create_environment(v81, 2, &v82);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v83);
  set_environment(v82, 0, v83);
  create_symbol_value("quote-statement", &v84);
  set_environment(v82, 1, v84);
  function_of(v80)(v82, &v85);
  if (is_true(v85)) {
  // looking up the value for generate-quote-statement
  get_environment(env, 2, 39, &v86);
  closure_of(v86, &v87);
  // preparing environment with 2 slots for call
  create_environment(v87, 2, &v88);
  // looking up the value for statement
  get_environment(env, 1, 0, &v89);
  set_environment(v88, 0, v89);
  // looking up the value for context
  get_environment(env, 1, 1, &v90);
  set_environment(v88, 1, v90);
  function_of(v86)(v88, &v91);
    v79 = v91;
  } else {
  // looking up the value for eq?
  get_environment(env, 3, 10, &v93);
  closure_of(v93, &v94);
  // preparing environment with 2 slots for call
  create_environment(v94, 2, &v95);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v96);
  set_environment(v95, 0, v96);
  create_symbol_value("set-environment", &v97);
  set_environment(v95, 1, v97);
  function_of(v93)(v95, &v98);
  if (is_true(v98)) {
  // looking up the value for generate-set-environment-statement
  get_environment(env, 2, 41, &v99);
  closure_of(v99, &v100);
  // preparing environment with 2 slots for call
  create_environment(v100, 2, &v101);
  // looking up the value for statement
  get_environment(env, 1, 0, &v102);
  set_environment(v101, 0, v102);
  // looking up the value for context
  get_environment(env, 1, 1, &v103);
  set_environment(v101, 1, v103);
  function_of(v99)(v101, &v104);
    v92 = v104;
  } else {
  // looking up the value for error
  get_environment(env, 3, 22, &v105);
  closure_of(v105, &v106);
  // preparing environment with 1 slots for call
  create_environment(v106, 1, &v107);
  // looking up the value for format
  get_environment(env, 3, 26, &v108);
  closure_of(v108, &v109);
  // preparing environment with 2 slots for call
  create_environment(v109, 2, &v110);
  create_string_value("[log] Error: Unknown statement type ~a", &v111);
  set_environment(v110, 0, v111);
  // looking up the value for statement-type
  get_environment(env, 0, 0, &v112);
  set_environment(v110, 1, v112);
  function_of(v108)(v110, &v113);
  set_environment(v107, 0, v113);
  function_of(v105)(v107, &v114);
    v92 = v114;
  }
    v79 = v92;
  }
    v66 = v79;
  }
    v53 = v66;
  }
    v40 = v53;
  }
    v27 = v40;
  }
    v14 = v27;
  }
    v1 = v14;
  }
  *pReturn = v1;
  pop_stack_slot(114);
  collect(false);
}
// The symbol table for this function is:
// (expression)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f97(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f128, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 3, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statement
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f98(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  // looking up the value for null?
  get_environment(env, 3, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for car
  get_environment(env, 3, 14, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for defines
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  function_of(v2)(v4, &v10);
  if (is_true(v10)) {
    create_closure(env, f129, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for generate-statement
  get_environment(env, 2, 40, &v14);
  closure_of(v14, &v15);
  // preparing environment with 2 slots for call
  create_environment(v15, 2, &v16);
  // looking up the value for car
  get_environment(env, 3, 14, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for statements
  get_environment(env, 1, 0, &v20);
  set_environment(v19, 0, v20);
  function_of(v17)(v19, &v21);
  set_environment(v16, 0, v21);
  // looking up the value for context
  get_environment(env, 1, 1, &v22);
  set_environment(v16, 1, v22);
  function_of(v14)(v16, &v23);
  set_environment(v13, 0, v23);
  function_of(v11)(v13, &v24);
    v1 = v24;
  } else {
    create_closure(env, f130, &v25);
  closure_of(v25, &v26);
  // preparing environment with 1 slots for call
  create_environment(v26, 1, &v27);
  // looking up the value for car
  get_environment(env, 3, 14, &v28);
  closure_of(v28, &v29);
  // preparing environment with 1 slots for call
  create_environment(v29, 1, &v30);
  // looking up the value for defines
  get_environment(env, 0, 0, &v31);
  set_environment(v30, 0, v31);
  function_of(v28)(v30, &v32);
  set_environment(v27, 0, v32);
  function_of(v25)(v27, &v33);
    v1 = v33;
  }
  *pReturn = v1;
  pop_stack_slot(33);
  collect(false);
}
// The symbol table for this function is:
// (argument-result)
// (arguments prefix index environment-id context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f99(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f131, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 3, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for argument-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f100(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f132, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 3, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for queue
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (original-context)
// (function-id statements context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f101(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  create_closure(env, f133, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statements
  get_environment(env, 2, 43, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for statements
  get_environment(env, 1, 1, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 1, 2, &v8);
  set_environment(v6, 1, v8);
  create_nil_value(&v10);
  set_environment(v6, 2, v10);
  function_of(v4)(v6, &v11);
  set_environment(v3, 0, v11);
  function_of(v1)(v3, &v12);
  *pReturn = v12;
  pop_stack_slot(12);
  collect(false);
}
// The symbol table for this function is:
// (third)
// (statement)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f102(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  // looking up the value for equal?
  get_environment(env, 3, 11, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for car
  get_environment(env, 3, 14, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for third
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  create_symbol_value("symbol-statement", &v10);
  set_environment(v4, 1, v10);
  function_of(v2)(v4, &v11);
  if (is_true(v11)) {
    // looking up the value for cdr
  get_environment(env, 3, 15, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for third
  get_environment(env, 0, 0, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
    v1 = v16;
  } else {
    // looking up the value for cdadr
  get_environment(env, 3, 31, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for third
  get_environment(env, 0, 0, &v20);
  set_environment(v19, 0, v20);
  function_of(v17)(v19, &v21);
    v1 = v21;
  }
  *pReturn = v1;
  pop_stack_slot(21);
  collect(false);
}
// The symbol table for this function is:
// (third tail)
// (statement)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f103(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  // looking up the value for equal?
  get_environment(env, 3, 11, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for car
  get_environment(env, 3, 14, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for third
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  create_symbol_value("symbol-statement", &v10);
  set_environment(v4, 1, v10);
  function_of(v2)(v4, &v11);
  if (is_true(v11)) {
    // looking up the value for car
  get_environment(env, 3, 14, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for tail
  get_environment(env, 0, 1, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
    v1 = v16;
  } else {
    // looking up the value for append
  get_environment(env, 2, 4, &v17);
  closure_of(v17, &v18);
  // preparing environment with 2 slots for call
  create_environment(v18, 2, &v19);
  // looking up the value for list
  get_environment(env, 3, 8, &v20);
  closure_of(v20, &v21);
  // preparing environment with 3 slots for call
  create_environment(v21, 3, &v22);
  create_symbol_value("list-statement", &v23);
  set_environment(v22, 0, v23);
  // looking up the value for cons
  get_environment(env, 3, 7, &v24);
  closure_of(v24, &v25);
  // preparing environment with 2 slots for call
  create_environment(v25, 2, &v26);
  create_symbol_value("symbol-statement", &v27);
  set_environment(v26, 0, v27);
  create_string_value("lambda", &v28);
  set_environment(v26, 1, v28);
  function_of(v24)(v26, &v29);
  set_environment(v22, 1, v29);
  // looking up the value for cons
  get_environment(env, 3, 7, &v30);
  closure_of(v30, &v31);
  // preparing environment with 2 slots for call
  create_environment(v31, 2, &v32);
  create_symbol_value("list_statement", &v33);
  set_environment(v32, 0, v33);
  // looking up the value for cddr
  get_environment(env, 3, 29, &v34);
  closure_of(v34, &v35);
  // preparing environment with 1 slots for call
  create_environment(v35, 1, &v36);
  // looking up the value for third
  get_environment(env, 0, 0, &v37);
  set_environment(v36, 0, v37);
  function_of(v34)(v36, &v38);
  set_environment(v32, 1, v38);
  function_of(v30)(v32, &v39);
  set_environment(v22, 2, v39);
  function_of(v20)(v22, &v40);
  set_environment(v19, 0, v40);
  // looking up the value for tail
  get_environment(env, 0, 1, &v41);
  set_environment(v19, 1, v41);
  function_of(v17)(v19, &v42);
    v1 = v42;
  }
  *pReturn = v1;
  pop_stack_slot(42);
  collect(false);
}
// The symbol table for this function is:
// (defines)
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f104(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f134, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for map
  get_environment(env, 2, 0, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for define-name
  get_environment(env, 2, 51, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for defines
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (initial-context)
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f105(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f135, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-all-functions
  get_environment(env, 2, 46, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for initial-context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (decision)
// (input condition)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f106(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  ekans_value* v66 = NULL;
  push_stack_slot(&v66);
  ekans_value* v67 = NULL;
  push_stack_slot(&v67);
  ekans_value* v68 = NULL;
  push_stack_slot(&v68);
  // looking up the value for equal?
  get_environment(env, 3, 11, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for decision
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("keep-going", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
  create_closure(env, f136, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for take-while
  get_environment(env, 2, 69, &v11);
  closure_of(v11, &v12);
  // preparing environment with 2 slots for call
  create_environment(v12, 2, &v13);
  // looking up the value for cdr
  get_environment(env, 3, 15, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for input
  get_environment(env, 1, 0, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v13, 0, v18);
  // looking up the value for condition
  get_environment(env, 1, 1, &v19);
  set_environment(v13, 1, v19);
  function_of(v11)(v13, &v20);
  set_environment(v10, 0, v20);
  function_of(v8)(v10, &v21);
    v1 = v21;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v23);
  closure_of(v23, &v24);
  // preparing environment with 2 slots for call
  create_environment(v24, 2, &v25);
  // looking up the value for decision
  get_environment(env, 0, 0, &v26);
  set_environment(v25, 0, v26);
  create_symbol_value("drop-and-stop", &v27);
  set_environment(v25, 1, v27);
  function_of(v23)(v25, &v28);
  if (is_true(v28)) {
  // looking up the value for cons
  get_environment(env, 3, 7, &v29);
  closure_of(v29, &v30);
  // preparing environment with 2 slots for call
  create_environment(v30, 2, &v31);
  create_nil_value(&v33);
  set_environment(v31, 0, v33);
  // looking up the value for input
  get_environment(env, 1, 0, &v34);
  set_environment(v31, 1, v34);
  function_of(v29)(v31, &v35);
    v22 = v35;
  } else {
  // looking up the value for equal?
  get_environment(env, 3, 11, &v37);
  closure_of(v37, &v38);
  // preparing environment with 2 slots for call
  create_environment(v38, 2, &v39);
  // looking up the value for decision
  get_environment(env, 0, 0, &v40);
  set_environment(v39, 0, v40);
  create_symbol_value("take-and-stop", &v41);
  set_environment(v39, 1, v41);
  function_of(v37)(v39, &v42);
  if (is_true(v42)) {
  // looking up the value for cons
  get_environment(env, 3, 7, &v43);
  closure_of(v43, &v44);
  // preparing environment with 2 slots for call
  create_environment(v44, 2, &v45);
  // looking up the value for cons
  get_environment(env, 3, 7, &v46);
  closure_of(v46, &v47);
  // preparing environment with 2 slots for call
  create_environment(v47, 2, &v48);
  // looking up the value for car
  get_environment(env, 3, 14, &v49);
  closure_of(v49, &v50);
  // preparing environment with 1 slots for call
  create_environment(v50, 1, &v51);
  // looking up the value for input
  get_environment(env, 1, 0, &v52);
  set_environment(v51, 0, v52);
  function_of(v49)(v51, &v53);
  set_environment(v48, 0, v53);
  create_nil_value(&v55);
  set_environment(v48, 1, v55);
  function_of(v46)(v48, &v56);
  set_environment(v45, 0, v56);
  // looking up the value for cdr
  get_environment(env, 3, 15, &v57);
  closure_of(v57, &v58);
  // preparing environment with 1 slots for call
  create_environment(v58, 1, &v59);
  // looking up the value for input
  get_environment(env, 1, 0, &v60);
  set_environment(v59, 0, v60);
  function_of(v57)(v59, &v61);
  set_environment(v45, 1, v61);
  function_of(v43)(v45, &v62);
    v36 = v62;
  } else {
  // looking up the value for error
  get_environment(env, 3, 22, &v63);
  closure_of(v63, &v64);
  // preparing environment with 2 slots for call
  create_environment(v64, 2, &v65);
  create_string_value("Unknown decision", &v66);
  set_environment(v65, 0, v66);
  // looking up the value for decision
  get_environment(env, 0, 0, &v67);
  set_environment(v65, 1, v67);
  function_of(v63)(v65, &v68);
    v36 = v68;
  }
    v22 = v36;
  }
    v1 = v22;
  }
  *pReturn = v1;
  pop_stack_slot(68);
  collect(false);
}
// The symbol table for this function is:
// (digit)
// (lst acc)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f107(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  // looking up the value for digits-to-number
  get_environment(env, 2, 73, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for cdr
  get_environment(env, 3, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for lst
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for +
  get_environment(env, 3, 0, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for *
  get_environment(env, 3, 2, &v12);
  closure_of(v12, &v13);
  // preparing environment with 2 slots for call
  create_environment(v13, 2, &v14);
  // looking up the value for acc
  get_environment(env, 1, 1, &v15);
  set_environment(v14, 0, v15);
  create_number_value(10, &v16);
  set_environment(v14, 1, v16);
  function_of(v12)(v14, &v17);
  set_environment(v11, 0, v17);
  // looking up the value for -
  get_environment(env, 3, 1, &v18);
  closure_of(v18, &v19);
  // preparing environment with 2 slots for call
  create_environment(v19, 2, &v20);
  // looking up the value for digit
  get_environment(env, 0, 0, &v21);
  set_environment(v20, 0, v21);
  // looking up the value for char->integer
  get_environment(env, 3, 16, &v22);
  closure_of(v22, &v23);
  // preparing environment with 1 slots for call
  create_environment(v23, 1, &v24);
  create_char_value('0', &v25);
  set_environment(v24, 0, v25);
  function_of(v22)(v24, &v26);
  set_environment(v20, 1, v26);
  function_of(v18)(v20, &v27);
  set_environment(v11, 1, v27);
  function_of(v9)(v11, &v28);
  set_environment(v3, 1, v28);
  function_of(v1)(v3, &v29);
  *pReturn = v29;
  pop_stack_slot(29);
  collect(false);
}
// The symbol table for this function is:
// (keyword-pair)
// (input keywords)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f108(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f137, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 3, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for keyword-pair
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (lexer-keywords-result)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f109(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  // looking up the value for not
  get_environment(env, 3, 4, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for null?
  get_environment(env, 3, 12, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for lexer-keywords-result
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  function_of(v2)(v4, &v10);
  if (is_true(v10)) {
    // looking up the value for lexer-keywords-result
  get_environment(env, 0, 0, &v11);
    v1 = v11;
  } else {
    create_closure(env, f138, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for car
  get_environment(env, 3, 14, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for input
  get_environment(env, 1, 0, &v18);
  set_environment(v17, 0, v18);
  function_of(v15)(v17, &v19);
  set_environment(v14, 0, v19);
  function_of(v12)(v14, &v20);
    v1 = v20;
  }
  *pReturn = v1;
  pop_stack_slot(20);
  collect(false);
}
// The symbol table for this function is:
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f110(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f139, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 3, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f111(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f140, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 3, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f112(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f141, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 3, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f113(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f142, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 3, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f114(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f143, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 3, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (head rest)
// (l target current index)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f115(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  // looking up the value for equal?
  get_environment(env, 3, 11, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for head
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  // looking up the value for target
  get_environment(env, 1, 1, &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    // looking up the value for last-index-of
  get_environment(env, 2, 87, &v8);
  closure_of(v8, &v9);
  // preparing environment with 4 slots for call
  create_environment(v9, 4, &v10);
  // looking up the value for rest
  get_environment(env, 0, 1, &v11);
  set_environment(v10, 0, v11);
  // looking up the value for target
  get_environment(env, 1, 1, &v12);
  set_environment(v10, 1, v12);
  // looking up the value for list
  get_environment(env, 3, 8, &v13);
  closure_of(v13, &v14);
  // preparing environment with 1 slots for call
  create_environment(v14, 1, &v15);
  // looking up the value for index
  get_environment(env, 1, 3, &v16);
  set_environment(v15, 0, v16);
  function_of(v13)(v15, &v17);
  set_environment(v10, 2, v17);
  // looking up the value for +
  get_environment(env, 3, 0, &v18);
  closure_of(v18, &v19);
  // preparing environment with 2 slots for call
  create_environment(v19, 2, &v20);
  // looking up the value for index
  get_environment(env, 1, 3, &v21);
  set_environment(v20, 0, v21);
  create_number_value(1, &v22);
  set_environment(v20, 1, v22);
  function_of(v18)(v20, &v23);
  set_environment(v10, 3, v23);
  function_of(v8)(v10, &v24);
    v1 = v24;
  } else {
    // looking up the value for last-index-of
  get_environment(env, 2, 87, &v25);
  closure_of(v25, &v26);
  // preparing environment with 4 slots for call
  create_environment(v26, 4, &v27);
  // looking up the value for rest
  get_environment(env, 0, 1, &v28);
  set_environment(v27, 0, v28);
  // looking up the value for target
  get_environment(env, 1, 1, &v29);
  set_environment(v27, 1, v29);
  // looking up the value for current
  get_environment(env, 1, 2, &v30);
  set_environment(v27, 2, v30);
  // looking up the value for +
  get_environment(env, 3, 0, &v31);
  closure_of(v31, &v32);
  // preparing environment with 2 slots for call
  create_environment(v32, 2, &v33);
  // looking up the value for index
  get_environment(env, 1, 3, &v34);
  set_environment(v33, 0, v34);
  create_number_value(1, &v35);
  set_environment(v33, 1, v35);
  function_of(v31)(v33, &v36);
  set_environment(v27, 3, v36);
  function_of(v25)(v27, &v37);
    v1 = v37;
  }
  *pReturn = v1;
  pop_stack_slot(37);
  collect(false);
}
// The symbol table for this function is:
// (result)
// (symbol table level)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f116(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  // looking up the value for null?
  get_environment(env, 3, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for result
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for lookup
  get_environment(env, 2, 88, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  // looking up the value for symbol
  get_environment(env, 1, 0, &v10);
  set_environment(v9, 0, v10);
  // looking up the value for cdr
  get_environment(env, 3, 15, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for table
  get_environment(env, 1, 1, &v14);
  set_environment(v13, 0, v14);
  function_of(v11)(v13, &v15);
  set_environment(v9, 1, v15);
  // looking up the value for +
  get_environment(env, 3, 0, &v16);
  closure_of(v16, &v17);
  // preparing environment with 2 slots for call
  create_environment(v17, 2, &v18);
  // looking up the value for level
  get_environment(env, 1, 2, &v19);
  set_environment(v18, 0, v19);
  create_number_value(1, &v20);
  set_environment(v18, 1, v20);
  function_of(v16)(v18, &v21);
  set_environment(v9, 2, v21);
  function_of(v7)(v9, &v22);
    v1 = v22;
  } else {
    // looking up the value for cons
  get_environment(env, 3, 7, &v23);
  closure_of(v23, &v24);
  // preparing environment with 2 slots for call
  create_environment(v24, 2, &v25);
  // looking up the value for level
  get_environment(env, 1, 2, &v26);
  set_environment(v25, 0, v26);
  // looking up the value for result
  get_environment(env, 0, 0, &v27);
  set_environment(v25, 1, v27);
  function_of(v23)(v25, &v28);
    v1 = v28;
  }
  *pReturn = v1;
  pop_stack_slot(28);
  collect(false);
}
// The symbol table for this function is:
// (variable-id)
// (symbol-value)
// (symbol-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f117(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f144, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 3, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 2, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f118(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f145, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadddr
  get_environment(env, 4, 36, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for if-statement
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-argument)
// (head arguments)
// (and-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f119(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f146, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for arguments
  get_environment(env, 1, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-argument)
// (head arguments)
// (or-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f120(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f147, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for arguments
  get_environment(env, 1, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f121(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f148, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 3, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 2, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f122(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f149, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statement
  get_environment(env, 3, 40, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for function
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 2, 1, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f123(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f150, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for map
  get_environment(env, 3, 0, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for arguments-list
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f124(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f151, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 4, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-statement-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (variable-id)
// (quoted-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f125(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f152, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 4, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for quoted-statement
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (symbols)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f126(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f153, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for map
  get_environment(env, 3, 0, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for caddr
  get_environment(env, 4, 28, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for bindings
  get_environment(env, 1, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (body)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f127(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  // looking up the value for null?
  get_environment(env, 4, 12, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for bindings
  get_environment(env, 1, 0, &v5);
  set_environment(v4, 0, v5);
  function_of(v2)(v4, &v6);
  if (is_true(v6)) {
    // looking up the value for generate-statements
  get_environment(env, 3, 43, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  // looking up the value for body
  get_environment(env, 0, 0, &v10);
  set_environment(v9, 0, v10);
  // looking up the value for context
  get_environment(env, 2, 1, &v11);
  set_environment(v9, 1, v11);
  create_nil_value(&v13);
  set_environment(v9, 2, v13);
  function_of(v7)(v9, &v14);
    v1 = v14;
  } else {
    create_closure(env, f154, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for car
  get_environment(env, 4, 14, &v18);
  closure_of(v18, &v19);
  // preparing environment with 1 slots for call
  create_environment(v19, 1, &v20);
  // looking up the value for bindings
  get_environment(env, 1, 0, &v21);
  set_environment(v20, 0, v21);
  function_of(v18)(v20, &v22);
  set_environment(v17, 0, v22);
  function_of(v15)(v17, &v23);
    v1 = v23;
  }
  *pReturn = v1;
  pop_stack_slot(23);
  collect(false);
}
// The symbol table for this function is:
// (index)
// (expression)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f128(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f155, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statement
  get_environment(env, 3, 40, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for expression
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 2, 1, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f129(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f156, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 4, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-statement-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f130(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f157, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for defines
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (argument-code)
// (argument-result)
// (arguments prefix index environment-id context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f131(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f158, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for argument-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f132(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f159, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for queue
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (statements-result)
// (original-context)
// (function-id statements context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f133(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f160, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 4, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statements-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (names)
// (defines)
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f134(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f161, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for map
  get_environment(env, 3, 0, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for define-value
  get_environment(env, 3, 52, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for defines
  get_environment(env, 1, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (all-function-result)
// (initial-context)
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f135(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f162, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 4, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for all-function-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (result)
// (decision)
// (input condition)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f136(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f163, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 4, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (keyword)
// (keyword-pair)
// (input keywords)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f137(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f164, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for keyword-pair
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (peek)
// (lexer-keywords-result)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f138(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  ekans_value* v66 = NULL;
  push_stack_slot(&v66);
  ekans_value* v67 = NULL;
  push_stack_slot(&v67);
  ekans_value* v68 = NULL;
  push_stack_slot(&v68);
  ekans_value* v69 = NULL;
  push_stack_slot(&v69);
  ekans_value* v70 = NULL;
  push_stack_slot(&v70);
  ekans_value* v71 = NULL;
  push_stack_slot(&v71);
  ekans_value* v72 = NULL;
  push_stack_slot(&v72);
  ekans_value* v73 = NULL;
  push_stack_slot(&v73);
  ekans_value* v74 = NULL;
  push_stack_slot(&v74);
  ekans_value* v75 = NULL;
  push_stack_slot(&v75);
  ekans_value* v76 = NULL;
  push_stack_slot(&v76);
  ekans_value* v77 = NULL;
  push_stack_slot(&v77);
  ekans_value* v78 = NULL;
  push_stack_slot(&v78);
  ekans_value* v79 = NULL;
  push_stack_slot(&v79);
  ekans_value* v80 = NULL;
  push_stack_slot(&v80);
  ekans_value* v81 = NULL;
  push_stack_slot(&v81);
  ekans_value* v82 = NULL;
  push_stack_slot(&v82);
  ekans_value* v83 = NULL;
  push_stack_slot(&v83);
  ekans_value* v84 = NULL;
  push_stack_slot(&v84);
  ekans_value* v85 = NULL;
  push_stack_slot(&v85);
  ekans_value* v86 = NULL;
  push_stack_slot(&v86);
  ekans_value* v87 = NULL;
  push_stack_slot(&v87);
  ekans_value* v88 = NULL;
  push_stack_slot(&v88);
  ekans_value* v89 = NULL;
  push_stack_slot(&v89);
  ekans_value* v90 = NULL;
  push_stack_slot(&v90);
  ekans_value* v91 = NULL;
  push_stack_slot(&v91);
  ekans_value* v92 = NULL;
  push_stack_slot(&v92);
  ekans_value* v93 = NULL;
  push_stack_slot(&v93);
  ekans_value* v94 = NULL;
  push_stack_slot(&v94);
  ekans_value* v95 = NULL;
  push_stack_slot(&v95);
  ekans_value* v96 = NULL;
  push_stack_slot(&v96);
  ekans_value* v97 = NULL;
  push_stack_slot(&v97);
  ekans_value* v98 = NULL;
  push_stack_slot(&v98);
  ekans_value* v99 = NULL;
  push_stack_slot(&v99);
  ekans_value* v100 = NULL;
  push_stack_slot(&v100);
  ekans_value* v101 = NULL;
  push_stack_slot(&v101);
  ekans_value* v102 = NULL;
  push_stack_slot(&v102);
  ekans_value* v103 = NULL;
  push_stack_slot(&v103);
  ekans_value* v104 = NULL;
  push_stack_slot(&v104);
  ekans_value* v105 = NULL;
  push_stack_slot(&v105);
  ekans_value* v106 = NULL;
  push_stack_slot(&v106);
  ekans_value* v107 = NULL;
  push_stack_slot(&v107);
  ekans_value* v108 = NULL;
  push_stack_slot(&v108);
  ekans_value* v109 = NULL;
  push_stack_slot(&v109);
  ekans_value* v110 = NULL;
  push_stack_slot(&v110);
  ekans_value* v111 = NULL;
  push_stack_slot(&v111);
  ekans_value* v112 = NULL;
  push_stack_slot(&v112);
  ekans_value* v113 = NULL;
  push_stack_slot(&v113);
  ekans_value* v114 = NULL;
  push_stack_slot(&v114);
  ekans_value* v115 = NULL;
  push_stack_slot(&v115);
  ekans_value* v116 = NULL;
  push_stack_slot(&v116);
  ekans_value* v117 = NULL;
  push_stack_slot(&v117);
  ekans_value* v118 = NULL;
  push_stack_slot(&v118);
  ekans_value* v119 = NULL;
  push_stack_slot(&v119);
  ekans_value* v120 = NULL;
  push_stack_slot(&v120);
  ekans_value* v121 = NULL;
  push_stack_slot(&v121);
  ekans_value* v122 = NULL;
  push_stack_slot(&v122);
  ekans_value* v123 = NULL;
  push_stack_slot(&v123);
  ekans_value* v124 = NULL;
  push_stack_slot(&v124);
  ekans_value* v125 = NULL;
  push_stack_slot(&v125);
  ekans_value* v126 = NULL;
  push_stack_slot(&v126);
  ekans_value* v127 = NULL;
  push_stack_slot(&v127);
  ekans_value* v128 = NULL;
  push_stack_slot(&v128);
  ekans_value* v129 = NULL;
  push_stack_slot(&v129);
  ekans_value* v130 = NULL;
  push_stack_slot(&v130);
  ekans_value* v131 = NULL;
  push_stack_slot(&v131);
  ekans_value* v132 = NULL;
  push_stack_slot(&v132);
  ekans_value* v133 = NULL;
  push_stack_slot(&v133);
  ekans_value* v134 = NULL;
  push_stack_slot(&v134);
  ekans_value* v135 = NULL;
  push_stack_slot(&v135);
  ekans_value* v136 = NULL;
  push_stack_slot(&v136);
  ekans_value* v137 = NULL;
  push_stack_slot(&v137);
  ekans_value* v138 = NULL;
  push_stack_slot(&v138);
  ekans_value* v139 = NULL;
  push_stack_slot(&v139);
  ekans_value* v140 = NULL;
  push_stack_slot(&v140);
  ekans_value* v141 = NULL;
  push_stack_slot(&v141);
  ekans_value* v142 = NULL;
  push_stack_slot(&v142);
  ekans_value* v143 = NULL;
  push_stack_slot(&v143);
  ekans_value* v144 = NULL;
  push_stack_slot(&v144);
  ekans_value* v145 = NULL;
  push_stack_slot(&v145);
  ekans_value* v146 = NULL;
  push_stack_slot(&v146);
  ekans_value* v147 = NULL;
  push_stack_slot(&v147);
  ekans_value* v148 = NULL;
  push_stack_slot(&v148);
  ekans_value* v149 = NULL;
  push_stack_slot(&v149);
  ekans_value* v150 = NULL;
  push_stack_slot(&v150);
  ekans_value* v151 = NULL;
  push_stack_slot(&v151);
  ekans_value* v152 = NULL;
  push_stack_slot(&v152);
  ekans_value* v153 = NULL;
  push_stack_slot(&v153);
  ekans_value* v154 = NULL;
  push_stack_slot(&v154);
  ekans_value* v155 = NULL;
  push_stack_slot(&v155);
  ekans_value* v156 = NULL;
  push_stack_slot(&v156);
  ekans_value* v157 = NULL;
  push_stack_slot(&v157);
  ekans_value* v158 = NULL;
  push_stack_slot(&v158);
  ekans_value* v159 = NULL;
  push_stack_slot(&v159);
  ekans_value* v160 = NULL;
  push_stack_slot(&v160);
  ekans_value* v161 = NULL;
  push_stack_slot(&v161);
  ekans_value* v162 = NULL;
  push_stack_slot(&v162);
  ekans_value* v163 = NULL;
  push_stack_slot(&v163);
  ekans_value* v164 = NULL;
  push_stack_slot(&v164);
  ekans_value* v165 = NULL;
  push_stack_slot(&v165);
  ekans_value* v166 = NULL;
  push_stack_slot(&v166);
  ekans_value* v167 = NULL;
  push_stack_slot(&v167);
  ekans_value* v168 = NULL;
  push_stack_slot(&v168);
  ekans_value* v169 = NULL;
  push_stack_slot(&v169);
  ekans_value* v170 = NULL;
  push_stack_slot(&v170);
  ekans_value* v171 = NULL;
  push_stack_slot(&v171);
  ekans_value* v172 = NULL;
  push_stack_slot(&v172);
  ekans_value* v173 = NULL;
  push_stack_slot(&v173);
  ekans_value* v174 = NULL;
  push_stack_slot(&v174);
  ekans_value* v175 = NULL;
  push_stack_slot(&v175);
  ekans_value* v176 = NULL;
  push_stack_slot(&v176);
  ekans_value* v177 = NULL;
  push_stack_slot(&v177);
  ekans_value* v178 = NULL;
  push_stack_slot(&v178);
  ekans_value* v179 = NULL;
  push_stack_slot(&v179);
  ekans_value* v180 = NULL;
  push_stack_slot(&v180);
  ekans_value* v181 = NULL;
  push_stack_slot(&v181);
  ekans_value* v182 = NULL;
  push_stack_slot(&v182);
  ekans_value* v183 = NULL;
  push_stack_slot(&v183);
  ekans_value* v184 = NULL;
  push_stack_slot(&v184);
  ekans_value* v185 = NULL;
  push_stack_slot(&v185);
  ekans_value* v186 = NULL;
  push_stack_slot(&v186);
  ekans_value* v187 = NULL;
  push_stack_slot(&v187);
  ekans_value* v188 = NULL;
  push_stack_slot(&v188);
  ekans_value* v189 = NULL;
  push_stack_slot(&v189);
  ekans_value* v190 = NULL;
  push_stack_slot(&v190);
  ekans_value* v191 = NULL;
  push_stack_slot(&v191);
  ekans_value* v192 = NULL;
  push_stack_slot(&v192);
  ekans_value* v193 = NULL;
  push_stack_slot(&v193);
  ekans_value* v194 = NULL;
  push_stack_slot(&v194);
  ekans_value* v195 = NULL;
  push_stack_slot(&v195);
  ekans_value* v196 = NULL;
  push_stack_slot(&v196);
  ekans_value* v197 = NULL;
  push_stack_slot(&v197);
  ekans_value* v198 = NULL;
  push_stack_slot(&v198);
  ekans_value* v199 = NULL;
  push_stack_slot(&v199);
  ekans_value* v200 = NULL;
  push_stack_slot(&v200);
  ekans_value* v201 = NULL;
  push_stack_slot(&v201);
  ekans_value* v202 = NULL;
  push_stack_slot(&v202);
  ekans_value* v203 = NULL;
  push_stack_slot(&v203);
  ekans_value* v204 = NULL;
  push_stack_slot(&v204);
  ekans_value* v205 = NULL;
  push_stack_slot(&v205);
  ekans_value* v206 = NULL;
  push_stack_slot(&v206);
  ekans_value* v207 = NULL;
  push_stack_slot(&v207);
  ekans_value* v208 = NULL;
  push_stack_slot(&v208);
  ekans_value* v209 = NULL;
  push_stack_slot(&v209);
  ekans_value* v210 = NULL;
  push_stack_slot(&v210);
  ekans_value* v211 = NULL;
  push_stack_slot(&v211);
  ekans_value* v212 = NULL;
  push_stack_slot(&v212);
  ekans_value* v213 = NULL;
  push_stack_slot(&v213);
  ekans_value* v214 = NULL;
  push_stack_slot(&v214);
  ekans_value* v215 = NULL;
  push_stack_slot(&v215);
  ekans_value* v216 = NULL;
  push_stack_slot(&v216);
  ekans_value* v217 = NULL;
  push_stack_slot(&v217);
  ekans_value* v218 = NULL;
  push_stack_slot(&v218);
  ekans_value* v219 = NULL;
  push_stack_slot(&v219);
  ekans_value* v220 = NULL;
  push_stack_slot(&v220);
  ekans_value* v221 = NULL;
  push_stack_slot(&v221);
  ekans_value* v222 = NULL;
  push_stack_slot(&v222);
  ekans_value* v223 = NULL;
  push_stack_slot(&v223);
  ekans_value* v224 = NULL;
  push_stack_slot(&v224);
  ekans_value* v225 = NULL;
  push_stack_slot(&v225);
  ekans_value* v226 = NULL;
  push_stack_slot(&v226);
  ekans_value* v227 = NULL;
  push_stack_slot(&v227);
  ekans_value* v228 = NULL;
  push_stack_slot(&v228);
  ekans_value* v229 = NULL;
  push_stack_slot(&v229);
  ekans_value* v230 = NULL;
  push_stack_slot(&v230);
  ekans_value* v231 = NULL;
  push_stack_slot(&v231);
  ekans_value* v232 = NULL;
  push_stack_slot(&v232);
  ekans_value* v233 = NULL;
  push_stack_slot(&v233);
  ekans_value* v234 = NULL;
  push_stack_slot(&v234);
  ekans_value* v235 = NULL;
  push_stack_slot(&v235);
  ekans_value* v236 = NULL;
  push_stack_slot(&v236);
  ekans_value* v237 = NULL;
  push_stack_slot(&v237);
  ekans_value* v238 = NULL;
  push_stack_slot(&v238);
  ekans_value* v239 = NULL;
  push_stack_slot(&v239);
  ekans_value* v240 = NULL;
  push_stack_slot(&v240);
  ekans_value* v241 = NULL;
  push_stack_slot(&v241);
  ekans_value* v242 = NULL;
  push_stack_slot(&v242);
  ekans_value* v243 = NULL;
  push_stack_slot(&v243);
  ekans_value* v244 = NULL;
  push_stack_slot(&v244);
  ekans_value* v245 = NULL;
  push_stack_slot(&v245);
  ekans_value* v246 = NULL;
  push_stack_slot(&v246);
  ekans_value* v247 = NULL;
  push_stack_slot(&v247);
  ekans_value* v248 = NULL;
  push_stack_slot(&v248);
  ekans_value* v249 = NULL;
  push_stack_slot(&v249);
  ekans_value* v250 = NULL;
  push_stack_slot(&v250);
  ekans_value* v251 = NULL;
  push_stack_slot(&v251);
  ekans_value* v252 = NULL;
  push_stack_slot(&v252);
  ekans_value* v253 = NULL;
  push_stack_slot(&v253);
  ekans_value* v254 = NULL;
  push_stack_slot(&v254);
  ekans_value* v255 = NULL;
  push_stack_slot(&v255);
  ekans_value* v256 = NULL;
  push_stack_slot(&v256);
  ekans_value* v257 = NULL;
  push_stack_slot(&v257);
  ekans_value* v258 = NULL;
  push_stack_slot(&v258);
  ekans_value* v259 = NULL;
  push_stack_slot(&v259);
  ekans_value* v260 = NULL;
  push_stack_slot(&v260);
  ekans_value* v261 = NULL;
  push_stack_slot(&v261);
  ekans_value* v262 = NULL;
  push_stack_slot(&v262);
  ekans_value* v263 = NULL;
  push_stack_slot(&v263);
  ekans_value* v264 = NULL;
  push_stack_slot(&v264);
  ekans_value* v265 = NULL;
  push_stack_slot(&v265);
  ekans_value* v266 = NULL;
  push_stack_slot(&v266);
  ekans_value* v267 = NULL;
  push_stack_slot(&v267);
  ekans_value* v268 = NULL;
  push_stack_slot(&v268);
  ekans_value* v269 = NULL;
  push_stack_slot(&v269);
  ekans_value* v270 = NULL;
  push_stack_slot(&v270);
  ekans_value* v271 = NULL;
  push_stack_slot(&v271);
  ekans_value* v272 = NULL;
  push_stack_slot(&v272);
  ekans_value* v273 = NULL;
  push_stack_slot(&v273);
  ekans_value* v274 = NULL;
  push_stack_slot(&v274);
  ekans_value* v275 = NULL;
  push_stack_slot(&v275);
  ekans_value* v276 = NULL;
  push_stack_slot(&v276);
  ekans_value* v277 = NULL;
  push_stack_slot(&v277);
  ekans_value* v278 = NULL;
  push_stack_slot(&v278);
  ekans_value* v279 = NULL;
  push_stack_slot(&v279);
  ekans_value* v280 = NULL;
  push_stack_slot(&v280);
  ekans_value* v281 = NULL;
  push_stack_slot(&v281);
  ekans_value* v282 = NULL;
  push_stack_slot(&v282);
  ekans_value* v283 = NULL;
  push_stack_slot(&v283);
  ekans_value* v284 = NULL;
  push_stack_slot(&v284);
  ekans_value* v285 = NULL;
  push_stack_slot(&v285);
  // looking up the value for equal?
  get_environment(env, 4, 11, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for peek
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_char_value(';', &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
  // looking up the value for lexer
  get_environment(env, 3, 79, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for skip-comment
  get_environment(env, 3, 75, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for input
  get_environment(env, 2, 0, &v17);
  set_environment(v16, 0, v17);
  function_of(v14)(v16, &v18);
  set_environment(v13, 0, v18);
  function_of(v11)(v13, &v19);
  set_environment(v10, 0, v19);
  function_of(v8)(v10, &v20);
    v1 = v20;
  } else {
  // looking up the value for equal?
  get_environment(env, 4, 11, &v22);
  closure_of(v22, &v23);
  // preparing environment with 2 slots for call
  create_environment(v23, 2, &v24);
  // looking up the value for peek
  get_environment(env, 0, 0, &v25);
  set_environment(v24, 0, v25);
  create_char_value(' ', &v26);
  set_environment(v24, 1, v26);
  function_of(v22)(v24, &v27);
  if (is_true(v27)) {
  // looking up the value for lexer
  get_environment(env, 3, 79, &v28);
  closure_of(v28, &v29);
  // preparing environment with 1 slots for call
  create_environment(v29, 1, &v30);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v31);
  closure_of(v31, &v32);
  // preparing environment with 1 slots for call
  create_environment(v32, 1, &v33);
  // looking up the value for input
  get_environment(env, 2, 0, &v34);
  set_environment(v33, 0, v34);
  function_of(v31)(v33, &v35);
  set_environment(v30, 0, v35);
  function_of(v28)(v30, &v36);
    v21 = v36;
  } else {
  // looking up the value for equal?
  get_environment(env, 4, 11, &v38);
  closure_of(v38, &v39);
  // preparing environment with 2 slots for call
  create_environment(v39, 2, &v40);
  // looking up the value for peek
  get_environment(env, 0, 0, &v41);
  set_environment(v40, 0, v41);
  create_char_value('\n', &v42);
  set_environment(v40, 1, v42);
  function_of(v38)(v40, &v43);
  if (is_true(v43)) {
  // looking up the value for lexer
  get_environment(env, 3, 79, &v44);
  closure_of(v44, &v45);
  // preparing environment with 1 slots for call
  create_environment(v45, 1, &v46);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v47);
  closure_of(v47, &v48);
  // preparing environment with 1 slots for call
  create_environment(v48, 1, &v49);
  // looking up the value for input
  get_environment(env, 2, 0, &v50);
  set_environment(v49, 0, v50);
  function_of(v47)(v49, &v51);
  set_environment(v46, 0, v51);
  function_of(v44)(v46, &v52);
    v37 = v52;
  } else {
  // looking up the value for equal?
  get_environment(env, 4, 11, &v54);
  closure_of(v54, &v55);
  // preparing environment with 2 slots for call
  create_environment(v55, 2, &v56);
  // looking up the value for peek
  get_environment(env, 0, 0, &v57);
  set_environment(v56, 0, v57);
  // looking up the value for lp
  get_environment(env, 3, 9, &v58);
  set_environment(v56, 1, v58);
  function_of(v54)(v56, &v59);
  if (is_true(v59)) {
  // looking up the value for cons
  get_environment(env, 4, 7, &v60);
  closure_of(v60, &v61);
  // preparing environment with 2 slots for call
  create_environment(v61, 2, &v62);
  // looking up the value for cons
  get_environment(env, 4, 7, &v63);
  closure_of(v63, &v64);
  // preparing environment with 2 slots for call
  create_environment(v64, 2, &v65);
  create_symbol_value("lparen", &v66);
  set_environment(v65, 0, v66);
  create_nil_value(&v68);
  set_environment(v65, 1, v68);
  function_of(v63)(v65, &v69);
  set_environment(v62, 0, v69);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v70);
  closure_of(v70, &v71);
  // preparing environment with 1 slots for call
  create_environment(v71, 1, &v72);
  // looking up the value for input
  get_environment(env, 2, 0, &v73);
  set_environment(v72, 0, v73);
  function_of(v70)(v72, &v74);
  set_environment(v62, 1, v74);
  function_of(v60)(v62, &v75);
    v53 = v75;
  } else {
  // looking up the value for equal?
  get_environment(env, 4, 11, &v77);
  closure_of(v77, &v78);
  // preparing environment with 2 slots for call
  create_environment(v78, 2, &v79);
  // looking up the value for peek
  get_environment(env, 0, 0, &v80);
  set_environment(v79, 0, v80);
  // looking up the value for rp
  get_environment(env, 3, 10, &v81);
  set_environment(v79, 1, v81);
  function_of(v77)(v79, &v82);
  if (is_true(v82)) {
  // looking up the value for cons
  get_environment(env, 4, 7, &v83);
  closure_of(v83, &v84);
  // preparing environment with 2 slots for call
  create_environment(v84, 2, &v85);
  // looking up the value for cons
  get_environment(env, 4, 7, &v86);
  closure_of(v86, &v87);
  // preparing environment with 2 slots for call
  create_environment(v87, 2, &v88);
  create_symbol_value("rparen", &v89);
  set_environment(v88, 0, v89);
  create_nil_value(&v91);
  set_environment(v88, 1, v91);
  function_of(v86)(v88, &v92);
  set_environment(v85, 0, v92);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v93);
  closure_of(v93, &v94);
  // preparing environment with 1 slots for call
  create_environment(v94, 1, &v95);
  // looking up the value for input
  get_environment(env, 2, 0, &v96);
  set_environment(v95, 0, v96);
  function_of(v93)(v95, &v97);
  set_environment(v85, 1, v97);
  function_of(v83)(v85, &v98);
    v76 = v98;
  } else {
  // looking up the value for equal?
  get_environment(env, 4, 11, &v100);
  closure_of(v100, &v101);
  // preparing environment with 2 slots for call
  create_environment(v101, 2, &v102);
  // looking up the value for peek
  get_environment(env, 0, 0, &v103);
  set_environment(v102, 0, v103);
  // looking up the value for ls
  get_environment(env, 3, 13, &v104);
  set_environment(v102, 1, v104);
  function_of(v100)(v102, &v105);
  if (is_true(v105)) {
  // looking up the value for cons
  get_environment(env, 4, 7, &v106);
  closure_of(v106, &v107);
  // preparing environment with 2 slots for call
  create_environment(v107, 2, &v108);
  // looking up the value for cons
  get_environment(env, 4, 7, &v109);
  closure_of(v109, &v110);
  // preparing environment with 2 slots for call
  create_environment(v110, 2, &v111);
  create_symbol_value("lparen", &v112);
  set_environment(v111, 0, v112);
  create_nil_value(&v114);
  set_environment(v111, 1, v114);
  function_of(v109)(v111, &v115);
  set_environment(v108, 0, v115);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v116);
  closure_of(v116, &v117);
  // preparing environment with 1 slots for call
  create_environment(v117, 1, &v118);
  // looking up the value for input
  get_environment(env, 2, 0, &v119);
  set_environment(v118, 0, v119);
  function_of(v116)(v118, &v120);
  set_environment(v108, 1, v120);
  function_of(v106)(v108, &v121);
    v99 = v121;
  } else {
  // looking up the value for equal?
  get_environment(env, 4, 11, &v123);
  closure_of(v123, &v124);
  // preparing environment with 2 slots for call
  create_environment(v124, 2, &v125);
  // looking up the value for peek
  get_environment(env, 0, 0, &v126);
  set_environment(v125, 0, v126);
  // looking up the value for rs
  get_environment(env, 3, 14, &v127);
  set_environment(v125, 1, v127);
  function_of(v123)(v125, &v128);
  if (is_true(v128)) {
  // looking up the value for cons
  get_environment(env, 4, 7, &v129);
  closure_of(v129, &v130);
  // preparing environment with 2 slots for call
  create_environment(v130, 2, &v131);
  // looking up the value for cons
  get_environment(env, 4, 7, &v132);
  closure_of(v132, &v133);
  // preparing environment with 2 slots for call
  create_environment(v133, 2, &v134);
  create_symbol_value("rparen", &v135);
  set_environment(v134, 0, v135);
  create_nil_value(&v137);
  set_environment(v134, 1, v137);
  function_of(v132)(v134, &v138);
  set_environment(v131, 0, v138);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v139);
  closure_of(v139, &v140);
  // preparing environment with 1 slots for call
  create_environment(v140, 1, &v141);
  // looking up the value for input
  get_environment(env, 2, 0, &v142);
  set_environment(v141, 0, v142);
  function_of(v139)(v141, &v143);
  set_environment(v131, 1, v143);
  function_of(v129)(v131, &v144);
    v122 = v144;
  } else {
  // looking up the value for equal?
  get_environment(env, 4, 11, &v146);
  closure_of(v146, &v147);
  // preparing environment with 2 slots for call
  create_environment(v147, 2, &v148);
  // looking up the value for peek
  get_environment(env, 0, 0, &v149);
  set_environment(v148, 0, v149);
  create_char_value('\'', &v150);
  set_environment(v148, 1, v150);
  function_of(v146)(v148, &v151);
  if (is_true(v151)) {
  // looking up the value for cons
  get_environment(env, 4, 7, &v152);
  closure_of(v152, &v153);
  // preparing environment with 2 slots for call
  create_environment(v153, 2, &v154);
  // looking up the value for cons
  get_environment(env, 4, 7, &v155);
  closure_of(v155, &v156);
  // preparing environment with 2 slots for call
  create_environment(v156, 2, &v157);
  create_symbol_value("quote", &v158);
  set_environment(v157, 0, v158);
  create_nil_value(&v160);
  set_environment(v157, 1, v160);
  function_of(v155)(v157, &v161);
  set_environment(v154, 0, v161);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v162);
  closure_of(v162, &v163);
  // preparing environment with 1 slots for call
  create_environment(v163, 1, &v164);
  // looking up the value for input
  get_environment(env, 2, 0, &v165);
  set_environment(v164, 0, v165);
  function_of(v162)(v164, &v166);
  set_environment(v154, 1, v166);
  function_of(v152)(v154, &v167);
    v145 = v167;
  } else {
  // looking up the value for pair?
  get_environment(env, 4, 23, &v170);
  closure_of(v170, &v171);
  // preparing environment with 1 slots for call
  create_environment(v171, 1, &v172);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v173);
  closure_of(v173, &v174);
  // preparing environment with 1 slots for call
  create_environment(v174, 1, &v175);
  // looking up the value for input
  get_environment(env, 2, 0, &v176);
  set_environment(v175, 0, v176);
  function_of(v173)(v175, &v177);
  set_environment(v172, 0, v177);
  function_of(v170)(v172, &v178);
  if (is_true(v178)) {
    // looking up the value for equal?
  get_environment(env, 4, 11, &v180);
  closure_of(v180, &v181);
  // preparing environment with 2 slots for call
  create_environment(v181, 2, &v182);
  // looking up the value for peek
  get_environment(env, 0, 0, &v183);
  set_environment(v182, 0, v183);
  create_char_value('#', &v184);
  set_environment(v182, 1, v184);
  function_of(v180)(v182, &v185);
  if (is_true(v185)) {
    // looking up the value for equal?
  get_environment(env, 4, 11, &v187);
  closure_of(v187, &v188);
  // preparing environment with 2 slots for call
  create_environment(v188, 2, &v189);
  // looking up the value for cadr
  get_environment(env, 4, 27, &v190);
  closure_of(v190, &v191);
  // preparing environment with 1 slots for call
  create_environment(v191, 1, &v192);
  // looking up the value for input
  get_environment(env, 2, 0, &v193);
  set_environment(v192, 0, v193);
  function_of(v190)(v192, &v194);
  set_environment(v189, 0, v194);
  create_char_value('\\', &v195);
  set_environment(v189, 1, v195);
  function_of(v187)(v189, &v196);
  if (is_true(v196)) {
    create_boolean_value(true, &v197);
    v186 = v197;
  } else {
    create_boolean_value(false, &v198);
    v186 = v198;
  }
    v179 = v186;
  } else {
    create_boolean_value(false, &v199);
    v179 = v199;
  }
    v169 = v179;
  } else {
    create_boolean_value(false, &v200);
    v169 = v200;
  }
  if (is_true(v169)) {
  // looking up the value for pair?
  get_environment(env, 4, 23, &v202);
  closure_of(v202, &v203);
  // preparing environment with 1 slots for call
  create_environment(v203, 1, &v204);
  // looking up the value for cddr
  get_environment(env, 4, 29, &v205);
  closure_of(v205, &v206);
  // preparing environment with 1 slots for call
  create_environment(v206, 1, &v207);
  // looking up the value for input
  get_environment(env, 2, 0, &v208);
  set_environment(v207, 0, v208);
  function_of(v205)(v207, &v209);
  set_environment(v204, 0, v209);
  function_of(v202)(v204, &v210);
  if (is_true(v210)) {
  // looking up the value for cons
  get_environment(env, 4, 7, &v211);
  closure_of(v211, &v212);
  // preparing environment with 2 slots for call
  create_environment(v212, 2, &v213);
  // looking up the value for cons
  get_environment(env, 4, 7, &v214);
  closure_of(v214, &v215);
  // preparing environment with 2 slots for call
  create_environment(v215, 2, &v216);
  create_symbol_value("character", &v217);
  set_environment(v216, 0, v217);
  // looking up the value for caddr
  get_environment(env, 4, 28, &v218);
  closure_of(v218, &v219);
  // preparing environment with 1 slots for call
  create_environment(v219, 1, &v220);
  // looking up the value for input
  get_environment(env, 2, 0, &v221);
  set_environment(v220, 0, v221);
  function_of(v218)(v220, &v222);
  set_environment(v216, 1, v222);
  function_of(v214)(v216, &v223);
  set_environment(v213, 0, v223);
  // looking up the value for cdddr
  get_environment(env, 4, 35, &v224);
  closure_of(v224, &v225);
  // preparing environment with 1 slots for call
  create_environment(v225, 1, &v226);
  // looking up the value for input
  get_environment(env, 2, 0, &v227);
  set_environment(v226, 0, v227);
  function_of(v224)(v226, &v228);
  set_environment(v213, 1, v228);
  function_of(v211)(v213, &v229);
    v201 = v229;
  } else {
  // looking up the value for cons
  get_environment(env, 4, 7, &v230);
  closure_of(v230, &v231);
  // preparing environment with 2 slots for call
  create_environment(v231, 2, &v232);
  // looking up the value for cons
  get_environment(env, 4, 7, &v233);
  closure_of(v233, &v234);
  // preparing environment with 2 slots for call
  create_environment(v234, 2, &v235);
  create_symbol_value("unknown", &v236);
  set_environment(v235, 0, v236);
  create_nil_value(&v238);
  set_environment(v235, 1, v238);
  function_of(v233)(v235, &v239);
  set_environment(v232, 0, v239);
  create_nil_value(&v241);
  set_environment(v232, 1, v241);
  function_of(v230)(v232, &v242);
    v201 = v242;
  }
    v168 = v201;
  } else {
  // looking up the value for digit?
  get_environment(env, 3, 68, &v244);
  closure_of(v244, &v245);
  // preparing environment with 1 slots for call
  create_environment(v245, 1, &v246);
  // looking up the value for peek
  get_environment(env, 0, 0, &v247);
  set_environment(v246, 0, v247);
  function_of(v244)(v246, &v248);
  if (is_true(v248)) {
  create_closure(env, f165, &v249);
  closure_of(v249, &v250);
  // preparing environment with 1 slots for call
  create_environment(v250, 1, &v251);
  // looking up the value for take-while
  get_environment(env, 3, 69, &v252);
  closure_of(v252, &v253);
  // preparing environment with 2 slots for call
  create_environment(v253, 2, &v254);
  // looking up the value for input
  get_environment(env, 2, 0, &v255);
  set_environment(v254, 0, v255);
  // looking up the value for digit-decision
  get_environment(env, 3, 70, &v256);
  set_environment(v254, 1, v256);
  function_of(v252)(v254, &v257);
  set_environment(v251, 0, v257);
  function_of(v249)(v251, &v258);
    v243 = v258;
  } else {
  // looking up the value for equal?
  get_environment(env, 4, 11, &v260);
  closure_of(v260, &v261);
  // preparing environment with 2 slots for call
  create_environment(v261, 2, &v262);
  // looking up the value for peek
  get_environment(env, 0, 0, &v263);
  set_environment(v262, 0, v263);
  create_char_value('"', &v264);
  set_environment(v262, 1, v264);
  function_of(v260)(v262, &v265);
  if (is_true(v265)) {
  create_closure(env, f166, &v266);
  closure_of(v266, &v267);
  // preparing environment with 1 slots for call
  create_environment(v267, 1, &v268);
  // looking up the value for take-while
  get_environment(env, 3, 69, &v269);
  closure_of(v269, &v270);
  // preparing environment with 2 slots for call
  create_environment(v270, 2, &v271);
  // looking up the value for input
  get_environment(env, 2, 0, &v272);
  set_environment(v271, 0, v272);
  // looking up the value for string-decision
  get_environment(env, 3, 72, &v273);
  set_environment(v271, 1, v273);
  function_of(v269)(v271, &v274);
  set_environment(v268, 0, v274);
  function_of(v266)(v268, &v275);
    v259 = v275;
  } else {
  create_closure(env, f167, &v276);
  closure_of(v276, &v277);
  // preparing environment with 1 slots for call
  create_environment(v277, 1, &v278);
  // looking up the value for take-while
  get_environment(env, 3, 69, &v279);
  closure_of(v279, &v280);
  // preparing environment with 2 slots for call
  create_environment(v280, 2, &v281);
  // looking up the value for input
  get_environment(env, 2, 0, &v282);
  set_environment(v281, 0, v282);
  // looking up the value for symbol-decision
  get_environment(env, 3, 71, &v283);
  set_environment(v281, 1, v283);
  function_of(v279)(v281, &v284);
  set_environment(v278, 0, v284);
  function_of(v276)(v278, &v285);
    v259 = v285;
  }
    v243 = v259;
  }
    v168 = v243;
  }
    v145 = v168;
  }
    v122 = v145;
  }
    v99 = v122;
  }
    v76 = v99;
  }
    v53 = v76;
  }
    v37 = v53;
  }
    v21 = v37;
  }
    v1 = v21;
  }
  *pReturn = v1;
  pop_stack_slot(285);
  collect(false);
}
// The symbol table for this function is:
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f139(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f168, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f140(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f169, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f141(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f170, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f142(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f171, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f143(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f172, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 4, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-lex
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (variable-id)
// (symbol-value)
// (symbol-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f144(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  create_closure(env, f173, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for lookup
  get_environment(env, 4, 88, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for symbol-value
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for symbol-table
  get_environment(env, 4, 64, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for context
  get_environment(env, 0, 0, &v11);
  set_environment(v10, 0, v11);
  function_of(v8)(v10, &v12);
  set_environment(v6, 1, v12);
  create_number_value(0, &v13);
  set_environment(v6, 2, v13);
  function_of(v4)(v6, &v14);
  set_environment(v3, 0, v14);
  function_of(v1)(v3, &v15);
  *pReturn = v15;
  pop_stack_slot(15);
  collect(false);
}
// The symbol table for this function is:
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f145(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f174, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 4, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 3, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (rest-arguments)
// (first-argument)
// (head arguments)
// (and-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f146(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  create_closure(env, f175, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for list
  get_environment(env, 5, 8, &v4);
  closure_of(v4, &v5);
  // preparing environment with 5 slots for call
  create_environment(v5, 5, &v6);
  create_symbol_value("list-statement", &v7);
  set_environment(v6, 0, v7);
  // looking up the value for cons
  get_environment(env, 5, 7, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  create_symbol_value("symbol-statement", &v11);
  set_environment(v10, 0, v11);
  create_string_value("if", &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
  set_environment(v6, 1, v13);
  // looking up the value for first-argument
  get_environment(env, 1, 0, &v14);
  set_environment(v6, 2, v14);
  // looking up the value for cons
  get_environment(env, 5, 7, &v15);
  closure_of(v15, &v16);
  // preparing environment with 2 slots for call
  create_environment(v16, 2, &v17);
  create_symbol_value("list-statement", &v18);
  set_environment(v17, 0, v18);
  // looking up the value for cons
  get_environment(env, 5, 7, &v19);
  closure_of(v19, &v20);
  // preparing environment with 2 slots for call
  create_environment(v20, 2, &v21);
  // looking up the value for head
  get_environment(env, 2, 0, &v22);
  set_environment(v21, 0, v22);
  // looking up the value for rest-arguments
  get_environment(env, 0, 0, &v23);
  set_environment(v21, 1, v23);
  function_of(v19)(v21, &v24);
  set_environment(v17, 1, v24);
  function_of(v15)(v17, &v25);
  set_environment(v6, 3, v25);
  // looking up the value for cons
  get_environment(env, 5, 7, &v26);
  closure_of(v26, &v27);
  // preparing environment with 2 slots for call
  create_environment(v27, 2, &v28);
  create_symbol_value("bool-statement", &v29);
  set_environment(v28, 0, v29);
  create_boolean_value(false, &v30);
  set_environment(v28, 1, v30);
  function_of(v26)(v28, &v31);
  set_environment(v6, 4, v31);
  function_of(v4)(v6, &v32);
  set_environment(v3, 0, v32);
  function_of(v1)(v3, &v33);
  *pReturn = v33;
  pop_stack_slot(33);
  collect(false);
}
// The symbol table for this function is:
// (rest-arguments)
// (first-argument)
// (head arguments)
// (or-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f147(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  create_closure(env, f176, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for list
  get_environment(env, 5, 8, &v4);
  closure_of(v4, &v5);
  // preparing environment with 5 slots for call
  create_environment(v5, 5, &v6);
  create_symbol_value("list-statement", &v7);
  set_environment(v6, 0, v7);
  // looking up the value for cons
  get_environment(env, 5, 7, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  create_symbol_value("symbol-statement", &v11);
  set_environment(v10, 0, v11);
  create_string_value("if", &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
  set_environment(v6, 1, v13);
  // looking up the value for first-argument
  get_environment(env, 1, 0, &v14);
  set_environment(v6, 2, v14);
  // looking up the value for cons
  get_environment(env, 5, 7, &v15);
  closure_of(v15, &v16);
  // preparing environment with 2 slots for call
  create_environment(v16, 2, &v17);
  create_symbol_value("bool-statement", &v18);
  set_environment(v17, 0, v18);
  create_boolean_value(true, &v19);
  set_environment(v17, 1, v19);
  function_of(v15)(v17, &v20);
  set_environment(v6, 3, v20);
  // looking up the value for cons
  get_environment(env, 5, 7, &v21);
  closure_of(v21, &v22);
  // preparing environment with 2 slots for call
  create_environment(v22, 2, &v23);
  create_symbol_value("list-statement", &v24);
  set_environment(v23, 0, v24);
  // looking up the value for cons
  get_environment(env, 5, 7, &v25);
  closure_of(v25, &v26);
  // preparing environment with 2 slots for call
  create_environment(v26, 2, &v27);
  // looking up the value for head
  get_environment(env, 2, 0, &v28);
  set_environment(v27, 0, v28);
  // looking up the value for rest-arguments
  get_environment(env, 0, 0, &v29);
  set_environment(v27, 1, v29);
  function_of(v25)(v27, &v30);
  set_environment(v23, 1, v30);
  function_of(v21)(v23, &v31);
  set_environment(v6, 4, v31);
  function_of(v4)(v6, &v32);
  set_environment(v3, 0, v32);
  function_of(v1)(v3, &v33);
  *pReturn = v33;
  pop_stack_slot(33);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f148(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f177, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 5, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for cond-statement
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f149(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f178, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function-statement-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (arguments-symbols)
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f150(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f179, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cddr
  get_environment(env, 5, 29, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement-list
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f151(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f180, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 5, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-statement-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (quoted-statement-type)
// (context)
// (variable-id)
// (quoted-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f152(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  ekans_value* v66 = NULL;
  push_stack_slot(&v66);
  ekans_value* v67 = NULL;
  push_stack_slot(&v67);
  ekans_value* v68 = NULL;
  push_stack_slot(&v68);
  ekans_value* v69 = NULL;
  push_stack_slot(&v69);
  ekans_value* v70 = NULL;
  push_stack_slot(&v70);
  ekans_value* v71 = NULL;
  push_stack_slot(&v71);
  ekans_value* v72 = NULL;
  push_stack_slot(&v72);
  ekans_value* v73 = NULL;
  push_stack_slot(&v73);
  ekans_value* v74 = NULL;
  push_stack_slot(&v74);
  ekans_value* v75 = NULL;
  push_stack_slot(&v75);
  ekans_value* v76 = NULL;
  push_stack_slot(&v76);
  ekans_value* v77 = NULL;
  push_stack_slot(&v77);
  ekans_value* v78 = NULL;
  push_stack_slot(&v78);
  ekans_value* v79 = NULL;
  push_stack_slot(&v79);
  ekans_value* v80 = NULL;
  push_stack_slot(&v80);
  ekans_value* v81 = NULL;
  push_stack_slot(&v81);
  ekans_value* v82 = NULL;
  push_stack_slot(&v82);
  ekans_value* v83 = NULL;
  push_stack_slot(&v83);
  ekans_value* v84 = NULL;
  push_stack_slot(&v84);
  ekans_value* v85 = NULL;
  push_stack_slot(&v85);
  ekans_value* v86 = NULL;
  push_stack_slot(&v86);
  ekans_value* v87 = NULL;
  push_stack_slot(&v87);
  ekans_value* v88 = NULL;
  push_stack_slot(&v88);
  ekans_value* v89 = NULL;
  push_stack_slot(&v89);
  ekans_value* v90 = NULL;
  push_stack_slot(&v90);
  ekans_value* v91 = NULL;
  push_stack_slot(&v91);
  ekans_value* v92 = NULL;
  push_stack_slot(&v92);
  ekans_value* v93 = NULL;
  push_stack_slot(&v93);
  ekans_value* v94 = NULL;
  push_stack_slot(&v94);
  ekans_value* v95 = NULL;
  push_stack_slot(&v95);
  ekans_value* v96 = NULL;
  push_stack_slot(&v96);
  ekans_value* v97 = NULL;
  push_stack_slot(&v97);
  ekans_value* v98 = NULL;
  push_stack_slot(&v98);
  ekans_value* v99 = NULL;
  push_stack_slot(&v99);
  ekans_value* v100 = NULL;
  push_stack_slot(&v100);
  ekans_value* v101 = NULL;
  push_stack_slot(&v101);
  ekans_value* v102 = NULL;
  push_stack_slot(&v102);
  ekans_value* v103 = NULL;
  push_stack_slot(&v103);
  ekans_value* v104 = NULL;
  push_stack_slot(&v104);
  ekans_value* v105 = NULL;
  push_stack_slot(&v105);
  ekans_value* v106 = NULL;
  push_stack_slot(&v106);
  ekans_value* v107 = NULL;
  push_stack_slot(&v107);
  // looking up the value for eq?
  get_environment(env, 5, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for quoted-statement-type
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("number-statement", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
  // looking up the value for generate-number-statement
  get_environment(env, 4, 23, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for quoted-statement
  get_environment(env, 3, 0, &v11);
  set_environment(v10, 0, v11);
  // looking up the value for context
  get_environment(env, 1, 0, &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
    v1 = v13;
  } else {
  // looking up the value for eq?
  get_environment(env, 5, 10, &v15);
  closure_of(v15, &v16);
  // preparing environment with 2 slots for call
  create_environment(v16, 2, &v17);
  // looking up the value for quoted-statement-type
  get_environment(env, 0, 0, &v18);
  set_environment(v17, 0, v18);
  create_symbol_value("bool-statement", &v19);
  set_environment(v17, 1, v19);
  function_of(v15)(v17, &v20);
  if (is_true(v20)) {
  // looking up the value for generate-bool-statement
  get_environment(env, 4, 24, &v21);
  closure_of(v21, &v22);
  // preparing environment with 2 slots for call
  create_environment(v22, 2, &v23);
  // looking up the value for quoted-statement
  get_environment(env, 3, 0, &v24);
  set_environment(v23, 0, v24);
  // looking up the value for context
  get_environment(env, 1, 0, &v25);
  set_environment(v23, 1, v25);
  function_of(v21)(v23, &v26);
    v14 = v26;
  } else {
  // looking up the value for eq?
  get_environment(env, 5, 10, &v28);
  closure_of(v28, &v29);
  // preparing environment with 2 slots for call
  create_environment(v29, 2, &v30);
  // looking up the value for quoted-statement-type
  get_environment(env, 0, 0, &v31);
  set_environment(v30, 0, v31);
  create_symbol_value("char-statement", &v32);
  set_environment(v30, 1, v32);
  function_of(v28)(v30, &v33);
  if (is_true(v33)) {
  // looking up the value for generate-char-statement
  get_environment(env, 4, 25, &v34);
  closure_of(v34, &v35);
  // preparing environment with 2 slots for call
  create_environment(v35, 2, &v36);
  // looking up the value for quoted-statement
  get_environment(env, 3, 0, &v37);
  set_environment(v36, 0, v37);
  // looking up the value for context
  get_environment(env, 1, 0, &v38);
  set_environment(v36, 1, v38);
  function_of(v34)(v36, &v39);
    v27 = v39;
  } else {
  // looking up the value for eq?
  get_environment(env, 5, 10, &v41);
  closure_of(v41, &v42);
  // preparing environment with 2 slots for call
  create_environment(v42, 2, &v43);
  // looking up the value for quoted-statement-type
  get_environment(env, 0, 0, &v44);
  set_environment(v43, 0, v44);
  create_symbol_value("string-statement", &v45);
  set_environment(v43, 1, v45);
  function_of(v41)(v43, &v46);
  if (is_true(v46)) {
  // looking up the value for generate-string-statement
  get_environment(env, 4, 26, &v47);
  closure_of(v47, &v48);
  // preparing environment with 2 slots for call
  create_environment(v48, 2, &v49);
  // looking up the value for quoted-statement
  get_environment(env, 3, 0, &v50);
  set_environment(v49, 0, v50);
  // looking up the value for context
  get_environment(env, 1, 0, &v51);
  set_environment(v49, 1, v51);
  function_of(v47)(v49, &v52);
    v40 = v52;
  } else {
  // looking up the value for eq?
  get_environment(env, 5, 10, &v54);
  closure_of(v54, &v55);
  // preparing environment with 2 slots for call
  create_environment(v55, 2, &v56);
  // looking up the value for quoted-statement-type
  get_environment(env, 0, 0, &v57);
  set_environment(v56, 0, v57);
  create_symbol_value("list-statement", &v58);
  set_environment(v56, 1, v58);
  function_of(v54)(v56, &v59);
  if (is_true(v59)) {
  // looking up the value for generate-list-statement-quoted
  get_environment(env, 4, 35, &v60);
  closure_of(v60, &v61);
  // preparing environment with 2 slots for call
  create_environment(v61, 2, &v62);
  // looking up the value for quoted-statement
  get_environment(env, 3, 0, &v63);
  set_environment(v62, 0, v63);
  // looking up the value for context
  get_environment(env, 1, 0, &v64);
  set_environment(v62, 1, v64);
  function_of(v60)(v62, &v65);
    v53 = v65;
  } else {
  // looking up the value for eq?
  get_environment(env, 5, 10, &v67);
  closure_of(v67, &v68);
  // preparing environment with 2 slots for call
  create_environment(v68, 2, &v69);
  // looking up the value for quoted-statement-type
  get_environment(env, 0, 0, &v70);
  set_environment(v69, 0, v70);
  create_symbol_value("symbol-statement", &v71);
  set_environment(v69, 1, v71);
  function_of(v67)(v69, &v72);
  if (is_true(v72)) {
  // looking up the value for list
  get_environment(env, 5, 8, &v73);
  closure_of(v73, &v74);
  // preparing environment with 3 slots for call
  create_environment(v74, 3, &v75);
  // looking up the value for string-append
  get_environment(env, 5, 25, &v76);
  closure_of(v76, &v77);
  // preparing environment with 2 slots for call
  create_environment(v77, 2, &v78);
  // looking up the value for format
  get_environment(env, 5, 26, &v79);
  closure_of(v79, &v80);
  // preparing environment with 3 slots for call
  create_environment(v80, 3, &v81);
  create_string_value("  create_symbol_value(\"~a\", &v~a);\n", &v82);
  set_environment(v81, 0, v82);
  // looking up the value for cdr
  get_environment(env, 5, 15, &v83);
  closure_of(v83, &v84);
  // preparing environment with 1 slots for call
  create_environment(v84, 1, &v85);
  // looking up the value for quoted-statement
  get_environment(env, 3, 0, &v86);
  set_environment(v85, 0, v86);
  function_of(v83)(v85, &v87);
  set_environment(v81, 1, v87);
  // looking up the value for variable-id
  get_environment(env, 2, 0, &v88);
  set_environment(v81, 2, v88);
  function_of(v79)(v81, &v89);
  set_environment(v78, 0, v89);
  // looking up the value for optional-collect
  get_environment(env, 4, 19, &v90);
  closure_of(v90, &v91);
  // preparing environment with 0 slots for call
  create_environment(v91, 0, &v92);
  function_of(v90)(v92, &v93);
  set_environment(v78, 1, v93);
  function_of(v76)(v78, &v94);
  set_environment(v75, 0, v94);
  // looking up the value for variable-id
  get_environment(env, 2, 0, &v95);
  set_environment(v75, 1, v95);
  // looking up the value for context
  get_environment(env, 1, 0, &v96);
  set_environment(v75, 2, v96);
  function_of(v73)(v75, &v97);
    v66 = v97;
  } else {
  // looking up the value for error
  get_environment(env, 5, 22, &v98);
  closure_of(v98, &v99);
  // preparing environment with 1 slots for call
  create_environment(v99, 1, &v100);
  // looking up the value for format
  get_environment(env, 5, 26, &v101);
  closure_of(v101, &v102);
  // preparing environment with 2 slots for call
  create_environment(v102, 2, &v103);
  create_string_value("[log] Error: Unknown quoted statement type ~a", &v104);
  set_environment(v103, 0, v104);
  // looking up the value for quoted-statement-type
  get_environment(env, 0, 0, &v105);
  set_environment(v103, 1, v105);
  function_of(v101)(v103, &v106);
  set_environment(v100, 0, v106);
  function_of(v98)(v100, &v107);
    v66 = v107;
  }
    v53 = v66;
  }
    v40 = v53;
  }
    v27 = v40;
  }
    v14 = v27;
  }
    v1 = v14;
  }
  *pReturn = v1;
  pop_stack_slot(107);
  collect(false);
}
// The symbol table for this function is:
// (values)
// (symbols)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f153(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f181, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cddr
  get_environment(env, 5, 29, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for list-statement-list
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (binding-head)
// (body)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f154(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f182, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 5, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for bindings
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (expression-result)
// (index)
// (expression)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f155(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f183, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for expression-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f156(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f184, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 5, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-statement-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f157(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f185, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for push-symbols
  get_environment(env, 4, 65, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for define-names
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 3, 1, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (argument-rest)
// (argument-code)
// (argument-result)
// (arguments prefix index environment-id context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f158(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f186, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for argument-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f159(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f187, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (statements-code)
// (statements-result)
// (original-context)
// (function-id statements context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f160(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f188, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 5, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statements-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (values)
// (names)
// (defines)
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f161(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  // looking up the value for cons
  get_environment(env, 5, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for names
  get_environment(env, 1, 0, &v4);
  set_environment(v3, 0, v4);
  // looking up the value for values
  get_environment(env, 0, 0, &v5);
  set_environment(v3, 1, v5);
  function_of(v1)(v3, &v6);
  *pReturn = v6;
  pop_stack_slot(6);
  collect(false);
}
// The symbol table for this function is:
// (all-function-code)
// (all-function-result)
// (initial-context)
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f162(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f189, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 5, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for all-function-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (result-value)
// (result)
// (decision)
// (input condition)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f163(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f190, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 5, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (token)
// (keyword)
// (keyword-pair)
// (input keywords)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f164(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f191, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for match
  get_environment(env, 4, 76, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for input
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for keyword
  get_environment(env, 1, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (number-result)
// (peek)
// (lexer-keywords-result)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f165(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  // looking up the value for token-end?
  get_environment(env, 4, 74, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for cdr
  get_environment(env, 5, 15, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for number-result
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  function_of(v2)(v4, &v10);
  if (is_true(v10)) {
    // looking up the value for cons
  get_environment(env, 5, 7, &v11);
  closure_of(v11, &v12);
  // preparing environment with 2 slots for call
  create_environment(v12, 2, &v13);
  // looking up the value for cons
  get_environment(env, 5, 7, &v14);
  closure_of(v14, &v15);
  // preparing environment with 2 slots for call
  create_environment(v15, 2, &v16);
  create_symbol_value("number", &v17);
  set_environment(v16, 0, v17);
  // looking up the value for digits-to-number
  get_environment(env, 4, 73, &v18);
  closure_of(v18, &v19);
  // preparing environment with 2 slots for call
  create_environment(v19, 2, &v20);
  // looking up the value for car
  get_environment(env, 5, 14, &v21);
  closure_of(v21, &v22);
  // preparing environment with 1 slots for call
  create_environment(v22, 1, &v23);
  // looking up the value for number-result
  get_environment(env, 0, 0, &v24);
  set_environment(v23, 0, v24);
  function_of(v21)(v23, &v25);
  set_environment(v20, 0, v25);
  create_number_value(0, &v26);
  set_environment(v20, 1, v26);
  function_of(v18)(v20, &v27);
  set_environment(v16, 1, v27);
  function_of(v14)(v16, &v28);
  set_environment(v13, 0, v28);
  // looking up the value for cdr
  get_environment(env, 5, 15, &v29);
  closure_of(v29, &v30);
  // preparing environment with 1 slots for call
  create_environment(v30, 1, &v31);
  // looking up the value for number-result
  get_environment(env, 0, 0, &v32);
  set_environment(v31, 0, v32);
  function_of(v29)(v31, &v33);
  set_environment(v13, 1, v33);
  function_of(v11)(v13, &v34);
    v1 = v34;
  } else {
    // looking up the value for cons
  get_environment(env, 5, 7, &v35);
  closure_of(v35, &v36);
  // preparing environment with 2 slots for call
  create_environment(v36, 2, &v37);
  // looking up the value for cons
  get_environment(env, 5, 7, &v38);
  closure_of(v38, &v39);
  // preparing environment with 2 slots for call
  create_environment(v39, 2, &v40);
  create_symbol_value("unknown", &v41);
  set_environment(v40, 0, v41);
  create_nil_value(&v43);
  set_environment(v40, 1, v43);
  function_of(v38)(v40, &v44);
  set_environment(v37, 0, v44);
  create_nil_value(&v46);
  set_environment(v37, 1, v46);
  function_of(v35)(v37, &v47);
    v1 = v47;
  }
  *pReturn = v1;
  pop_stack_slot(47);
  collect(false);
}
// The symbol table for this function is:
// (string-result)
// (peek)
// (lexer-keywords-result)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f166(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  // looking up the value for token-end?
  get_environment(env, 4, 74, &v2);
  closure_of(v2, &v3);
  // preparing environment with 1 slots for call
  create_environment(v3, 1, &v4);
  // looking up the value for cddr
  get_environment(env, 5, 29, &v5);
  closure_of(v5, &v6);
  // preparing environment with 1 slots for call
  create_environment(v6, 1, &v7);
  // looking up the value for string-result
  get_environment(env, 0, 0, &v8);
  set_environment(v7, 0, v8);
  function_of(v5)(v7, &v9);
  set_environment(v4, 0, v9);
  function_of(v2)(v4, &v10);
  if (is_true(v10)) {
    // looking up the value for cons
  get_environment(env, 5, 7, &v11);
  closure_of(v11, &v12);
  // preparing environment with 2 slots for call
  create_environment(v12, 2, &v13);
  // looking up the value for cons
  get_environment(env, 5, 7, &v14);
  closure_of(v14, &v15);
  // preparing environment with 2 slots for call
  create_environment(v15, 2, &v16);
  create_symbol_value("string", &v17);
  set_environment(v16, 0, v17);
  // looking up the value for list->string
  get_environment(env, 5, 24, &v18);
  closure_of(v18, &v19);
  // preparing environment with 1 slots for call
  create_environment(v19, 1, &v20);
  // looking up the value for cdar
  get_environment(env, 5, 34, &v21);
  closure_of(v21, &v22);
  // preparing environment with 1 slots for call
  create_environment(v22, 1, &v23);
  // looking up the value for string-result
  get_environment(env, 0, 0, &v24);
  set_environment(v23, 0, v24);
  function_of(v21)(v23, &v25);
  set_environment(v20, 0, v25);
  function_of(v18)(v20, &v26);
  set_environment(v16, 1, v26);
  function_of(v14)(v16, &v27);
  set_environment(v13, 0, v27);
  // looking up the value for cddr
  get_environment(env, 5, 29, &v28);
  closure_of(v28, &v29);
  // preparing environment with 1 slots for call
  create_environment(v29, 1, &v30);
  // looking up the value for string-result
  get_environment(env, 0, 0, &v31);
  set_environment(v30, 0, v31);
  function_of(v28)(v30, &v32);
  set_environment(v13, 1, v32);
  function_of(v11)(v13, &v33);
    v1 = v33;
  } else {
    // looking up the value for cons
  get_environment(env, 5, 7, &v34);
  closure_of(v34, &v35);
  // preparing environment with 2 slots for call
  create_environment(v35, 2, &v36);
  // looking up the value for cons
  get_environment(env, 5, 7, &v37);
  closure_of(v37, &v38);
  // preparing environment with 2 slots for call
  create_environment(v38, 2, &v39);
  create_symbol_value("unknown", &v40);
  set_environment(v39, 0, v40);
  create_nil_value(&v42);
  set_environment(v39, 1, v42);
  function_of(v37)(v39, &v43);
  set_environment(v36, 0, v43);
  create_nil_value(&v45);
  set_environment(v36, 1, v45);
  function_of(v34)(v36, &v46);
    v1 = v46;
  }
  *pReturn = v1;
  pop_stack_slot(46);
  collect(false);
}
// The symbol table for this function is:
// (symbol-result)
// (peek)
// (lexer-keywords-result)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f167(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f192, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for symbol-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f168(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f193, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-token
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f169(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f194, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-token
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f170(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f195, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-token
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f171(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f196, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-token
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f172(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f197, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 5, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-token
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (lookup-result)
// (context)
// (variable-id)
// (symbol-value)
// (symbol-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f173(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f198, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 6, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for lookup-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f174(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f199, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 5, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 4, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (if-statement)
// (rest-arguments)
// (first-argument)
// (head arguments)
// (and-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f175(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  // looking up the value for generate-statement
  get_environment(env, 5, 40, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for if-statement
  get_environment(env, 0, 0, &v4);
  set_environment(v3, 0, v4);
  // looking up the value for context
  get_environment(env, 4, 1, &v5);
  set_environment(v3, 1, v5);
  function_of(v1)(v3, &v6);
  *pReturn = v6;
  pop_stack_slot(6);
  collect(false);
}
// The symbol table for this function is:
// (if-statement)
// (rest-arguments)
// (first-argument)
// (head arguments)
// (or-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f176(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  // looking up the value for generate-statement
  get_environment(env, 5, 40, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for if-statement
  get_environment(env, 0, 0, &v4);
  set_environment(v3, 0, v4);
  // looking up the value for context
  get_environment(env, 4, 1, &v5);
  set_environment(v3, 1, v5);
  function_of(v1)(v3, &v6);
  *pReturn = v6;
  pop_stack_slot(6);
  collect(false);
}
// The symbol table for this function is:
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f177(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f200, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 6, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-branch
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f178(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f201, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 6, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function-statement-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function-body)
// (arguments-symbols)
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f179(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f202, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-function-id
  get_environment(env, 5, 61, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 4, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f180(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f203, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 6, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-statement-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (body)
// (values)
// (symbols)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f181(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  create_closure(env, f204, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cons
  get_environment(env, 6, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  create_symbol_value("list-statement", &v7);
  set_environment(v6, 0, v7);
  // looking up the value for cons
  get_environment(env, 6, 7, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for cons
  get_environment(env, 6, 7, &v11);
  closure_of(v11, &v12);
  // preparing environment with 2 slots for call
  create_environment(v12, 2, &v13);
  create_symbol_value("symbol-statement", &v14);
  set_environment(v13, 0, v14);
  create_string_value("lambda", &v15);
  set_environment(v13, 1, v15);
  function_of(v11)(v13, &v16);
  set_environment(v10, 0, v16);
  // looking up the value for cons
  get_environment(env, 6, 7, &v17);
  closure_of(v17, &v18);
  // preparing environment with 2 slots for call
  create_environment(v18, 2, &v19);
  // looking up the value for cons
  get_environment(env, 6, 7, &v20);
  closure_of(v20, &v21);
  // preparing environment with 2 slots for call
  create_environment(v21, 2, &v22);
  create_symbol_value("list-statement", &v23);
  set_environment(v22, 0, v23);
  // looking up the value for symbols
  get_environment(env, 2, 0, &v24);
  set_environment(v22, 1, v24);
  function_of(v20)(v22, &v25);
  set_environment(v19, 0, v25);
  // looking up the value for body
  get_environment(env, 0, 0, &v26);
  set_environment(v19, 1, v26);
  function_of(v17)(v19, &v27);
  set_environment(v10, 1, v27);
  function_of(v8)(v10, &v28);
  set_environment(v6, 1, v28);
  function_of(v4)(v6, &v29);
  set_environment(v3, 0, v29);
  function_of(v1)(v3, &v30);
  *pReturn = v30;
  pop_stack_slot(30);
  collect(false);
}
// The symbol table for this function is:
// (binding-tail)
// (binding-head)
// (body)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f182(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f205, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for list
  get_environment(env, 6, 8, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  create_symbol_value("list-statement", &v7);
  set_environment(v6, 0, v7);
  // looking up the value for binding-head
  get_environment(env, 1, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (expression-code)
// (expression-result)
// (index)
// (expression)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f183(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f206, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 6, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for expression-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f184(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f207, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 6, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-statement-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f185(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f208, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 5, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (argument-variable)
// (argument-rest)
// (argument-code)
// (argument-result)
// (arguments prefix index environment-id context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f186(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f209, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 6, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for argument-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f187(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f210, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 6, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (statements-variable)
// (statements-code)
// (statements-result)
// (original-context)
// (function-id statements context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f188(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f211, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 6, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for statements-result
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (all-function-count)
// (all-function-code)
// (all-function-result)
// (initial-context)
// (statements)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f189(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  // looking up the value for string-append
  get_environment(env, 6, 25, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for prologue
  get_environment(env, 5, 21, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for all-function-count
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for all-function-code
  get_environment(env, 1, 0, &v9);
  set_environment(v3, 1, v9);
  // looking up the value for epilogue
  get_environment(env, 5, 57, &v10);
  closure_of(v10, &v11);
  // preparing environment with 0 slots for call
  create_environment(v11, 0, &v12);
  function_of(v10)(v12, &v13);
  set_environment(v3, 2, v13);
  function_of(v1)(v3, &v14);
  *pReturn = v14;
  pop_stack_slot(14);
  collect(false);
}
// The symbol table for this function is:
// (result-tail)
// (result-value)
// (result)
// (decision)
// (input condition)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f190(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  // looking up the value for cons
  get_environment(env, 6, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for cons
  get_environment(env, 6, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for car
  get_environment(env, 6, 14, &v7);
  closure_of(v7, &v8);
  // preparing environment with 1 slots for call
  create_environment(v8, 1, &v9);
  // looking up the value for input
  get_environment(env, 4, 0, &v10);
  set_environment(v9, 0, v10);
  function_of(v7)(v9, &v11);
  set_environment(v6, 0, v11);
  // looking up the value for result-value
  get_environment(env, 1, 0, &v12);
  set_environment(v6, 1, v12);
  function_of(v4)(v6, &v13);
  set_environment(v3, 0, v13);
  // looking up the value for result-tail
  get_environment(env, 0, 0, &v14);
  set_environment(v3, 1, v14);
  function_of(v1)(v3, &v15);
  *pReturn = v15;
  pop_stack_slot(15);
  collect(false);
}
// The symbol table for this function is:
// (match-result)
// (token)
// (keyword)
// (keyword-pair)
// (input keywords)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f191(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  // looking up the value for not
  get_environment(env, 6, 4, &v3);
  closure_of(v3, &v4);
  // preparing environment with 1 slots for call
  create_environment(v4, 1, &v5);
  // looking up the value for null?
  get_environment(env, 6, 12, &v6);
  closure_of(v6, &v7);
  // preparing environment with 1 slots for call
  create_environment(v7, 1, &v8);
  // looking up the value for match-result
  get_environment(env, 0, 0, &v9);
  set_environment(v8, 0, v9);
  function_of(v6)(v8, &v10);
  set_environment(v5, 0, v10);
  function_of(v3)(v5, &v11);
  if (is_true(v11)) {
    // looking up the value for token-end?
  get_environment(env, 5, 74, &v13);
  closure_of(v13, &v14);
  // preparing environment with 1 slots for call
  create_environment(v14, 1, &v15);
  // looking up the value for car
  get_environment(env, 6, 14, &v16);
  closure_of(v16, &v17);
  // preparing environment with 1 slots for call
  create_environment(v17, 1, &v18);
  // looking up the value for match-result
  get_environment(env, 0, 0, &v19);
  set_environment(v18, 0, v19);
  function_of(v16)(v18, &v20);
  set_environment(v15, 0, v20);
  function_of(v13)(v15, &v21);
  if (is_true(v21)) {
    create_boolean_value(true, &v22);
    v12 = v22;
  } else {
    create_boolean_value(false, &v23);
    v12 = v23;
  }
    v2 = v12;
  } else {
    create_boolean_value(false, &v24);
    v2 = v24;
  }
  if (is_true(v2)) {
    // looking up the value for cons
  get_environment(env, 6, 7, &v25);
  closure_of(v25, &v26);
  // preparing environment with 2 slots for call
  create_environment(v26, 2, &v27);
  // looking up the value for token
  get_environment(env, 1, 0, &v28);
  set_environment(v27, 0, v28);
  // looking up the value for car
  get_environment(env, 6, 14, &v29);
  closure_of(v29, &v30);
  // preparing environment with 1 slots for call
  create_environment(v30, 1, &v31);
  // looking up the value for match-result
  get_environment(env, 0, 0, &v32);
  set_environment(v31, 0, v32);
  function_of(v29)(v31, &v33);
  set_environment(v27, 1, v33);
  function_of(v25)(v27, &v34);
    v1 = v34;
  } else {
    // looking up the value for lexer-keywords
  get_environment(env, 5, 77, &v35);
  closure_of(v35, &v36);
  // preparing environment with 2 slots for call
  create_environment(v36, 2, &v37);
  // looking up the value for input
  get_environment(env, 4, 0, &v38);
  set_environment(v37, 0, v38);
  // looking up the value for cdr
  get_environment(env, 6, 15, &v39);
  closure_of(v39, &v40);
  // preparing environment with 1 slots for call
  create_environment(v40, 1, &v41);
  // looking up the value for keywords
  get_environment(env, 4, 1, &v42);
  set_environment(v41, 0, v42);
  function_of(v39)(v41, &v43);
  set_environment(v37, 1, v43);
  function_of(v35)(v37, &v44);
    v1 = v44;
  }
  *pReturn = v1;
  pop_stack_slot(44);
  collect(false);
}
// The symbol table for this function is:
// (symbol)
// (symbol-result)
// (peek)
// (lexer-keywords-result)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f192(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f212, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for list->string
  get_environment(env, 6, 24, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for symbol
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f193(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  // looking up the value for eq?
  get_environment(env, 6, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("eof", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
  // looking up the value for cons
  get_environment(env, 6, 7, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  create_nil_value(&v12);
  set_environment(v10, 0, v12);
  create_nil_value(&v14);
  set_environment(v10, 1, v14);
  function_of(v8)(v10, &v15);
    v1 = v15;
  } else {
  create_closure(env, f213, &v16);
  closure_of(v16, &v17);
  // preparing environment with 1 slots for call
  create_environment(v17, 1, &v18);
  // looking up the value for parse-statement
  get_environment(env, 5, 81, &v19);
  closure_of(v19, &v20);
  // preparing environment with 1 slots for call
  create_environment(v20, 1, &v21);
  // looking up the value for input
  get_environment(env, 4, 0, &v22);
  set_environment(v21, 0, v22);
  function_of(v19)(v21, &v23);
  set_environment(v18, 0, v23);
  function_of(v16)(v18, &v24);
    v1 = v24;
  }
  *pReturn = v1;
  pop_stack_slot(24);
  collect(false);
}
// The symbol table for this function is:
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f194(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  ekans_value* v66 = NULL;
  push_stack_slot(&v66);
  ekans_value* v67 = NULL;
  push_stack_slot(&v67);
  ekans_value* v68 = NULL;
  push_stack_slot(&v68);
  ekans_value* v69 = NULL;
  push_stack_slot(&v69);
  ekans_value* v70 = NULL;
  push_stack_slot(&v70);
  ekans_value* v71 = NULL;
  push_stack_slot(&v71);
  ekans_value* v72 = NULL;
  push_stack_slot(&v72);
  ekans_value* v73 = NULL;
  push_stack_slot(&v73);
  ekans_value* v74 = NULL;
  push_stack_slot(&v74);
  ekans_value* v75 = NULL;
  push_stack_slot(&v75);
  ekans_value* v76 = NULL;
  push_stack_slot(&v76);
  ekans_value* v77 = NULL;
  push_stack_slot(&v77);
  ekans_value* v78 = NULL;
  push_stack_slot(&v78);
  ekans_value* v79 = NULL;
  push_stack_slot(&v79);
  ekans_value* v80 = NULL;
  push_stack_slot(&v80);
  ekans_value* v81 = NULL;
  push_stack_slot(&v81);
  ekans_value* v82 = NULL;
  push_stack_slot(&v82);
  ekans_value* v83 = NULL;
  push_stack_slot(&v83);
  ekans_value* v84 = NULL;
  push_stack_slot(&v84);
  ekans_value* v85 = NULL;
  push_stack_slot(&v85);
  ekans_value* v86 = NULL;
  push_stack_slot(&v86);
  ekans_value* v87 = NULL;
  push_stack_slot(&v87);
  ekans_value* v88 = NULL;
  push_stack_slot(&v88);
  ekans_value* v89 = NULL;
  push_stack_slot(&v89);
  ekans_value* v90 = NULL;
  push_stack_slot(&v90);
  ekans_value* v91 = NULL;
  push_stack_slot(&v91);
  ekans_value* v92 = NULL;
  push_stack_slot(&v92);
  ekans_value* v93 = NULL;
  push_stack_slot(&v93);
  ekans_value* v94 = NULL;
  push_stack_slot(&v94);
  ekans_value* v95 = NULL;
  push_stack_slot(&v95);
  ekans_value* v96 = NULL;
  push_stack_slot(&v96);
  ekans_value* v97 = NULL;
  push_stack_slot(&v97);
  ekans_value* v98 = NULL;
  push_stack_slot(&v98);
  ekans_value* v99 = NULL;
  push_stack_slot(&v99);
  ekans_value* v100 = NULL;
  push_stack_slot(&v100);
  ekans_value* v101 = NULL;
  push_stack_slot(&v101);
  ekans_value* v102 = NULL;
  push_stack_slot(&v102);
  ekans_value* v103 = NULL;
  push_stack_slot(&v103);
  ekans_value* v104 = NULL;
  push_stack_slot(&v104);
  ekans_value* v105 = NULL;
  push_stack_slot(&v105);
  ekans_value* v106 = NULL;
  push_stack_slot(&v106);
  ekans_value* v107 = NULL;
  push_stack_slot(&v107);
  ekans_value* v108 = NULL;
  push_stack_slot(&v108);
  ekans_value* v109 = NULL;
  push_stack_slot(&v109);
  ekans_value* v110 = NULL;
  push_stack_slot(&v110);
  ekans_value* v111 = NULL;
  push_stack_slot(&v111);
  ekans_value* v112 = NULL;
  push_stack_slot(&v112);
  ekans_value* v113 = NULL;
  push_stack_slot(&v113);
  ekans_value* v114 = NULL;
  push_stack_slot(&v114);
  ekans_value* v115 = NULL;
  push_stack_slot(&v115);
  ekans_value* v116 = NULL;
  push_stack_slot(&v116);
  ekans_value* v117 = NULL;
  push_stack_slot(&v117);
  ekans_value* v118 = NULL;
  push_stack_slot(&v118);
  ekans_value* v119 = NULL;
  push_stack_slot(&v119);
  ekans_value* v120 = NULL;
  push_stack_slot(&v120);
  ekans_value* v121 = NULL;
  push_stack_slot(&v121);
  ekans_value* v122 = NULL;
  push_stack_slot(&v122);
  ekans_value* v123 = NULL;
  push_stack_slot(&v123);
  ekans_value* v124 = NULL;
  push_stack_slot(&v124);
  ekans_value* v125 = NULL;
  push_stack_slot(&v125);
  ekans_value* v126 = NULL;
  push_stack_slot(&v126);
  ekans_value* v127 = NULL;
  push_stack_slot(&v127);
  ekans_value* v128 = NULL;
  push_stack_slot(&v128);
  ekans_value* v129 = NULL;
  push_stack_slot(&v129);
  ekans_value* v130 = NULL;
  push_stack_slot(&v130);
  ekans_value* v131 = NULL;
  push_stack_slot(&v131);
  ekans_value* v132 = NULL;
  push_stack_slot(&v132);
  ekans_value* v133 = NULL;
  push_stack_slot(&v133);
  ekans_value* v134 = NULL;
  push_stack_slot(&v134);
  ekans_value* v135 = NULL;
  push_stack_slot(&v135);
  // looking up the value for eq?
  get_environment(env, 6, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("number", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
  // looking up the value for cons
  get_environment(env, 6, 7, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for cons
  get_environment(env, 6, 7, &v11);
  closure_of(v11, &v12);
  // preparing environment with 2 slots for call
  create_environment(v12, 2, &v13);
  create_symbol_value("number-statement", &v14);
  set_environment(v13, 0, v14);
  // looking up the value for cdr
  get_environment(env, 6, 15, &v15);
  closure_of(v15, &v16);
  // preparing environment with 1 slots for call
  create_environment(v16, 1, &v17);
  // looking up the value for first-token
  get_environment(env, 2, 0, &v18);
  set_environment(v17, 0, v18);
  function_of(v15)(v17, &v19);
  set_environment(v13, 1, v19);
  function_of(v11)(v13, &v20);
  set_environment(v10, 0, v20);
  // looking up the value for first-rest
  get_environment(env, 1, 0, &v21);
  set_environment(v10, 1, v21);
  function_of(v8)(v10, &v22);
    v1 = v22;
  } else {
  // looking up the value for eq?
  get_environment(env, 6, 10, &v24);
  closure_of(v24, &v25);
  // preparing environment with 2 slots for call
  create_environment(v25, 2, &v26);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v27);
  set_environment(v26, 0, v27);
  create_symbol_value("bool", &v28);
  set_environment(v26, 1, v28);
  function_of(v24)(v26, &v29);
  if (is_true(v29)) {
  // looking up the value for cons
  get_environment(env, 6, 7, &v30);
  closure_of(v30, &v31);
  // preparing environment with 2 slots for call
  create_environment(v31, 2, &v32);
  // looking up the value for cons
  get_environment(env, 6, 7, &v33);
  closure_of(v33, &v34);
  // preparing environment with 2 slots for call
  create_environment(v34, 2, &v35);
  create_symbol_value("bool-statement", &v36);
  set_environment(v35, 0, v36);
  // looking up the value for cdr
  get_environment(env, 6, 15, &v37);
  closure_of(v37, &v38);
  // preparing environment with 1 slots for call
  create_environment(v38, 1, &v39);
  // looking up the value for first-token
  get_environment(env, 2, 0, &v40);
  set_environment(v39, 0, v40);
  function_of(v37)(v39, &v41);
  set_environment(v35, 1, v41);
  function_of(v33)(v35, &v42);
  set_environment(v32, 0, v42);
  // looking up the value for first-rest
  get_environment(env, 1, 0, &v43);
  set_environment(v32, 1, v43);
  function_of(v30)(v32, &v44);
    v23 = v44;
  } else {
  // looking up the value for eq?
  get_environment(env, 6, 10, &v46);
  closure_of(v46, &v47);
  // preparing environment with 2 slots for call
  create_environment(v47, 2, &v48);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v49);
  set_environment(v48, 0, v49);
  create_symbol_value("character", &v50);
  set_environment(v48, 1, v50);
  function_of(v46)(v48, &v51);
  if (is_true(v51)) {
  // looking up the value for cons
  get_environment(env, 6, 7, &v52);
  closure_of(v52, &v53);
  // preparing environment with 2 slots for call
  create_environment(v53, 2, &v54);
  // looking up the value for cons
  get_environment(env, 6, 7, &v55);
  closure_of(v55, &v56);
  // preparing environment with 2 slots for call
  create_environment(v56, 2, &v57);
  create_symbol_value("char-statement", &v58);
  set_environment(v57, 0, v58);
  // looking up the value for cdr
  get_environment(env, 6, 15, &v59);
  closure_of(v59, &v60);
  // preparing environment with 1 slots for call
  create_environment(v60, 1, &v61);
  // looking up the value for first-token
  get_environment(env, 2, 0, &v62);
  set_environment(v61, 0, v62);
  function_of(v59)(v61, &v63);
  set_environment(v57, 1, v63);
  function_of(v55)(v57, &v64);
  set_environment(v54, 0, v64);
  // looking up the value for first-rest
  get_environment(env, 1, 0, &v65);
  set_environment(v54, 1, v65);
  function_of(v52)(v54, &v66);
    v45 = v66;
  } else {
  // looking up the value for eq?
  get_environment(env, 6, 10, &v68);
  closure_of(v68, &v69);
  // preparing environment with 2 slots for call
  create_environment(v69, 2, &v70);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v71);
  set_environment(v70, 0, v71);
  create_symbol_value("symbol", &v72);
  set_environment(v70, 1, v72);
  function_of(v68)(v70, &v73);
  if (is_true(v73)) {
  // looking up the value for cons
  get_environment(env, 6, 7, &v74);
  closure_of(v74, &v75);
  // preparing environment with 2 slots for call
  create_environment(v75, 2, &v76);
  // looking up the value for cons
  get_environment(env, 6, 7, &v77);
  closure_of(v77, &v78);
  // preparing environment with 2 slots for call
  create_environment(v78, 2, &v79);
  create_symbol_value("symbol-statement", &v80);
  set_environment(v79, 0, v80);
  // looking up the value for cdr
  get_environment(env, 6, 15, &v81);
  closure_of(v81, &v82);
  // preparing environment with 1 slots for call
  create_environment(v82, 1, &v83);
  // looking up the value for first-token
  get_environment(env, 2, 0, &v84);
  set_environment(v83, 0, v84);
  function_of(v81)(v83, &v85);
  set_environment(v79, 1, v85);
  function_of(v77)(v79, &v86);
  set_environment(v76, 0, v86);
  // looking up the value for first-rest
  get_environment(env, 1, 0, &v87);
  set_environment(v76, 1, v87);
  function_of(v74)(v76, &v88);
    v67 = v88;
  } else {
  // looking up the value for eq?
  get_environment(env, 6, 10, &v90);
  closure_of(v90, &v91);
  // preparing environment with 2 slots for call
  create_environment(v91, 2, &v92);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v93);
  set_environment(v92, 0, v93);
  create_symbol_value("string", &v94);
  set_environment(v92, 1, v94);
  function_of(v90)(v92, &v95);
  if (is_true(v95)) {
  // looking up the value for cons
  get_environment(env, 6, 7, &v96);
  closure_of(v96, &v97);
  // preparing environment with 2 slots for call
  create_environment(v97, 2, &v98);
  // looking up the value for cons
  get_environment(env, 6, 7, &v99);
  closure_of(v99, &v100);
  // preparing environment with 2 slots for call
  create_environment(v100, 2, &v101);
  create_symbol_value("string-statement", &v102);
  set_environment(v101, 0, v102);
  // looking up the value for cdr
  get_environment(env, 6, 15, &v103);
  closure_of(v103, &v104);
  // preparing environment with 1 slots for call
  create_environment(v104, 1, &v105);
  // looking up the value for first-token
  get_environment(env, 2, 0, &v106);
  set_environment(v105, 0, v106);
  function_of(v103)(v105, &v107);
  set_environment(v101, 1, v107);
  function_of(v99)(v101, &v108);
  set_environment(v98, 0, v108);
  // looking up the value for first-rest
  get_environment(env, 1, 0, &v109);
  set_environment(v98, 1, v109);
  function_of(v96)(v98, &v110);
    v89 = v110;
  } else {
  // looking up the value for eq?
  get_environment(env, 6, 10, &v112);
  closure_of(v112, &v113);
  // preparing environment with 2 slots for call
  create_environment(v113, 2, &v114);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v115);
  set_environment(v114, 0, v115);
  create_symbol_value("lparen", &v116);
  set_environment(v114, 1, v116);
  function_of(v112)(v114, &v117);
  if (is_true(v117)) {
  // looking up the value for parse-list-statement
  get_environment(env, 5, 83, &v118);
  closure_of(v118, &v119);
  // preparing environment with 1 slots for call
  create_environment(v119, 1, &v120);
  // looking up the value for input
  get_environment(env, 4, 0, &v121);
  set_environment(v120, 0, v121);
  function_of(v118)(v120, &v122);
    v111 = v122;
  } else {
  // looking up the value for eq?
  get_environment(env, 6, 10, &v124);
  closure_of(v124, &v125);
  // preparing environment with 2 slots for call
  create_environment(v125, 2, &v126);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v127);
  set_environment(v126, 0, v127);
  create_symbol_value("quote", &v128);
  set_environment(v126, 1, v128);
  function_of(v124)(v126, &v129);
  if (is_true(v129)) {
  // looking up the value for parse-quote-statement
  get_environment(env, 5, 82, &v130);
  closure_of(v130, &v131);
  // preparing environment with 1 slots for call
  create_environment(v131, 1, &v132);
  // looking up the value for input
  get_environment(env, 4, 0, &v133);
  set_environment(v132, 0, v133);
  function_of(v130)(v132, &v134);
    v123 = v134;
  } else {
  create_symbol_value("error", &v135);
    v123 = v135;
  }
    v111 = v123;
  }
    v89 = v111;
  }
    v67 = v89;
  }
    v45 = v67;
  }
    v23 = v45;
  }
    v1 = v23;
  }
  *pReturn = v1;
  pop_stack_slot(135);
  collect(false);
}
// The symbol table for this function is:
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f195(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  // looking up the value for eq?
  get_environment(env, 6, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("quote", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    create_closure(env, f214, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for parse-statement
  get_environment(env, 5, 81, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for first-rest
  get_environment(env, 1, 0, &v14);
  set_environment(v13, 0, v14);
  function_of(v11)(v13, &v15);
  set_environment(v10, 0, v15);
  function_of(v8)(v10, &v16);
    v1 = v16;
  } else {
    create_symbol_value("error", &v17);
    v1 = v17;
  }
  *pReturn = v1;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f196(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  // looking up the value for eq?
  get_environment(env, 6, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("lparen", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    create_closure(env, f215, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for parse-list-end
  get_environment(env, 5, 84, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for first-rest
  get_environment(env, 1, 0, &v14);
  set_environment(v13, 0, v14);
  function_of(v11)(v13, &v15);
  set_environment(v10, 0, v15);
  function_of(v8)(v10, &v16);
    v1 = v16;
  } else {
    create_symbol_value("error", &v17);
    v1 = v17;
  }
  *pReturn = v1;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f197(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  // looking up the value for eq?
  get_environment(env, 6, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("eof", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
  create_symbol_value("error", &v8);
    v1 = v8;
  } else {
  // looking up the value for eq?
  get_environment(env, 6, 10, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  // looking up the value for first-token-type
  get_environment(env, 0, 0, &v13);
  set_environment(v12, 0, v13);
  create_symbol_value("rparen", &v14);
  set_environment(v12, 1, v14);
  function_of(v10)(v12, &v15);
  if (is_true(v15)) {
  // looking up the value for cons
  get_environment(env, 6, 7, &v16);
  closure_of(v16, &v17);
  // preparing environment with 2 slots for call
  create_environment(v17, 2, &v18);
  create_nil_value(&v20);
  set_environment(v18, 0, v20);
  // looking up the value for first-rest
  get_environment(env, 1, 0, &v21);
  set_environment(v18, 1, v21);
  function_of(v16)(v18, &v22);
    v9 = v22;
  } else {
  create_closure(env, f216, &v23);
  closure_of(v23, &v24);
  // preparing environment with 1 slots for call
  create_environment(v24, 1, &v25);
  // looking up the value for parse-statement
  get_environment(env, 5, 81, &v26);
  closure_of(v26, &v27);
  // preparing environment with 1 slots for call
  create_environment(v27, 1, &v28);
  // looking up the value for input
  get_environment(env, 4, 0, &v29);
  set_environment(v28, 0, v29);
  function_of(v26)(v28, &v30);
  set_environment(v25, 0, v30);
  function_of(v23)(v25, &v31);
    v9 = v31;
  }
    v1 = v9;
  }
  *pReturn = v1;
  pop_stack_slot(31);
  collect(false);
}
// The symbol table for this function is:
// (level)
// (lookup-result)
// (context)
// (variable-id)
// (symbol-value)
// (symbol-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f198(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f217, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 7, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for lookup-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f199(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f218, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statement
  get_environment(env, 6, 40, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for condition
  get_environment(env, 4, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f200(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f219, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cddr
  get_environment(env, 7, 29, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-branch
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f201(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f220, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 7, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (new-function-id)
// (function-body)
// (arguments-symbols)
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f202(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f221, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-function-id
  get_environment(env, 6, 63, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 5, 1, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f203(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f222, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 7, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-statement-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (lambda)
// (body)
// (values)
// (symbols)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f204(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  create_closure(env, f223, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cons
  get_environment(env, 7, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  create_symbol_value("list-statement", &v7);
  set_environment(v6, 0, v7);
  // looking up the value for cons
  get_environment(env, 7, 7, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  // looking up the value for lambda
  get_environment(env, 0, 0, &v11);
  set_environment(v10, 0, v11);
  // looking up the value for values
  get_environment(env, 2, 0, &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
  set_environment(v6, 1, v13);
  function_of(v4)(v6, &v14);
  set_environment(v3, 0, v14);
  function_of(v1)(v3, &v15);
  *pReturn = v15;
  pop_stack_slot(15);
  collect(false);
}
// The symbol table for this function is:
// (head-binding)
// (binding-tail)
// (binding-head)
// (body)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f205(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f224, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cons
  get_environment(env, 7, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  create_symbol_value("list-statement", &v7);
  set_environment(v6, 0, v7);
  // looking up the value for binding-tail
  get_environment(env, 1, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (expression-rest)
// (expression-code)
// (expression-result)
// (index)
// (expression)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f206(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f225, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 7, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for expression-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f207(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f226, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 7, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-statement-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f208(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f227, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 6, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (argument-variable)
// (argument-rest)
// (argument-code)
// (argument-result)
// (arguments prefix index environment-id context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f209(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  // looking up the value for generate-arguments
  get_environment(env, 6, 44, &v1);
  closure_of(v1, &v2);
  // preparing environment with 5 slots for call
  create_environment(v2, 5, &v3);
  // looking up the value for cdr
  get_environment(env, 7, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for arguments
  get_environment(env, 5, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  // looking up the value for string-append
  get_environment(env, 7, 25, &v9);
  closure_of(v9, &v10);
  // preparing environment with 4 slots for call
  create_environment(v10, 4, &v11);
  // looking up the value for prefix
  get_environment(env, 5, 1, &v12);
  set_environment(v11, 0, v12);
  // looking up the value for argument-code
  get_environment(env, 3, 0, &v13);
  set_environment(v11, 1, v13);
  // looking up the value for format
  get_environment(env, 7, 26, &v14);
  closure_of(v14, &v15);
  // preparing environment with 4 slots for call
  create_environment(v15, 4, &v16);
  create_string_value("  set_environment(v~a, ~a, v~a);\n", &v17);
  set_environment(v16, 0, v17);
  // looking up the value for environment-id
  get_environment(env, 5, 3, &v18);
  set_environment(v16, 1, v18);
  // looking up the value for index
  get_environment(env, 5, 2, &v19);
  set_environment(v16, 2, v19);
  // looking up the value for argument-variable
  get_environment(env, 1, 0, &v20);
  set_environment(v16, 3, v20);
  function_of(v14)(v16, &v21);
  set_environment(v11, 2, v21);
  // looking up the value for optional-collect
  get_environment(env, 6, 19, &v22);
  closure_of(v22, &v23);
  // preparing environment with 0 slots for call
  create_environment(v23, 0, &v24);
  function_of(v22)(v24, &v25);
  set_environment(v11, 3, v25);
  function_of(v9)(v11, &v26);
  set_environment(v3, 1, v26);
  // looking up the value for +
  get_environment(env, 7, 0, &v27);
  closure_of(v27, &v28);
  // preparing environment with 2 slots for call
  create_environment(v28, 2, &v29);
  // looking up the value for index
  get_environment(env, 5, 2, &v30);
  set_environment(v29, 0, v30);
  create_number_value(1, &v31);
  set_environment(v29, 1, v31);
  function_of(v27)(v29, &v32);
  set_environment(v3, 2, v32);
  // looking up the value for environment-id
  get_environment(env, 5, 3, &v33);
  set_environment(v3, 3, v33);
  // looking up the value for context
  get_environment(env, 0, 0, &v34);
  set_environment(v3, 4, v34);
  function_of(v1)(v3, &v35);
  *pReturn = v35;
  pop_stack_slot(35);
  collect(false);
}
// The symbol table for this function is:
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f210(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f228, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 7, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (statements-variable)
// (statements-code)
// (statements-result)
// (original-context)
// (function-id statements context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f211(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f229, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for number-of-variables
  get_environment(env, 6, 59, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (symbol-value)
// (symbol)
// (symbol-result)
// (peek)
// (lexer-keywords-result)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f212(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f230, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 7, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for symbol-result
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f213(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  // looking up the value for eq?
  get_environment(env, 7, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("error", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    create_symbol_value("error", &v8);
    v1 = v8;
  } else {
    create_closure(env, f231, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for car
  get_environment(env, 7, 14, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
  set_environment(v11, 0, v16);
  function_of(v9)(v11, &v17);
    v1 = v17;
  }
  *pReturn = v1;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f214(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  // looking up the value for eq?
  get_environment(env, 7, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("error", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    create_symbol_value("error", &v8);
    v1 = v8;
  } else {
    // looking up the value for cons
  get_environment(env, 7, 7, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for cons
  get_environment(env, 7, 7, &v12);
  closure_of(v12, &v13);
  // preparing environment with 2 slots for call
  create_environment(v13, 2, &v14);
  create_symbol_value("quote-statement", &v15);
  set_environment(v14, 0, v15);
  // looking up the value for car
  get_environment(env, 7, 14, &v16);
  closure_of(v16, &v17);
  // preparing environment with 1 slots for call
  create_environment(v17, 1, &v18);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v19);
  set_environment(v18, 0, v19);
  function_of(v16)(v18, &v20);
  set_environment(v14, 1, v20);
  function_of(v12)(v14, &v21);
  set_environment(v11, 0, v21);
  // looking up the value for cdr
  get_environment(env, 7, 15, &v22);
  closure_of(v22, &v23);
  // preparing environment with 1 slots for call
  create_environment(v23, 1, &v24);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v25);
  set_environment(v24, 0, v25);
  function_of(v22)(v24, &v26);
  set_environment(v11, 1, v26);
  function_of(v9)(v11, &v27);
    v1 = v27;
  }
  *pReturn = v1;
  pop_stack_slot(27);
  collect(false);
}
// The symbol table for this function is:
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f215(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  // looking up the value for eq?
  get_environment(env, 7, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("error", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    create_symbol_value("error", &v8);
    v1 = v8;
  } else {
    // looking up the value for cons
  get_environment(env, 7, 7, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for cons
  get_environment(env, 7, 7, &v12);
  closure_of(v12, &v13);
  // preparing environment with 2 slots for call
  create_environment(v13, 2, &v14);
  create_symbol_value("list-statement", &v15);
  set_environment(v14, 0, v15);
  // looking up the value for car
  get_environment(env, 7, 14, &v16);
  closure_of(v16, &v17);
  // preparing environment with 1 slots for call
  create_environment(v17, 1, &v18);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v19);
  set_environment(v18, 0, v19);
  function_of(v16)(v18, &v20);
  set_environment(v14, 1, v20);
  function_of(v12)(v14, &v21);
  set_environment(v11, 0, v21);
  // looking up the value for cdr
  get_environment(env, 7, 15, &v22);
  closure_of(v22, &v23);
  // preparing environment with 1 slots for call
  create_environment(v23, 1, &v24);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v25);
  set_environment(v24, 0, v25);
  function_of(v22)(v24, &v26);
  set_environment(v11, 1, v26);
  function_of(v9)(v11, &v27);
    v1 = v27;
  }
  *pReturn = v1;
  pop_stack_slot(27);
  collect(false);
}
// The symbol table for this function is:
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f216(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  // looking up the value for eq?
  get_environment(env, 7, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("error", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    create_symbol_value("error", &v8);
    v1 = v8;
  } else {
    create_closure(env, f232, &v9);
  closure_of(v9, &v10);
  // preparing environment with 1 slots for call
  create_environment(v10, 1, &v11);
  // looking up the value for car
  get_environment(env, 7, 14, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for parse1
  get_environment(env, 0, 0, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
  set_environment(v11, 0, v16);
  function_of(v9)(v11, &v17);
    v1 = v17;
  }
  *pReturn = v1;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (index)
// (level)
// (lookup-result)
// (context)
// (variable-id)
// (symbol-value)
// (symbol-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f217(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  // looking up the value for list
  get_environment(env, 8, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 8, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for optional-comment
  get_environment(env, 7, 18, &v7);
  closure_of(v7, &v8);
  // preparing environment with 1 slots for call
  create_environment(v8, 1, &v9);
  // looking up the value for format
  get_environment(env, 8, 26, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  create_string_value("  // looking up the value for ~a\n", &v13);
  set_environment(v12, 0, v13);
  // looking up the value for symbol-value
  get_environment(env, 5, 0, &v14);
  set_environment(v12, 1, v14);
  function_of(v10)(v12, &v15);
  set_environment(v9, 0, v15);
  function_of(v7)(v9, &v16);
  set_environment(v6, 0, v16);
  // looking up the value for format
  get_environment(env, 8, 26, &v17);
  closure_of(v17, &v18);
  // preparing environment with 4 slots for call
  create_environment(v18, 4, &v19);
  create_string_value("  get_environment(env, ~a, ~a, &v~a);\n", &v20);
  set_environment(v19, 0, v20);
  // looking up the value for level
  get_environment(env, 1, 0, &v21);
  set_environment(v19, 1, v21);
  // looking up the value for index
  get_environment(env, 0, 0, &v22);
  set_environment(v19, 2, v22);
  // looking up the value for variable-id
  get_environment(env, 4, 0, &v23);
  set_environment(v19, 3, v23);
  function_of(v17)(v19, &v24);
  set_environment(v6, 1, v24);
  // looking up the value for optional-collect
  get_environment(env, 7, 19, &v25);
  closure_of(v25, &v26);
  // preparing environment with 0 slots for call
  create_environment(v26, 0, &v27);
  function_of(v25)(v27, &v28);
  set_environment(v6, 2, v28);
  function_of(v4)(v6, &v29);
  set_environment(v3, 0, v29);
  // looking up the value for variable-id
  get_environment(env, 4, 0, &v30);
  set_environment(v3, 1, v30);
  // looking up the value for context
  get_environment(env, 3, 0, &v31);
  set_environment(v3, 2, v31);
  function_of(v1)(v3, &v32);
  *pReturn = v32;
  pop_stack_slot(32);
  collect(false);
}
// The symbol table for this function is:
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f218(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f233, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 8, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for condition-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f219(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f234, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statement
  get_environment(env, 7, 40, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for first-condition
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 3, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f220(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f235, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 8, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (new-function-id)
// (function-body)
// (arguments-symbols)
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f221(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  create_closure(env, f236, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cons
  get_environment(env, 8, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for arguments-symbols
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for symbol-table
  get_environment(env, 7, 64, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for context
  get_environment(env, 0, 0, &v11);
  set_environment(v10, 0, v11);
  function_of(v8)(v10, &v12);
  set_environment(v6, 1, v12);
  function_of(v4)(v6, &v13);
  set_environment(v3, 0, v13);
  function_of(v1)(v3, &v14);
  *pReturn = v14;
  pop_stack_slot(14);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f222(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  create_closure(env, f237, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-list-statement-quoted
  get_environment(env, 7, 35, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for cons
  get_environment(env, 8, 7, &v7);
  closure_of(v7, &v8);
  // preparing environment with 2 slots for call
  create_environment(v8, 2, &v9);
  create_symbol_value("list-statement", &v10);
  set_environment(v9, 0, v10);
  // looking up the value for cdr
  get_environment(env, 8, 15, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for quoted-list-statement
  get_environment(env, 5, 0, &v14);
  set_environment(v13, 0, v14);
  function_of(v11)(v13, &v15);
  set_environment(v9, 1, v15);
  function_of(v7)(v9, &v16);
  set_environment(v6, 0, v16);
  // looking up the value for context
  get_environment(env, 0, 0, &v17);
  set_environment(v6, 1, v17);
  function_of(v4)(v6, &v18);
  set_environment(v3, 0, v18);
  function_of(v1)(v3, &v19);
  *pReturn = v19;
  pop_stack_slot(19);
  collect(false);
}
// The symbol table for this function is:
// (application)
// (lambda)
// (body)
// (values)
// (symbols)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f223(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  // looking up the value for generate-statement
  get_environment(env, 7, 40, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for application
  get_environment(env, 0, 0, &v4);
  set_environment(v3, 0, v4);
  // looking up the value for context
  get_environment(env, 6, 1, &v5);
  set_environment(v3, 1, v5);
  function_of(v1)(v3, &v6);
  *pReturn = v6;
  pop_stack_slot(6);
  collect(false);
}
// The symbol table for this function is:
// (tail-binding)
// (head-binding)
// (binding-tail)
// (binding-head)
// (body)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f224(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  create_closure(env, f238, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for append
  get_environment(env, 7, 4, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for list
  get_environment(env, 8, 8, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  create_symbol_value("list-statement", &v10);
  set_environment(v9, 0, v10);
  // looking up the value for cons
  get_environment(env, 8, 7, &v11);
  closure_of(v11, &v12);
  // preparing environment with 2 slots for call
  create_environment(v12, 2, &v13);
  create_symbol_value("symbol-statement", &v14);
  set_environment(v13, 0, v14);
  create_string_value("let*", &v15);
  set_environment(v13, 1, v15);
  function_of(v11)(v13, &v16);
  set_environment(v9, 1, v16);
  // looking up the value for tail-binding
  get_environment(env, 0, 0, &v17);
  set_environment(v9, 2, v17);
  function_of(v7)(v9, &v18);
  set_environment(v6, 0, v18);
  // looking up the value for body
  get_environment(env, 4, 0, &v19);
  set_environment(v6, 1, v19);
  function_of(v4)(v6, &v20);
  set_environment(v3, 0, v20);
  function_of(v1)(v3, &v21);
  *pReturn = v21;
  pop_stack_slot(21);
  collect(false);
}
// The symbol table for this function is:
// (expression-var)
// (expression-rest)
// (expression-code)
// (expression-result)
// (index)
// (expression)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f225(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  create_closure(env, f239, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for string-append
  get_environment(env, 8, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for expression-code
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for format
  get_environment(env, 8, 26, &v8);
  closure_of(v8, &v9);
  // preparing environment with 3 slots for call
  create_environment(v9, 3, &v10);
  create_string_value("  set_environment(env, ~a, v~a);\n", &v11);
  set_environment(v10, 0, v11);
  // looking up the value for index
  get_environment(env, 4, 0, &v12);
  set_environment(v10, 1, v12);
  // looking up the value for expression-var
  get_environment(env, 0, 0, &v13);
  set_environment(v10, 2, v13);
  function_of(v8)(v10, &v14);
  set_environment(v6, 1, v14);
  // looking up the value for optional-collect
  get_environment(env, 7, 19, &v15);
  closure_of(v15, &v16);
  // preparing environment with 0 slots for call
  create_environment(v16, 0, &v17);
  function_of(v15)(v17, &v18);
  set_environment(v6, 2, v18);
  function_of(v4)(v6, &v19);
  set_environment(v3, 0, v19);
  function_of(v1)(v3, &v20);
  *pReturn = v20;
  pop_stack_slot(20);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f226(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  create_closure(env, f240, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statements
  get_environment(env, 7, 43, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for cdr
  get_environment(env, 8, 15, &v7);
  closure_of(v7, &v8);
  // preparing environment with 1 slots for call
  create_environment(v8, 1, &v9);
  // looking up the value for statements
  get_environment(env, 6, 0, &v10);
  set_environment(v9, 0, v10);
  function_of(v7)(v9, &v11);
  set_environment(v6, 0, v11);
  // looking up the value for context
  get_environment(env, 0, 0, &v12);
  set_environment(v6, 1, v12);
  // looking up the value for first-statement-variable
  get_environment(env, 1, 0, &v13);
  set_environment(v6, 2, v13);
  function_of(v4)(v6, &v14);
  set_environment(v3, 0, v14);
  function_of(v1)(v3, &v15);
  *pReturn = v15;
  pop_stack_slot(15);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f227(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  create_closure(env, f241, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statements
  get_environment(env, 7, 43, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for set-environment
  get_environment(env, 7, 42, &v7);
  closure_of(v7, &v8);
  // preparing environment with 2 slots for call
  create_environment(v8, 2, &v9);
  // looking up the value for define-values
  get_environment(env, 3, 0, &v10);
  set_environment(v9, 0, v10);
  create_number_value(0, &v11);
  set_environment(v9, 1, v11);
  function_of(v7)(v9, &v12);
  set_environment(v6, 0, v12);
  // looking up the value for context
  get_environment(env, 0, 0, &v13);
  set_environment(v6, 1, v13);
  // looking up the value for result
  get_environment(env, 6, 2, &v14);
  set_environment(v6, 2, v14);
  function_of(v4)(v6, &v15);
  set_environment(v3, 0, v15);
  function_of(v1)(v3, &v16);
  *pReturn = v16;
  pop_stack_slot(16);
  collect(false);
}
// The symbol table for this function is:
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f228(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  create_closure(env, f242, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for list
  get_environment(env, 8, 8, &v4);
  closure_of(v4, &v5);
  // preparing environment with 4 slots for call
  create_environment(v5, 4, &v6);
  create_number_value(0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for number-of-functions
  get_environment(env, 7, 62, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for context
  get_environment(env, 6, 0, &v11);
  set_environment(v10, 0, v11);
  function_of(v8)(v10, &v12);
  set_environment(v6, 1, v12);
  // looking up the value for function-symbol-table
  get_environment(env, 0, 0, &v13);
  set_environment(v6, 2, v13);
  create_nil_value(&v15);
  set_environment(v6, 3, v15);
  function_of(v4)(v6, &v16);
  set_environment(v3, 0, v16);
  function_of(v1)(v3, &v17);
  *pReturn = v17;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (number-of-variables)
// (context)
// (statements-variable)
// (statements-code)
// (statements-result)
// (original-context)
// (function-id statements context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f229(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  // looking up the value for cons
  get_environment(env, 8, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for string-append
  get_environment(env, 8, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 11 slots for call
  create_environment(v5, 11, &v6);
  // looking up the value for optional-comment
  get_environment(env, 7, 18, &v7);
  closure_of(v7, &v8);
  // preparing environment with 1 slots for call
  create_environment(v8, 1, &v9);
  // looking up the value for format
  get_environment(env, 8, 26, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  create_string_value("// The symbol table for this function is:\n~a\n", &v13);
  set_environment(v12, 0, v13);
  // looking up the value for pretty-symbol-table
  get_environment(env, 7, 47, &v14);
  closure_of(v14, &v15);
  // preparing environment with 1 slots for call
  create_environment(v15, 1, &v16);
  // looking up the value for symbol-table
  get_environment(env, 7, 64, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for original-context
  get_environment(env, 5, 0, &v20);
  set_environment(v19, 0, v20);
  function_of(v17)(v19, &v21);
  set_environment(v16, 0, v21);
  function_of(v14)(v16, &v22);
  set_environment(v12, 1, v22);
  function_of(v10)(v12, &v23);
  set_environment(v9, 0, v23);
  function_of(v7)(v9, &v24);
  set_environment(v6, 0, v24);
  // looking up the value for format
  get_environment(env, 8, 26, &v25);
  closure_of(v25, &v26);
  // preparing environment with 2 slots for call
  create_environment(v26, 2, &v27);
  create_string_value("void f~a(ekans_value* env, ekans_value** pReturn) ", &v28);
  set_environment(v27, 0, v28);
  // looking up the value for function-id
  get_environment(env, 6, 0, &v29);
  set_environment(v27, 1, v29);
  function_of(v25)(v27, &v30);
  set_environment(v6, 1, v30);
  // looking up the value for lb
  get_environment(env, 7, 11, &v31);
  set_environment(v6, 2, v31);
  create_string_value("\n", &v32);
  set_environment(v6, 3, v32);
  // looking up the value for generate-temp-declarations
  get_environment(env, 7, 45, &v33);
  closure_of(v33, &v34);
  // preparing environment with 1 slots for call
  create_environment(v34, 1, &v35);
  // looking up the value for number-of-variables
  get_environment(env, 0, 0, &v36);
  set_environment(v35, 0, v36);
  function_of(v33)(v35, &v37);
  set_environment(v6, 4, v37);
  // looking up the value for statements-code
  get_environment(env, 3, 0, &v38);
  set_environment(v6, 5, v38);
  // looking up the value for format
  get_environment(env, 8, 26, &v39);
  closure_of(v39, &v40);
  // preparing environment with 2 slots for call
  create_environment(v40, 2, &v41);
  create_string_value("  *pReturn = v~a;\n", &v42);
  set_environment(v41, 0, v42);
  // looking up the value for statements-variable
  get_environment(env, 2, 0, &v43);
  set_environment(v41, 1, v43);
  function_of(v39)(v41, &v44);
  set_environment(v6, 6, v44);
  // looking up the value for format
  get_environment(env, 8, 26, &v45);
  closure_of(v45, &v46);
  // preparing environment with 2 slots for call
  create_environment(v46, 2, &v47);
  create_string_value("  pop_stack_slot(~a);\n", &v48);
  set_environment(v47, 0, v48);
  // looking up the value for number-of-variables
  get_environment(env, 0, 0, &v49);
  set_environment(v47, 1, v49);
  function_of(v45)(v47, &v50);
  set_environment(v6, 7, v50);
  // looking up the value for generate-collect-statement
  get_environment(env, 7, 22, &v51);
  closure_of(v51, &v52);
  // preparing environment with 0 slots for call
  create_environment(v52, 0, &v53);
  function_of(v51)(v53, &v54);
  set_environment(v6, 8, v54);
  // looking up the value for rb
  get_environment(env, 7, 12, &v55);
  set_environment(v6, 9, v55);
  create_string_value("\n", &v56);
  set_environment(v6, 10, v56);
  function_of(v4)(v6, &v57);
  set_environment(v3, 0, v57);
  // looking up the value for context
  get_environment(env, 1, 0, &v58);
  set_environment(v3, 1, v58);
  function_of(v1)(v3, &v59);
  *pReturn = v59;
  pop_stack_slot(59);
  collect(false);
}
// The symbol table for this function is:
// (tail)
// (symbol-value)
// (symbol)
// (symbol-result)
// (peek)
// (lexer-keywords-result)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f230(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  // looking up the value for cons
  get_environment(env, 8, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for cons
  get_environment(env, 8, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  create_symbol_value("symbol", &v7);
  set_environment(v6, 0, v7);
  // looking up the value for symbol-value
  get_environment(env, 1, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  // looking up the value for tail
  get_environment(env, 0, 0, &v10);
  set_environment(v3, 1, v10);
  function_of(v1)(v3, &v11);
  *pReturn = v11;
  pop_stack_slot(11);
  collect(false);
}
// The symbol table for this function is:
// (first-statement)
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f231(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f243, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 8, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for parse1
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-statement)
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f232(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f244, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 8, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for parse1
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f233(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f245, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 9, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for condition-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f234(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f246, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 9, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-condition-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f235(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f247, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 8, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (new-symbol-table)
// (context)
// (new-function-id)
// (function-body)
// (arguments-symbols)
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f236(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  create_closure(env, f248, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for enqueue-pending-function
  get_environment(env, 8, 66, &v4);
  closure_of(v4, &v5);
  // preparing environment with 4 slots for call
  create_environment(v5, 4, &v6);
  // looking up the value for new-function-id
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for function-body
  get_environment(env, 3, 0, &v8);
  set_environment(v6, 1, v8);
  // looking up the value for new-symbol-table
  get_environment(env, 0, 0, &v9);
  set_environment(v6, 2, v9);
  // looking up the value for context
  get_environment(env, 1, 0, &v10);
  set_environment(v6, 3, v10);
  function_of(v4)(v6, &v11);
  set_environment(v3, 0, v11);
  function_of(v1)(v3, &v12);
  *pReturn = v12;
  pop_stack_slot(12);
  collect(false);
}
// The symbol table for this function is:
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f237(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f249, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 9, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-statement-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (inner)
// (tail-binding)
// (head-binding)
// (binding-tail)
// (binding-head)
// (body)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f238(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  create_closure(env, f250, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for list
  get_environment(env, 9, 8, &v4);
  closure_of(v4, &v5);
  // preparing environment with 4 slots for call
  create_environment(v5, 4, &v6);
  create_symbol_value("list-statement", &v7);
  set_environment(v6, 0, v7);
  // looking up the value for cons
  get_environment(env, 9, 7, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  create_symbol_value("symbol-statement", &v11);
  set_environment(v10, 0, v11);
  create_string_value("let", &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
  set_environment(v6, 1, v13);
  // looking up the value for head-binding
  get_environment(env, 2, 0, &v14);
  set_environment(v6, 2, v14);
  // looking up the value for inner
  get_environment(env, 0, 0, &v15);
  set_environment(v6, 3, v15);
  function_of(v4)(v6, &v16);
  set_environment(v3, 0, v16);
  function_of(v1)(v3, &v17);
  *pReturn = v17;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (expression-code)
// (expression-var)
// (expression-rest)
// (expression-code)
// (expression-result)
// (index)
// (expression)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f239(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f251, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cons
  get_environment(env, 9, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for expression-code
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for expression-rest
  get_environment(env, 2, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f240(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f252, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 9, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-statement-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (define-result)
// (context)
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f241(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f253, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 9, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for define-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f242(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  create_closure(env, f254, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-function
  get_environment(env, 8, 48, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for function-id
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for function-body
  get_environment(env, 2, 0, &v8);
  set_environment(v6, 1, v8);
  // looking up the value for function-context
  get_environment(env, 0, 0, &v9);
  set_environment(v6, 2, v9);
  function_of(v4)(v6, &v10);
  set_environment(v3, 0, v10);
  function_of(v1)(v3, &v11);
  *pReturn = v11;
  pop_stack_slot(11);
  collect(false);
}
// The symbol table for this function is:
// (first-rest)
// (first-statement)
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f243(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f255, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for parse-statements
  get_environment(env, 8, 80, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-rest)
// (first-statement)
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f244(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f256, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for parse-list-end
  get_environment(env, 8, 84, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f245(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f257, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 10, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for condition-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f246(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f258, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 10, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-condition-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f247(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f259, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 9, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (new-symbol-table)
// (context)
// (new-function-id)
// (function-body)
// (arguments-symbols)
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f248(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f260, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 9, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f249(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f261, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 10, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-statement-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (outer)
// (inner)
// (tail-binding)
// (head-binding)
// (binding-tail)
// (binding-head)
// (body)
// (bindings)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f250(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  // looking up the value for generate-statement
  get_environment(env, 9, 40, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for outer
  get_environment(env, 0, 0, &v4);
  set_environment(v3, 0, v4);
  // looking up the value for context
  get_environment(env, 8, 1, &v5);
  set_environment(v3, 1, v5);
  function_of(v1)(v3, &v6);
  *pReturn = v6;
  pop_stack_slot(6);
  collect(false);
}
// The symbol table for this function is:
// (expression-result)
// (expression-code)
// (expression-var)
// (expression-rest)
// (expression-code)
// (expression-result)
// (index)
// (expression)
// (statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f251(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  // looking up the value for expression-result
  get_environment(env, 0, 0, &v1);
  *pReturn = v1;
  pop_stack_slot(1);
  collect(false);
}
// The symbol table for this function is:
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f252(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f262, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 10, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-statement-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (define-code)
// (define-result)
// (context)
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f253(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f263, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 10, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for define-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function-result)
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f254(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f264, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 10, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (parse2)
// (first-rest)
// (first-statement)
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f255(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  // looking up the value for eq?
  get_environment(env, 10, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for parse2
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("error", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    create_symbol_value("error", &v8);
    v1 = v8;
  } else {
    create_closure(env, f265, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for car
  get_environment(env, 10, 14, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for parse2
  get_environment(env, 0, 0, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
  set_environment(v11, 0, v16);
  // looking up the value for cdr
  get_environment(env, 10, 15, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for parse2
  get_environment(env, 0, 0, &v20);
  set_environment(v19, 0, v20);
  function_of(v17)(v19, &v21);
  set_environment(v11, 1, v21);
  function_of(v9)(v11, &v22);
    v1 = v22;
  }
  *pReturn = v1;
  pop_stack_slot(22);
  collect(false);
}
// The symbol table for this function is:
// (parse2)
// (first-rest)
// (first-statement)
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f256(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  // looking up the value for eq?
  get_environment(env, 10, 10, &v2);
  closure_of(v2, &v3);
  // preparing environment with 2 slots for call
  create_environment(v3, 2, &v4);
  // looking up the value for parse2
  get_environment(env, 0, 0, &v5);
  set_environment(v4, 0, v5);
  create_symbol_value("error", &v6);
  set_environment(v4, 1, v6);
  function_of(v2)(v4, &v7);
  if (is_true(v7)) {
    create_symbol_value("error", &v8);
    v1 = v8;
  } else {
    create_closure(env, f266, &v9);
  closure_of(v9, &v10);
  // preparing environment with 2 slots for call
  create_environment(v10, 2, &v11);
  // looking up the value for car
  get_environment(env, 10, 14, &v12);
  closure_of(v12, &v13);
  // preparing environment with 1 slots for call
  create_environment(v13, 1, &v14);
  // looking up the value for parse2
  get_environment(env, 0, 0, &v15);
  set_environment(v14, 0, v15);
  function_of(v12)(v14, &v16);
  set_environment(v11, 0, v16);
  // looking up the value for cdr
  get_environment(env, 10, 15, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for parse2
  get_environment(env, 0, 0, &v20);
  set_environment(v19, 0, v20);
  function_of(v17)(v19, &v21);
  set_environment(v11, 1, v21);
  function_of(v9)(v11, &v22);
    v1 = v22;
  }
  *pReturn = v1;
  pop_stack_slot(22);
  collect(false);
}
// The symbol table for this function is:
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f257(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f267, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 11, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for condition-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f258(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f268, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 11, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-condition-result
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f259(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f269, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 10, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (closure-id)
// (context)
// (new-symbol-table)
// (context)
// (new-function-id)
// (function-body)
// (arguments-symbols)
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f260(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f270, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 10, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (rest-statement-rest)
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f261(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f271, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 11, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-statement-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (rest-statement-rest)
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f262(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f272, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 11, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-statement-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (define-code)
// (define-result)
// (context)
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f263(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  create_closure(env, f273, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statements
  get_environment(env, 10, 43, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for filter
  get_environment(env, 10, 3, &v7);
  closure_of(v7, &v8);
  // preparing environment with 2 slots for call
  create_environment(v8, 2, &v9);
  // looking up the value for not-define?
  get_environment(env, 10, 50, &v10);
  set_environment(v9, 0, v10);
  // looking up the value for statements
  get_environment(env, 9, 0, &v11);
  set_environment(v9, 1, v11);
  function_of(v7)(v9, &v12);
  set_environment(v6, 0, v12);
  // looking up the value for context
  get_environment(env, 0, 0, &v13);
  set_environment(v6, 1, v13);
  // looking up the value for result
  get_environment(env, 9, 2, &v14);
  set_environment(v6, 2, v14);
  function_of(v4)(v6, &v15);
  set_environment(v3, 0, v15);
  function_of(v1)(v3, &v16);
  *pReturn = v16;
  pop_stack_slot(16);
  collect(false);
}
// The symbol table for this function is:
// (function-code)
// (function-result)
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f264(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f274, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 11, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (next-statements last-rest)
// (parse2)
// (first-rest)
// (first-statement)
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f265(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  // looking up the value for cons
  get_environment(env, 11, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for cons
  get_environment(env, 11, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for first-statement
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for next-statements
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  // looking up the value for last-rest
  get_environment(env, 0, 1, &v10);
  set_environment(v3, 1, v10);
  function_of(v1)(v3, &v11);
  *pReturn = v11;
  pop_stack_slot(11);
  collect(false);
}
// The symbol table for this function is:
// (next-statements last-rest)
// (parse2)
// (first-rest)
// (first-statement)
// (parse1)
// (first-token-type)
// (first-rest)
// (first-token)
// (first-lex)
// (input)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f266(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  // looking up the value for cons
  get_environment(env, 11, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for cons
  get_environment(env, 11, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for first-statement
  get_environment(env, 3, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for next-statements
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  // looking up the value for last-rest
  get_environment(env, 0, 1, &v10);
  set_environment(v3, 1, v10);
  function_of(v1)(v3, &v11);
  *pReturn = v11;
  pop_stack_slot(11);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f267(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f275, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statement
  get_environment(env, 11, 40, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for then-body
  get_environment(env, 8, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f268(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  create_closure(env, f276, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statements
  get_environment(env, 11, 43, &v4);
  closure_of(v4, &v5);
  // preparing environment with 3 slots for call
  create_environment(v5, 3, &v6);
  // looking up the value for first-branch-logic
  get_environment(env, 4, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  create_nil_value(&v10);
  set_environment(v6, 2, v10);
  function_of(v4)(v6, &v11);
  set_environment(v3, 0, v11);
  function_of(v1)(v3, &v12);
  *pReturn = v12;
  pop_stack_slot(12);
  collect(false);
}
// The symbol table for this function is:
// (environment-id)
// (context)
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f269(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f277, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 11, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (closure-id)
// (context)
// (new-symbol-table)
// (context)
// (new-function-id)
// (function-body)
// (arguments-symbols)
// (arguments-list)
// (arguments-list-statement)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f270(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  // looking up the value for list
  get_environment(env, 12, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 12, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for format
  get_environment(env, 12, 26, &v7);
  closure_of(v7, &v8);
  // preparing environment with 3 slots for call
  create_environment(v8, 3, &v9);
  create_string_value("  create_closure(env, f~a, &v~a);\n", &v10);
  set_environment(v9, 0, v10);
  // looking up the value for new-function-id
  get_environment(env, 5, 0, &v11);
  set_environment(v9, 1, v11);
  // looking up the value for closure-id
  get_environment(env, 1, 0, &v12);
  set_environment(v9, 2, v12);
  function_of(v7)(v9, &v13);
  set_environment(v6, 0, v13);
  // looking up the value for optional-collect
  get_environment(env, 11, 19, &v14);
  closure_of(v14, &v15);
  // preparing environment with 0 slots for call
  create_environment(v15, 0, &v16);
  function_of(v14)(v16, &v17);
  set_environment(v6, 1, v17);
  function_of(v4)(v6, &v18);
  set_environment(v3, 0, v18);
  // looking up the value for closure-id
  get_environment(env, 1, 0, &v19);
  set_environment(v3, 1, v19);
  // looking up the value for context
  get_environment(env, 0, 0, &v20);
  set_environment(v3, 2, v20);
  function_of(v1)(v3, &v21);
  *pReturn = v21;
  pop_stack_slot(21);
  collect(false);
}
// The symbol table for this function is:
// (rest-statement-variable)
// (rest-statement-rest)
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f271(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f278, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 12, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-statement-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (rest-statement-variable)
// (rest-statement-rest)
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f272(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f279, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 12, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-statement-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (generate-statements-result)
// (context)
// (define-code)
// (define-result)
// (context)
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f273(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f280, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 12, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for generate-statements-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (function-context)
// (function-code)
// (function-result)
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f274(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  create_closure(env, f281, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for append
  get_environment(env, 11, 4, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for queue
  get_environment(env, 7, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for reverse
  get_environment(env, 11, 5, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for pending-functions
  get_environment(env, 11, 67, &v11);
  closure_of(v11, &v12);
  // preparing environment with 1 slots for call
  create_environment(v12, 1, &v13);
  // looking up the value for function-context
  get_environment(env, 0, 0, &v14);
  set_environment(v13, 0, v14);
  function_of(v11)(v13, &v15);
  set_environment(v10, 0, v15);
  function_of(v8)(v10, &v16);
  set_environment(v6, 1, v16);
  function_of(v4)(v6, &v17);
  set_environment(v3, 0, v17);
  function_of(v1)(v3, &v18);
  *pReturn = v18;
  pop_stack_slot(18);
  collect(false);
}
// The symbol table for this function is:
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f275(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f282, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 13, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for then-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f276(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f283, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 13, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-branch-logic-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (environment-id)
// (context)
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f277(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  create_closure(env, f284, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-arguments
  get_environment(env, 12, 44, &v4);
  closure_of(v4, &v5);
  // preparing environment with 5 slots for call
  create_environment(v5, 5, &v6);
  // looking up the value for arguments
  get_environment(env, 9, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for empty-string
  get_environment(env, 12, 15, &v8);
  set_environment(v6, 1, v8);
  create_number_value(0, &v9);
  set_environment(v6, 2, v9);
  // looking up the value for environment-id
  get_environment(env, 1, 0, &v10);
  set_environment(v6, 3, v10);
  // looking up the value for context
  get_environment(env, 0, 0, &v11);
  set_environment(v6, 4, v11);
  function_of(v4)(v6, &v12);
  set_environment(v3, 0, v12);
  function_of(v1)(v3, &v13);
  *pReturn = v13;
  pop_stack_slot(13);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (rest-statement-variable)
// (rest-statement-rest)
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f278(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f285, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 12, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (rest-statement-variable)
// (rest-statement-rest)
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f279(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  // looking up the value for list
  get_environment(env, 13, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 13, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for first-statement-code
  get_environment(env, 8, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for rest-statement-code
  get_environment(env, 3, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  // looking up the value for rest-statement-variable
  get_environment(env, 1, 0, &v10);
  set_environment(v3, 1, v10);
  // looking up the value for context
  get_environment(env, 0, 0, &v11);
  set_environment(v3, 2, v11);
  function_of(v1)(v3, &v12);
  *pReturn = v12;
  pop_stack_slot(12);
  collect(false);
}
// The symbol table for this function is:
// (generate-statements-code)
// (generate-statements-result)
// (context)
// (define-code)
// (define-result)
// (context)
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f280(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f286, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 13, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for generate-statements-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (queue)
// (function-context)
// (function-code)
// (function-result)
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f281(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  create_closure(env, f287, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for list
  get_environment(env, 13, 8, &v4);
  closure_of(v4, &v5);
  // preparing environment with 4 slots for call
  create_environment(v5, 4, &v6);
  create_number_value(0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for number-of-functions
  get_environment(env, 12, 62, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for function-context
  get_environment(env, 1, 0, &v11);
  set_environment(v10, 0, v11);
  function_of(v8)(v10, &v12);
  set_environment(v6, 1, v12);
  create_nil_value(&v14);
  set_environment(v6, 2, v14);
  // looking up the value for queue
  get_environment(env, 0, 0, &v15);
  set_environment(v6, 3, v15);
  function_of(v4)(v6, &v16);
  set_environment(v3, 0, v16);
  function_of(v1)(v3, &v17);
  *pReturn = v17;
  pop_stack_slot(17);
  collect(false);
}
// The symbol table for this function is:
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f282(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f288, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 14, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for then-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-branch-logic-code)
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f283(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f289, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 14, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-branch-logic-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (arguments-result)
// (context)
// (environment-id)
// (context)
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f284(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f290, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 14, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for arguments-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (result-id)
// (context)
// (rest-statement-variable)
// (rest-statement-rest)
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f285(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f291, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 13, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (generate-statements-rest)
// (generate-statements-code)
// (generate-statements-result)
// (context)
// (define-code)
// (define-result)
// (context)
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f286(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  create_closure(env, f292, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cons
  get_environment(env, 14, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for string-append
  get_environment(env, 14, 25, &v7);
  closure_of(v7, &v8);
  // preparing environment with 5 slots for call
  create_environment(v8, 5, &v9);
  // looking up the value for optional-comment
  get_environment(env, 13, 18, &v10);
  closure_of(v10, &v11);
  // preparing environment with 1 slots for call
  create_environment(v11, 1, &v12);
  // looking up the value for format
  get_environment(env, 14, 26, &v13);
  closure_of(v13, &v14);
  // preparing environment with 2 slots for call
  create_environment(v14, 2, &v15);
  create_string_value("// Adding defines here:\n~a", &v16);
  set_environment(v15, 0, v16);
  // looking up the value for pretty-symbol-table
  get_environment(env, 13, 47, &v17);
  closure_of(v17, &v18);
  // preparing environment with 1 slots for call
  create_environment(v18, 1, &v19);
  // looking up the value for symbol-table
  get_environment(env, 13, 64, &v20);
  closure_of(v20, &v21);
  // preparing environment with 1 slots for call
  create_environment(v21, 1, &v22);
  // looking up the value for context
  get_environment(env, 3, 0, &v23);
  set_environment(v22, 0, v23);
  function_of(v20)(v22, &v24);
  set_environment(v19, 0, v24);
  function_of(v17)(v19, &v25);
  set_environment(v15, 1, v25);
  function_of(v13)(v15, &v26);
  set_environment(v12, 0, v26);
  function_of(v10)(v12, &v27);
  set_environment(v9, 0, v27);
  // looking up the value for format
  get_environment(env, 14, 26, &v28);
  closure_of(v28, &v29);
  // preparing environment with 4 slots for call
  create_environment(v29, 4, &v30);
  create_string_value("  create_environment(env, ~a, &v~a);\n  env = v~a;\n", &v31);
  set_environment(v30, 0, v31);
  // looking up the value for length
  get_environment(env, 13, 1, &v32);
  closure_of(v32, &v33);
  // preparing environment with 1 slots for call
  create_environment(v33, 1, &v34);
  // looking up the value for define-names
  get_environment(env, 10, 0, &v35);
  set_environment(v34, 0, v35);
  function_of(v32)(v34, &v36);
  set_environment(v30, 1, v36);
  // looking up the value for environment-id
  get_environment(env, 7, 0, &v37);
  set_environment(v30, 2, v37);
  // looking up the value for environment-id
  get_environment(env, 7, 0, &v38);
  set_environment(v30, 3, v38);
  function_of(v28)(v30, &v39);
  set_environment(v9, 1, v39);
  // looking up the value for optional-collect
  get_environment(env, 13, 19, &v40);
  closure_of(v40, &v41);
  // preparing environment with 0 slots for call
  create_environment(v41, 0, &v42);
  function_of(v40)(v42, &v43);
  set_environment(v9, 2, v43);
  // looking up the value for define-code
  get_environment(env, 4, 0, &v44);
  set_environment(v9, 3, v44);
  // looking up the value for generate-statements-code
  get_environment(env, 1, 0, &v45);
  set_environment(v9, 4, v45);
  function_of(v7)(v9, &v46);
  set_environment(v6, 0, v46);
  // looking up the value for generate-statements-rest
  get_environment(env, 0, 0, &v47);
  set_environment(v6, 1, v47);
  function_of(v4)(v6, &v48);
  set_environment(v3, 0, v48);
  function_of(v1)(v3, &v49);
  *pReturn = v49;
  pop_stack_slot(49);
  collect(false);
}
// The symbol table for this function is:
// (function-context)
// (queue)
// (function-context)
// (function-code)
// (function-result)
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f287(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f293, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-all-functions
  get_environment(env, 13, 46, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for function-context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (then-rest)
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f288(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f294, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 15, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for then-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (first-branch-logic-var)
// (first-branch-logic-code)
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f289(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f295, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 15, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for first-branch-logic-result
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (argument-code)
// (arguments-result)
// (context)
// (environment-id)
// (context)
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f290(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f296, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 15, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for arguments-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (result-id)
// (context)
// (rest-statement-variable)
// (rest-statement-rest)
// (rest-statement-code)
// (rest-statement-result)
// (context)
// (first-statement-variable)
// (first-statement-rest)
// (first-statement-code)
// (first-statement-result)
// (quoted-list-statement variable-id context)
// (list-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f291(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  // looking up the value for list
  get_environment(env, 15, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 15, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 4 slots for call
  create_environment(v5, 4, &v6);
  // looking up the value for first-statement-code
  get_environment(env, 10, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for rest-statement-code
  get_environment(env, 5, 0, &v8);
  set_environment(v6, 1, v8);
  // looking up the value for format
  get_environment(env, 15, 26, &v9);
  closure_of(v9, &v10);
  // preparing environment with 4 slots for call
  create_environment(v10, 4, &v11);
  create_string_value("  create_cons_cell(v~a, v~a, &v~a);\n", &v12);
  set_environment(v11, 0, v12);
  // looking up the value for first-statement-variable
  get_environment(env, 8, 0, &v13);
  set_environment(v11, 1, v13);
  // looking up the value for rest-statement-variable
  get_environment(env, 3, 0, &v14);
  set_environment(v11, 2, v14);
  // looking up the value for result-id
  get_environment(env, 1, 0, &v15);
  set_environment(v11, 3, v15);
  function_of(v9)(v11, &v16);
  set_environment(v6, 2, v16);
  // looking up the value for optional-collect
  get_environment(env, 14, 19, &v17);
  closure_of(v17, &v18);
  // preparing environment with 0 slots for call
  create_environment(v18, 0, &v19);
  function_of(v17)(v19, &v20);
  set_environment(v6, 3, v20);
  function_of(v4)(v6, &v21);
  set_environment(v3, 0, v21);
  // looking up the value for result-id
  get_environment(env, 1, 0, &v22);
  set_environment(v3, 1, v22);
  // looking up the value for context
  get_environment(env, 0, 0, &v23);
  set_environment(v3, 2, v23);
  function_of(v1)(v3, &v24);
  *pReturn = v24;
  pop_stack_slot(24);
  collect(false);
}
// The symbol table for this function is:
// (generate-statements-result)
// (generate-statements-rest)
// (generate-statements-code)
// (generate-statements-result)
// (context)
// (define-code)
// (define-result)
// (context)
// (environment-id)
// (context)
// (define-values)
// (define-names)
// (defines)
// (statements context result)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f292(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  // looking up the value for generate-statements-result
  get_environment(env, 0, 0, &v1);
  *pReturn = v1;
  pop_stack_slot(1);
  collect(false);
}
// The symbol table for this function is:
// (rest-result)
// (function-context)
// (queue)
// (function-context)
// (function-code)
// (function-result)
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f293(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f297, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 15, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (then-variable)
// (then-rest)
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f294(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f298, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 16, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for then-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (first-branch-logic-var)
// (first-branch-logic-code)
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f295(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  create_closure(env, f299, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cons
  get_environment(env, 16, 7, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for head
  get_environment(env, 13, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for cddr
  get_environment(env, 16, 29, &v8);
  closure_of(v8, &v9);
  // preparing environment with 1 slots for call
  create_environment(v9, 1, &v10);
  // looking up the value for cond-statement
  get_environment(env, 14, 0, &v11);
  set_environment(v10, 0, v11);
  function_of(v8)(v10, &v12);
  set_environment(v6, 1, v12);
  function_of(v4)(v6, &v13);
  set_environment(v3, 0, v13);
  function_of(v1)(v3, &v14);
  *pReturn = v14;
  pop_stack_slot(14);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (argument-code)
// (arguments-result)
// (context)
// (environment-id)
// (context)
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f296(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f300, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for new-variable-id
  get_environment(env, 15, 58, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (rest-code)
// (rest-result)
// (function-context)
// (queue)
// (function-context)
// (function-code)
// (function-result)
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f297(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f301, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 16, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for rest-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (then-variable)
// (then-rest)
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f298(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f302, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-statement
  get_environment(env, 16, 40, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for else-body
  get_environment(env, 12, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 0, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (else-logic)
// (context)
// (first-branch-logic-var)
// (first-branch-logic-code)
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f299(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  create_closure(env, f303, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for generate-cond-statement
  get_environment(env, 16, 31, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for else-logic
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for context
  get_environment(env, 1, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  function_of(v1)(v3, &v10);
  *pReturn = v10;
  pop_stack_slot(10);
  collect(false);
}
// The symbol table for this function is:
// (result-id)
// (context)
// (argument-code)
// (arguments-result)
// (context)
// (environment-id)
// (context)
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f300(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f304, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for increment-variable-id
  get_environment(env, 16, 60, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for context
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (rest-count)
// (rest-code)
// (rest-result)
// (function-context)
// (queue)
// (function-context)
// (function-code)
// (function-result)
// (function-context)
// (function-symbol-table)
// (function-body)
// (function-id)
// (queue)
// (function)
// (queue)
// (context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f301(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  // looking up the value for cons
  get_environment(env, 17, 7, &v1);
  closure_of(v1, &v2);
  // preparing environment with 2 slots for call
  create_environment(v2, 2, &v3);
  // looking up the value for string-append
  get_environment(env, 17, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 2 slots for call
  create_environment(v5, 2, &v6);
  // looking up the value for function-code
  get_environment(env, 6, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for rest-code
  get_environment(env, 1, 0, &v8);
  set_environment(v6, 1, v8);
  function_of(v4)(v6, &v9);
  set_environment(v3, 0, v9);
  // looking up the value for +
  get_environment(env, 17, 0, &v10);
  closure_of(v10, &v11);
  // preparing environment with 2 slots for call
  create_environment(v11, 2, &v12);
  // looking up the value for rest-count
  get_environment(env, 0, 0, &v13);
  set_environment(v12, 0, v13);
  create_number_value(1, &v14);
  set_environment(v12, 1, v14);
  function_of(v10)(v12, &v15);
  set_environment(v3, 1, v15);
  function_of(v1)(v3, &v16);
  *pReturn = v16;
  pop_stack_slot(16);
  collect(false);
}
// The symbol table for this function is:
// (else-result)
// (context)
// (then-variable)
// (then-rest)
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f302(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f305, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 18, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for else-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (else-logic-result)
// (else-logic)
// (context)
// (first-branch-logic-var)
// (first-branch-logic-code)
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f303(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f306, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 18, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for else-logic-result
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (result-id)
// (context)
// (argument-code)
// (arguments-result)
// (context)
// (environment-id)
// (context)
// (closure-id)
// (context)
// (function-id)
// (function-rest)
// (function-code)
// (function-statement-result)
// (arguments)
// (function)
// (list-statement-list context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f304(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  // looking up the value for list
  get_environment(env, 18, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 18, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 9 slots for call
  create_environment(v5, 9, &v6);
  // looking up the value for function-code
  get_environment(env, 12, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for format
  get_environment(env, 18, 26, &v8);
  closure_of(v8, &v9);
  // preparing environment with 3 slots for call
  create_environment(v9, 3, &v10);
  create_string_value("  closure_of(v~a, &v~a);\n", &v11);
  set_environment(v10, 0, v11);
  // looking up the value for function-id
  get_environment(env, 10, 0, &v12);
  set_environment(v10, 1, v12);
  // looking up the value for closure-id
  get_environment(env, 8, 0, &v13);
  set_environment(v10, 2, v13);
  function_of(v8)(v10, &v14);
  set_environment(v6, 1, v14);
  // looking up the value for optional-collect
  get_environment(env, 17, 19, &v15);
  closure_of(v15, &v16);
  // preparing environment with 0 slots for call
  create_environment(v16, 0, &v17);
  function_of(v15)(v17, &v18);
  set_environment(v6, 2, v18);
  // looking up the value for optional-comment
  get_environment(env, 17, 18, &v19);
  closure_of(v19, &v20);
  // preparing environment with 1 slots for call
  create_environment(v20, 1, &v21);
  // looking up the value for format
  get_environment(env, 18, 26, &v22);
  closure_of(v22, &v23);
  // preparing environment with 2 slots for call
  create_environment(v23, 2, &v24);
  create_string_value("  // preparing environment with ~a slots for call\n", &v25);
  set_environment(v24, 0, v25);
  // looking up the value for length
  get_environment(env, 17, 1, &v26);
  closure_of(v26, &v27);
  // preparing environment with 1 slots for call
  create_environment(v27, 1, &v28);
  // looking up the value for arguments
  get_environment(env, 14, 0, &v29);
  set_environment(v28, 0, v29);
  function_of(v26)(v28, &v30);
  set_environment(v24, 1, v30);
  function_of(v22)(v24, &v31);
  set_environment(v21, 0, v31);
  function_of(v19)(v21, &v32);
  set_environment(v6, 3, v32);
  // looking up the value for format
  get_environment(env, 18, 26, &v33);
  closure_of(v33, &v34);
  // preparing environment with 4 slots for call
  create_environment(v34, 4, &v35);
  create_string_value("  create_environment(v~a, ~a, &v~a);\n", &v36);
  set_environment(v35, 0, v36);
  // looking up the value for closure-id
  get_environment(env, 8, 0, &v37);
  set_environment(v35, 1, v37);
  // looking up the value for length
  get_environment(env, 17, 1, &v38);
  closure_of(v38, &v39);
  // preparing environment with 1 slots for call
  create_environment(v39, 1, &v40);
  // looking up the value for arguments
  get_environment(env, 14, 0, &v41);
  set_environment(v40, 0, v41);
  function_of(v38)(v40, &v42);
  set_environment(v35, 2, v42);
  // looking up the value for environment-id
  get_environment(env, 6, 0, &v43);
  set_environment(v35, 3, v43);
  function_of(v33)(v35, &v44);
  set_environment(v6, 4, v44);
  // looking up the value for optional-collect
  get_environment(env, 17, 19, &v45);
  closure_of(v45, &v46);
  // preparing environment with 0 slots for call
  create_environment(v46, 0, &v47);
  function_of(v45)(v47, &v48);
  set_environment(v6, 5, v48);
  // looking up the value for argument-code
  get_environment(env, 3, 0, &v49);
  set_environment(v6, 6, v49);
  // looking up the value for format
  get_environment(env, 18, 26, &v50);
  closure_of(v50, &v51);
  // preparing environment with 4 slots for call
  create_environment(v51, 4, &v52);
  create_string_value("  function_of(v~a)(v~a, &v~a);\n", &v53);
  set_environment(v52, 0, v53);
  // looking up the value for function-id
  get_environment(env, 10, 0, &v54);
  set_environment(v52, 1, v54);
  // looking up the value for environment-id
  get_environment(env, 6, 0, &v55);
  set_environment(v52, 2, v55);
  // looking up the value for result-id
  get_environment(env, 1, 0, &v56);
  set_environment(v52, 3, v56);
  function_of(v50)(v52, &v57);
  set_environment(v6, 7, v57);
  // looking up the value for optional-collect
  get_environment(env, 17, 19, &v58);
  closure_of(v58, &v59);
  // preparing environment with 0 slots for call
  create_environment(v59, 0, &v60);
  function_of(v58)(v60, &v61);
  set_environment(v6, 8, v61);
  function_of(v4)(v6, &v62);
  set_environment(v3, 0, v62);
  // looking up the value for result-id
  get_environment(env, 1, 0, &v63);
  set_environment(v3, 1, v63);
  // looking up the value for context
  get_environment(env, 0, 0, &v64);
  set_environment(v3, 2, v64);
  function_of(v1)(v3, &v65);
  *pReturn = v65;
  pop_stack_slot(65);
  collect(false);
}
// The symbol table for this function is:
// (else-code)
// (else-result)
// (context)
// (then-variable)
// (then-rest)
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f305(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f307, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cdr
  get_environment(env, 19, 15, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for else-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (else-logic-code)
// (else-logic-result)
// (else-logic)
// (context)
// (first-branch-logic-var)
// (first-branch-logic-code)
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f306(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f308, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 19, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for else-logic-result
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (else-rest)
// (else-code)
// (else-result)
// (context)
// (then-variable)
// (then-rest)
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f307(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f309, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for car
  get_environment(env, 20, 14, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for else-rest
  get_environment(env, 0, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (else-logic-var)
// (else-logic-code)
// (else-logic-result)
// (else-logic)
// (context)
// (first-branch-logic-var)
// (first-branch-logic-code)
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f308(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f310, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for caddr
  get_environment(env, 20, 28, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for else-logic-result
  get_environment(env, 2, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (else-variable)
// (else-rest)
// (else-code)
// (else-result)
// (context)
// (then-variable)
// (then-rest)
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f309(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  create_closure(env, f311, &v1);
  closure_of(v1, &v2);
  // preparing environment with 1 slots for call
  create_environment(v2, 1, &v3);
  // looking up the value for cadr
  get_environment(env, 21, 27, &v4);
  closure_of(v4, &v5);
  // preparing environment with 1 slots for call
  create_environment(v5, 1, &v6);
  // looking up the value for else-rest
  get_environment(env, 1, 0, &v7);
  set_environment(v6, 0, v7);
  function_of(v4)(v6, &v8);
  set_environment(v3, 0, v8);
  function_of(v1)(v3, &v9);
  *pReturn = v9;
  pop_stack_slot(9);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (else-logic-var)
// (else-logic-code)
// (else-logic-result)
// (else-logic)
// (context)
// (first-branch-logic-var)
// (first-branch-logic-code)
// (first-branch-logic-result)
// (context)
// (first-condition-var)
// (first-condition-code)
// (first-condition-result)
// (first-branch-logic)
// (first-condition)
// (first-branch)
// (context)
// (result-id)
// (head)
// (cond-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f310(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  // looking up the value for list
  get_environment(env, 21, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 21, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 8 slots for call
  create_environment(v5, 8, &v6);
  // looking up the value for first-condition-code
  get_environment(env, 11, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for format
  get_environment(env, 21, 26, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  create_string_value("  if (is_true(v~a)) {\n", &v11);
  set_environment(v10, 0, v11);
  // looking up the value for first-condition-var
  get_environment(env, 10, 0, &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
  set_environment(v6, 1, v13);
  // looking up the value for first-branch-logic-code
  get_environment(env, 7, 0, &v14);
  set_environment(v6, 2, v14);
  // looking up the value for format
  get_environment(env, 21, 26, &v15);
  closure_of(v15, &v16);
  // preparing environment with 3 slots for call
  create_environment(v16, 3, &v17);
  create_string_value("    v~a = v~a;\n", &v18);
  set_environment(v17, 0, v18);
  // looking up the value for result-id
  get_environment(env, 17, 0, &v19);
  set_environment(v17, 1, v19);
  // looking up the value for first-branch-logic-var
  get_environment(env, 6, 0, &v20);
  set_environment(v17, 2, v20);
  function_of(v15)(v17, &v21);
  set_environment(v6, 3, v21);
  create_string_value("  } else {\n", &v22);
  set_environment(v6, 4, v22);
  // looking up the value for else-logic-code
  get_environment(env, 2, 0, &v23);
  set_environment(v6, 5, v23);
  // looking up the value for format
  get_environment(env, 21, 26, &v24);
  closure_of(v24, &v25);
  // preparing environment with 3 slots for call
  create_environment(v25, 3, &v26);
  create_string_value("    v~a = v~a;\n", &v27);
  set_environment(v26, 0, v27);
  // looking up the value for result-id
  get_environment(env, 17, 0, &v28);
  set_environment(v26, 1, v28);
  // looking up the value for else-logic-var
  get_environment(env, 1, 0, &v29);
  set_environment(v26, 2, v29);
  function_of(v24)(v26, &v30);
  set_environment(v6, 6, v30);
  create_string_value("  }\n", &v31);
  set_environment(v6, 7, v31);
  function_of(v4)(v6, &v32);
  set_environment(v3, 0, v32);
  // looking up the value for result-id
  get_environment(env, 17, 0, &v33);
  set_environment(v3, 1, v33);
  // looking up the value for context
  get_environment(env, 0, 0, &v34);
  set_environment(v3, 2, v34);
  function_of(v1)(v3, &v35);
  *pReturn = v35;
  pop_stack_slot(35);
  collect(false);
}
// The symbol table for this function is:
// (context)
// (else-variable)
// (else-rest)
// (else-code)
// (else-result)
// (context)
// (then-variable)
// (then-rest)
// (then-code)
// (then-result)
// (context)
// (condition-variable)
// (condition-rest)
// (condition-code)
// (condition-result)
// (context)
// (result-id)
// (else-body)
// (then-body)
// (condition)
// (if-statement context)
// (map length args filter append reverse library compiler main lp rp lb rb ls rs empty-string show-comment gc-stress optional-comment optional-collect generate-function-prototypes prologue generate-collect-statement generate-number-statement generate-bool-statement generate-char-statement generate-string-statement generate-symbol-statement generate-if-statement generate-and-statement generate-or-statement generate-cond-statement generate-list-statement generate-application generate-lambda generate-list-statement-quoted generate-statement-quoted generate-let generate-let-star generate-quote-statement generate-statement generate-set-environment-statement set-environment generate-statements generate-arguments generate-temp-declarations generate-all-functions pretty-symbol-table generate-function define? not-define? define-name define-value extract-defines generate-all-code populate-environment generate-build-builtins epilogue new-variable-id number-of-variables increment-variable-id new-function-id number-of-functions increment-function-id symbol-table push-symbols enqueue-pending-function pending-functions digit? take-while digit-decision symbol-decision string-decision digits-to-number token-end? skip-comment match lexer-keywords keywords lexer parse-statements parse-statement parse-quote-statement parse-list-statement parse-list-end builtins initial-symbol-table last-index-of lookup)
// (+ - * / not char<=? char>=? cons list = eq? equal? null? member car cdr char->integer string->list get-args displayln < > error pair? list->string string-append format cadr caddr cddr cddadr cdadr caadr caar cdar cdddr cadddr write-file read-file)

void f311(ekans_value* env, ekans_value** pReturn) {
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  ekans_value* v40 = NULL;
  push_stack_slot(&v40);
  ekans_value* v41 = NULL;
  push_stack_slot(&v41);
  ekans_value* v42 = NULL;
  push_stack_slot(&v42);
  ekans_value* v43 = NULL;
  push_stack_slot(&v43);
  ekans_value* v44 = NULL;
  push_stack_slot(&v44);
  ekans_value* v45 = NULL;
  push_stack_slot(&v45);
  ekans_value* v46 = NULL;
  push_stack_slot(&v46);
  ekans_value* v47 = NULL;
  push_stack_slot(&v47);
  ekans_value* v48 = NULL;
  push_stack_slot(&v48);
  ekans_value* v49 = NULL;
  push_stack_slot(&v49);
  ekans_value* v50 = NULL;
  push_stack_slot(&v50);
  ekans_value* v51 = NULL;
  push_stack_slot(&v51);
  ekans_value* v52 = NULL;
  push_stack_slot(&v52);
  ekans_value* v53 = NULL;
  push_stack_slot(&v53);
  ekans_value* v54 = NULL;
  push_stack_slot(&v54);
  ekans_value* v55 = NULL;
  push_stack_slot(&v55);
  ekans_value* v56 = NULL;
  push_stack_slot(&v56);
  ekans_value* v57 = NULL;
  push_stack_slot(&v57);
  ekans_value* v58 = NULL;
  push_stack_slot(&v58);
  ekans_value* v59 = NULL;
  push_stack_slot(&v59);
  ekans_value* v60 = NULL;
  push_stack_slot(&v60);
  ekans_value* v61 = NULL;
  push_stack_slot(&v61);
  ekans_value* v62 = NULL;
  push_stack_slot(&v62);
  ekans_value* v63 = NULL;
  push_stack_slot(&v63);
  ekans_value* v64 = NULL;
  push_stack_slot(&v64);
  ekans_value* v65 = NULL;
  push_stack_slot(&v65);
  // looking up the value for list
  get_environment(env, 22, 8, &v1);
  closure_of(v1, &v2);
  // preparing environment with 3 slots for call
  create_environment(v2, 3, &v3);
  // looking up the value for string-append
  get_environment(env, 22, 25, &v4);
  closure_of(v4, &v5);
  // preparing environment with 11 slots for call
  create_environment(v5, 11, &v6);
  // looking up the value for condition-code
  get_environment(env, 13, 0, &v7);
  set_environment(v6, 0, v7);
  // looking up the value for format
  get_environment(env, 22, 26, &v8);
  closure_of(v8, &v9);
  // preparing environment with 2 slots for call
  create_environment(v9, 2, &v10);
  create_string_value("  if (is_true(v~a)) {\n", &v11);
  set_environment(v10, 0, v11);
  // looking up the value for condition-variable
  get_environment(env, 11, 0, &v12);
  set_environment(v10, 1, v12);
  function_of(v8)(v10, &v13);
  set_environment(v6, 1, v13);
  // looking up the value for format
  get_environment(env, 22, 26, &v14);
  closure_of(v14, &v15);
  // preparing environment with 2 slots for call
  create_environment(v15, 2, &v16);
  create_string_value("  ~a", &v17);
  set_environment(v16, 0, v17);
  // looking up the value for then-code
  get_environment(env, 8, 0, &v18);
  set_environment(v16, 1, v18);
  function_of(v14)(v16, &v19);
  set_environment(v6, 2, v19);
  // looking up the value for format
  get_environment(env, 22, 26, &v20);
  closure_of(v20, &v21);
  // preparing environment with 3 slots for call
  create_environment(v21, 3, &v22);
  create_string_value("    v~a = v~a;\n", &v23);
  set_environment(v22, 0, v23);
  // looking up the value for result-id
  get_environment(env, 16, 0, &v24);
  set_environment(v22, 1, v24);
  // looking up the value for then-variable
  get_environment(env, 6, 0, &v25);
  set_environment(v22, 2, v25);
  function_of(v20)(v22, &v26);
  set_environment(v6, 3, v26);
  // looking up the value for optional-collect
  get_environment(env, 21, 19, &v27);
  closure_of(v27, &v28);
  // preparing environment with 0 slots for call
  create_environment(v28, 0, &v29);
  function_of(v27)(v29, &v30);
  set_environment(v6, 4, v30);
  // looking up the value for format
  get_environment(env, 22, 26, &v31);
  closure_of(v31, &v32);
  // preparing environment with 1 slots for call
  create_environment(v32, 1, &v33);
  create_string_value("  } else {\n", &v34);
  set_environment(v33, 0, v34);
  function_of(v31)(v33, &v35);
  set_environment(v6, 5, v35);
  // looking up the value for format
  get_environment(env, 22, 26, &v36);
  closure_of(v36, &v37);
  // preparing environment with 2 slots for call
  create_environment(v37, 2, &v38);
  create_string_value("  ~a", &v39);
  set_environment(v38, 0, v39);
  // looking up the value for else-code
  get_environment(env, 3, 0, &v40);
  set_environment(v38, 1, v40);
  function_of(v36)(v38, &v41);
  set_environment(v6, 6, v41);
  // looking up the value for format
  get_environment(env, 22, 26, &v42);
  closure_of(v42, &v43);
  // preparing environment with 3 slots for call
  create_environment(v43, 3, &v44);
  create_string_value("    v~a = v~a;\n", &v45);
  set_environment(v44, 0, v45);
  // looking up the value for result-id
  get_environment(env, 16, 0, &v46);
  set_environment(v44, 1, v46);
  // looking up the value for else-variable
  get_environment(env, 1, 0, &v47);
  set_environment(v44, 2, v47);
  function_of(v42)(v44, &v48);
  set_environment(v6, 7, v48);
  // looking up the value for optional-collect
  get_environment(env, 21, 19, &v49);
  closure_of(v49, &v50);
  // preparing environment with 0 slots for call
  create_environment(v50, 0, &v51);
  function_of(v49)(v51, &v52);
  set_environment(v6, 8, v52);
  // looking up the value for format
  get_environment(env, 22, 26, &v53);
  closure_of(v53, &v54);
  // preparing environment with 1 slots for call
  create_environment(v54, 1, &v55);
  create_string_value("  }\n", &v56);
  set_environment(v55, 0, v56);
  function_of(v53)(v55, &v57);
  set_environment(v6, 9, v57);
  // looking up the value for optional-collect
  get_environment(env, 21, 19, &v58);
  closure_of(v58, &v59);
  // preparing environment with 0 slots for call
  create_environment(v59, 0, &v60);
  function_of(v58)(v60, &v61);
  set_environment(v6, 10, v61);
  function_of(v4)(v6, &v62);
  set_environment(v3, 0, v62);
  // looking up the value for result-id
  get_environment(env, 16, 0, &v63);
  set_environment(v3, 1, v63);
  // looking up the value for context
  get_environment(env, 0, 0, &v64);
  set_environment(v3, 2, v64);
  function_of(v1)(v3, &v65);
  *pReturn = v65;
  pop_stack_slot(65);
  collect(false);
}

void build_builtins(ekans_value** pEnv) {
  create_environment(NULL, 39, pEnv);
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  ekans_value* v2 = NULL;
  push_stack_slot(&v2);
  ekans_value* v3 = NULL;
  push_stack_slot(&v3);
  ekans_value* v4 = NULL;
  push_stack_slot(&v4);
  ekans_value* v5 = NULL;
  push_stack_slot(&v5);
  ekans_value* v6 = NULL;
  push_stack_slot(&v6);
  ekans_value* v7 = NULL;
  push_stack_slot(&v7);
  ekans_value* v8 = NULL;
  push_stack_slot(&v8);
  ekans_value* v9 = NULL;
  push_stack_slot(&v9);
  ekans_value* v10 = NULL;
  push_stack_slot(&v10);
  ekans_value* v11 = NULL;
  push_stack_slot(&v11);
  ekans_value* v12 = NULL;
  push_stack_slot(&v12);
  ekans_value* v13 = NULL;
  push_stack_slot(&v13);
  ekans_value* v14 = NULL;
  push_stack_slot(&v14);
  ekans_value* v15 = NULL;
  push_stack_slot(&v15);
  ekans_value* v16 = NULL;
  push_stack_slot(&v16);
  ekans_value* v17 = NULL;
  push_stack_slot(&v17);
  ekans_value* v18 = NULL;
  push_stack_slot(&v18);
  ekans_value* v19 = NULL;
  push_stack_slot(&v19);
  ekans_value* v20 = NULL;
  push_stack_slot(&v20);
  ekans_value* v21 = NULL;
  push_stack_slot(&v21);
  ekans_value* v22 = NULL;
  push_stack_slot(&v22);
  ekans_value* v23 = NULL;
  push_stack_slot(&v23);
  ekans_value* v24 = NULL;
  push_stack_slot(&v24);
  ekans_value* v25 = NULL;
  push_stack_slot(&v25);
  ekans_value* v26 = NULL;
  push_stack_slot(&v26);
  ekans_value* v27 = NULL;
  push_stack_slot(&v27);
  ekans_value* v28 = NULL;
  push_stack_slot(&v28);
  ekans_value* v29 = NULL;
  push_stack_slot(&v29);
  ekans_value* v30 = NULL;
  push_stack_slot(&v30);
  ekans_value* v31 = NULL;
  push_stack_slot(&v31);
  ekans_value* v32 = NULL;
  push_stack_slot(&v32);
  ekans_value* v33 = NULL;
  push_stack_slot(&v33);
  ekans_value* v34 = NULL;
  push_stack_slot(&v34);
  ekans_value* v35 = NULL;
  push_stack_slot(&v35);
  ekans_value* v36 = NULL;
  push_stack_slot(&v36);
  ekans_value* v37 = NULL;
  push_stack_slot(&v37);
  ekans_value* v38 = NULL;
  push_stack_slot(&v38);
  ekans_value* v39 = NULL;
  push_stack_slot(&v39);
  create_closure(*pEnv, plus, &v1);
  set_environment(*pEnv, 0, v1);
  create_closure(*pEnv, subtract, &v2);
  set_environment(*pEnv, 1, v2);
  create_closure(*pEnv, multiply, &v3);
  set_environment(*pEnv, 2, v3);
  create_closure(*pEnv, division, &v4);
  set_environment(*pEnv, 3, v4);
  create_closure(*pEnv, not, &v5);
  set_environment(*pEnv, 4, v5);
  create_closure(*pEnv, char_le, &v6);
  set_environment(*pEnv, 5, v6);
  create_closure(*pEnv, char_ge, &v7);
  set_environment(*pEnv, 6, v7);
  create_closure(*pEnv, list_cons, &v8);
  set_environment(*pEnv, 7, v8);
  create_closure(*pEnv, list_constructor, &v9);
  set_environment(*pEnv, 8, v9);
  create_closure(*pEnv, equals, &v10);
  set_environment(*pEnv, 9, v10);
  create_closure(*pEnv, equals, &v11);
  set_environment(*pEnv, 10, v11);
  create_closure(*pEnv, equals, &v12);
  set_environment(*pEnv, 11, v12);
  create_closure(*pEnv, is_null, &v13);
  set_environment(*pEnv, 12, v13);
  create_closure(*pEnv, member, &v14);
  set_environment(*pEnv, 13, v14);
  create_closure(*pEnv, car, &v15);
  set_environment(*pEnv, 14, v15);
  create_closure(*pEnv, cdr, &v16);
  set_environment(*pEnv, 15, v16);
  create_closure(*pEnv, char_to_int, &v17);
  set_environment(*pEnv, 16, v17);
  create_closure(*pEnv, string_to_list, &v18);
  set_environment(*pEnv, 17, v18);
  create_closure(*pEnv, args, &v19);
  set_environment(*pEnv, 18, v19);
  create_closure(*pEnv, println, &v20);
  set_environment(*pEnv, 19, v20);
  create_closure(*pEnv, less, &v21);
  set_environment(*pEnv, 20, v21);
  create_closure(*pEnv, greater, &v22);
  set_environment(*pEnv, 21, v22);
  create_closure(*pEnv, failfast, &v23);
  set_environment(*pEnv, 22, v23);
  create_closure(*pEnv, is_pair, &v24);
  set_environment(*pEnv, 23, v24);
  create_closure(*pEnv, list_to_string, &v25);
  set_environment(*pEnv, 24, v25);
  create_closure(*pEnv, string_append, &v26);
  set_environment(*pEnv, 25, v26);
  create_closure(*pEnv, format, &v27);
  set_environment(*pEnv, 26, v27);
  create_closure(*pEnv, cadr, &v28);
  set_environment(*pEnv, 27, v28);
  create_closure(*pEnv, caddr, &v29);
  set_environment(*pEnv, 28, v29);
  create_closure(*pEnv, cddr, &v30);
  set_environment(*pEnv, 29, v30);
  create_closure(*pEnv, cddadr, &v31);
  set_environment(*pEnv, 30, v31);
  create_closure(*pEnv, cdadr, &v32);
  set_environment(*pEnv, 31, v32);
  create_closure(*pEnv, caadr, &v33);
  set_environment(*pEnv, 32, v33);
  create_closure(*pEnv, caar, &v34);
  set_environment(*pEnv, 33, v34);
  create_closure(*pEnv, cdar, &v35);
  set_environment(*pEnv, 34, v35);
  create_closure(*pEnv, cdddr, &v36);
  set_environment(*pEnv, 35, v36);
  create_closure(*pEnv, cadddr, &v37);
  set_environment(*pEnv, 36, v37);
  create_closure(*pEnv, write_file, &v38);
  set_environment(*pEnv, 37, v38);
  create_closure(*pEnv, read_file, &v39);
  set_environment(*pEnv, 38, v39);
  pop_stack_slot(39);
}
int main(int argc, char** argv) {
  initialize_ekans(argc, argv);
  ekans_value* env = NULL;
  push_stack_slot(&env);
  ekans_value* v1 = NULL;
  push_stack_slot(&v1);
  build_builtins(&env);
  f1(env, &v1);
  print_ekans_value(v1);
  pop_stack_slot(2);
  finalize_ekans();
  return 0;
}
